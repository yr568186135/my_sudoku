<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>xutility</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
// xutility internal header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#pragma once
#ifndef _XUTILITY_
#define _XUTILITY_
#include &lt;yvals.h&gt;
#if _STL_COMPILER_PREPROCESSOR

#include &lt;__msvc_iter_core.hpp&gt;
#include &lt;climits&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

#if defined(_CRTBLD) &amp;&amp; defined(CRTDLL2)
// TRANSITION, ABI: The vector algorithms are compiled into the import lib, so we disable their usage when building
// the DLL. (We could additionally link them into the DLL - not as exports, just for internal usage - but we
// haven't chosen to do that yet.) When we can break ABI and export the vector algorithms from the DLL,
// this preprocessor case should be removed.
#ifndef _USE_STD_VECTOR_ALGORITHMS
#define _USE_STD_VECTOR_ALGORITHMS 0
#elif _USE_STD_VECTOR_ALGORITHMS
#error Vector algorithms are not supported when building msvcp140.dll, but _USE_STD_VECTOR_ALGORITHMS is set.
#endif // _USE_STD_VECTOR_ALGORITHMS
#elif (defined(_M_IX86) || defined(_M_X64)) &amp;&amp; !defined(_M_CEE_PURE) &amp;&amp; !defined(_M_HYBRID) &amp;&amp; !defined(_M_ARM64EC)
#ifndef _USE_STD_VECTOR_ALGORITHMS
#define _USE_STD_VECTOR_ALGORITHMS 1
#endif // _USE_STD_VECTOR_ALGORITHMS
#else // ^^^ arch supports vector algorithms / no support for vector algorithms vvv
#ifndef _USE_STD_VECTOR_ALGORITHMS
#define _USE_STD_VECTOR_ALGORITHMS 0
#elif _USE_STD_VECTOR_ALGORITHMS
#error Vector algorithms are not supported on this architecture, but _USE_STD_VECTOR_ALGORITHMS is set.
#endif // _USE_STD_VECTOR_ALGORITHMS
#endif // ^^^ no support for vector algorithms ^^^

#if _USE_STD_VECTOR_ALGORITHMS
_EXTERN_C
// The "noalias" attribute tells the compiler optimizer that pointers going into these hand-vectorized algorithms
// won't be stored beyond the lifetime of the function, and that the function will only reference arrays denoted by
// those pointers. The optimizer also assumes in that case that a pointer parameter is not returned to the caller via
// the return value, so functions using "noalias" must usually return void. This attribute is valuable because these
// functions are in native code objects that the compiler cannot analyze. In the absence of the noalias attribute, the
// compiler has to assume that the denoted arrays are "globally address taken", and that any later calls to
// unanalyzable routines may modify those arrays.
__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_1(void* _First, void* _Last) noexcept;
__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_2(void* _First, void* _Last) noexcept;
__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_4(void* _First, void* _Last) noexcept;
__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_8(void* _First, void* _Last) noexcept;
__declspec(noalias) void __cdecl __std_swap_ranges_trivially_swappable_noalias(
    void* _First1, void* _Last1, void* _First2) noexcept;

__declspec(noalias) size_t
    __stdcall __std_count_trivial_1(const void* _First, const void* _Last, uint8_t _Val) noexcept;
__declspec(noalias) size_t
    __stdcall __std_count_trivial_2(const void* _First, const void* _Last, uint16_t _Val) noexcept;
__declspec(noalias) size_t
    __stdcall __std_count_trivial_4(const void* _First, const void* _Last, uint32_t _Val) noexcept;
__declspec(noalias) size_t
    __stdcall __std_count_trivial_8(const void* _First, const void* _Last, uint64_t _Val) noexcept;

const void* __stdcall __std_find_trivial_1(const void* _First, const void* _Last, uint8_t _Val) noexcept;
const void* __stdcall __std_find_trivial_2(const void* _First, const void* _Last, uint16_t _Val) noexcept;
const void* __stdcall __std_find_trivial_4(const void* _First, const void* _Last, uint32_t _Val) noexcept;
const void* __stdcall __std_find_trivial_8(const void* _First, const void* _Last, uint64_t _Val) noexcept;

const void* __stdcall __std_find_trivial_unsized_1(const void* _First, uint8_t _Val) noexcept;
const void* __stdcall __std_find_trivial_unsized_2(const void* _First, uint16_t _Val) noexcept;
const void* __stdcall __std_find_trivial_unsized_4(const void* _First, uint32_t _Val) noexcept;
const void* __stdcall __std_find_trivial_unsized_8(const void* _First, uint64_t _Val) noexcept;

const void* __stdcall __std_min_element_1(const void* _First, const void* _Last, bool _Signed) noexcept;
const void* __stdcall __std_min_element_2(const void* _First, const void* _Last, bool _Signed) noexcept;
const void* __stdcall __std_min_element_4(const void* _First, const void* _Last, bool _Signed) noexcept;
const void* __stdcall __std_min_element_8(const void* _First, const void* _Last, bool _Signed) noexcept;

const void* __stdcall __std_max_element_1(const void* _First, const void* _Last, bool _Signed) noexcept;
const void* __stdcall __std_max_element_2(const void* _First, const void* _Last, bool _Signed) noexcept;
const void* __stdcall __std_max_element_4(const void* _First, const void* _Last, bool _Signed) noexcept;
const void* __stdcall __std_max_element_8(const void* _First, const void* _Last, bool _Signed) noexcept;
_END_EXTERN_C

template &lt;class _Ty, class _TVal&gt;
__declspec(noalias) size_t __std_count_trivial(_Ty* _First, _Ty* _Last, const _TVal _Val) noexcept {
    if constexpr (_STD is_pointer_v&lt;_TVal&gt; || _STD is_null_pointer_v&lt;_TVal&gt;) {
        return __std_count_trivial(_First, _Last, reinterpret_cast&lt;uintptr_t&gt;(_Val));
    } else if constexpr (sizeof(_Ty) == 1) {
        return __std_count_trivial_1(_First, _Last, static_cast&lt;uint8_t&gt;(_Val));
    } else if constexpr (sizeof(_Ty) == 2) {
        return __std_count_trivial_2(_First, _Last, static_cast&lt;uint16_t&gt;(_Val));
    } else if constexpr (sizeof(_Ty) == 4) {
        return __std_count_trivial_4(_First, _Last, static_cast&lt;uint32_t&gt;(_Val));
    } else if constexpr (sizeof(_Ty) == 8) {
        return __std_count_trivial_8(_First, _Last, static_cast&lt;uint64_t&gt;(_Val));
    } else {
        static_assert(_STD _Always_false&lt;_Ty&gt;, "Unexpected size");
    }
}

template &lt;class _Ty, class _TVal&gt;
_Ty* __std_find_trivial(_Ty* _First, _Ty* _Last, const _TVal _Val) noexcept {
    if constexpr (_STD is_pointer_v&lt;_TVal&gt; || _STD is_null_pointer_v&lt;_TVal&gt;) {
        return __std_find_trivial(_First, _Last, reinterpret_cast&lt;uintptr_t&gt;(_Val));
    } else if constexpr (sizeof(_Ty) == 1) {
        return const_cast&lt;_Ty*&gt;(
            static_cast&lt;const _Ty*&gt;(__std_find_trivial_1(_First, _Last, static_cast&lt;uint8_t&gt;(_Val))));
    } else if constexpr (sizeof(_Ty) == 2) {
        return const_cast&lt;_Ty*&gt;(
            static_cast&lt;const _Ty*&gt;(__std_find_trivial_2(_First, _Last, static_cast&lt;uint16_t&gt;(_Val))));
    } else if constexpr (sizeof(_Ty) == 4) {
        return const_cast&lt;_Ty*&gt;(
            static_cast&lt;const _Ty*&gt;(__std_find_trivial_4(_First, _Last, static_cast&lt;uint32_t&gt;(_Val))));
    } else if constexpr (sizeof(_Ty) == 8) {
        return const_cast&lt;_Ty*&gt;(
            static_cast&lt;const _Ty*&gt;(__std_find_trivial_8(_First, _Last, static_cast&lt;uint64_t&gt;(_Val))));
    } else {
        static_assert(_STD _Always_false&lt;_Ty&gt;, "Unexpected size");
    }
}

template &lt;class _Ty, class _TVal&gt;
_Ty* __std_find_trivial_unsized(_Ty* _First, const _TVal _Val) noexcept {
    if constexpr (_STD is_pointer_v&lt;_TVal&gt; || _STD is_null_pointer_v&lt;_TVal&gt;) {
        return __std_find_trivial_unsized(_First, reinterpret_cast&lt;uintptr_t&gt;(_Val));
    } else if constexpr (sizeof(_Ty) == 1) {
        return const_cast&lt;_Ty*&gt;(
            static_cast&lt;const _Ty*&gt;(__std_find_trivial_unsized_1(_First, static_cast&lt;uint8_t&gt;(_Val))));
    } else if constexpr (sizeof(_Ty) == 2) {
        return const_cast&lt;_Ty*&gt;(
            static_cast&lt;const _Ty*&gt;(__std_find_trivial_unsized_2(_First, static_cast&lt;uint16_t&gt;(_Val))));
    } else if constexpr (sizeof(_Ty) == 4) {
        return const_cast&lt;_Ty*&gt;(
            static_cast&lt;const _Ty*&gt;(__std_find_trivial_unsized_4(_First, static_cast&lt;uint32_t&gt;(_Val))));
    } else if constexpr (sizeof(_Ty) == 8) {
        return const_cast&lt;_Ty*&gt;(
            static_cast&lt;const _Ty*&gt;(__std_find_trivial_unsized_8(_First, static_cast&lt;uint64_t&gt;(_Val))));
    } else {
        static_assert(_STD _Always_false&lt;_Ty&gt;, "Unexpected size");
    }
}

template &lt;class _Ty&gt;
_Ty* __std_min_element(_Ty* _First, _Ty* _Last) noexcept {
    constexpr bool _Signed = _STD is_signed_v&lt;_Ty&gt;;

    if constexpr (sizeof(_Ty) == 1) {
        return const_cast&lt;_Ty*&gt;(static_cast&lt;const _Ty*&gt;(__std_min_element_1(_First, _Last, _Signed)));
    } else if constexpr (sizeof(_Ty) == 2) {
        return const_cast&lt;_Ty*&gt;(static_cast&lt;const _Ty*&gt;(__std_min_element_2(_First, _Last, _Signed)));
    } else if constexpr (sizeof(_Ty) == 4) {
        return const_cast&lt;_Ty*&gt;(static_cast&lt;const _Ty*&gt;(__std_min_element_4(_First, _Last, _Signed)));
    } else if constexpr (sizeof(_Ty) == 8) {
        return const_cast&lt;_Ty*&gt;(static_cast&lt;const _Ty*&gt;(__std_min_element_8(_First, _Last, _Signed)));
    } else {
        static_assert(_STD _Always_false&lt;_Ty&gt;, "Unexpected size");
    }
}

template &lt;class _Ty&gt;
_Ty* __std_max_element(_Ty* _First, _Ty* _Last) noexcept {
    constexpr bool _Signed = _STD is_signed_v&lt;_Ty&gt;;

    if constexpr (sizeof(_Ty) == 1) {
        return const_cast&lt;_Ty*&gt;(static_cast&lt;const _Ty*&gt;(__std_max_element_1(_First, _Last, _Signed)));
    } else if constexpr (sizeof(_Ty) == 2) {
        return const_cast&lt;_Ty*&gt;(static_cast&lt;const _Ty*&gt;(__std_max_element_2(_First, _Last, _Signed)));
    } else if constexpr (sizeof(_Ty) == 4) {
        return const_cast&lt;_Ty*&gt;(static_cast&lt;const _Ty*&gt;(__std_max_element_4(_First, _Last, _Signed)));
    } else if constexpr (sizeof(_Ty) == 8) {
        return const_cast&lt;_Ty*&gt;(static_cast&lt;const _Ty*&gt;(__std_max_element_8(_First, _Last, _Signed)));
    } else {
        static_assert(_STD _Always_false&lt;_Ty&gt;, "Unexpected size");
    }
}

#endif // _USE_STD_VECTOR_ALGORITHMS

_STD_BEGIN

template &lt;class _To, class _From,
    enable_if_t&lt;conjunction_v&lt;bool_constant&lt;sizeof(_To) == sizeof(_From)&gt;, is_trivially_copyable&lt;_To&gt;,
                    is_trivially_copyable&lt;_From&gt;&gt;,
        int&gt; = 0&gt;
_NODISCARD constexpr _To _Bit_cast(const _From&amp; _Val) noexcept {
    return __builtin_bit_cast(_To, _Val);
}

template &lt;class _Ty&gt;
struct _Get_first_parameter;

template &lt;template &lt;class, class...&gt; class _Ty, class _First, class... _Rest&gt;
struct _Get_first_parameter&lt;_Ty&lt;_First, _Rest...&gt;&gt; { // given _Ty&lt;_First, _Rest...&gt;, extract _First
    using type = _First;
};

template &lt;class _Newfirst, class _Ty&gt;
struct _Replace_first_parameter;

template &lt;class _Newfirst, template &lt;class, class...&gt; class _Ty, class _First, class... _Rest&gt;
struct _Replace_first_parameter&lt;_Newfirst, _Ty&lt;_First, _Rest...&gt;&gt; { // given _Ty&lt;_First, _Rest...&gt;, replace _First
    using type = _Ty&lt;_Newfirst, _Rest...&gt;;
};

template &lt;class _Ty, class = void&gt;
struct _Get_ptr_difference_type {
    using type = ptrdiff_t;
};

template &lt;class _Ty&gt;
struct _Get_ptr_difference_type&lt;_Ty, void_t&lt;typename _Ty::difference_type&gt;&gt; {
    using type = typename _Ty::difference_type;
};

template &lt;class _Ty, class _Other, class = void&gt;
struct _Get_rebind_alias {
    using type = typename _Replace_first_parameter&lt;_Other, _Ty&gt;::type;
};

template &lt;class _Ty, class _Other&gt;
struct _Get_rebind_alias&lt;_Ty, _Other, void_t&lt;typename _Ty::template rebind&lt;_Other&gt;&gt;&gt; {
    using type = typename _Ty::template rebind&lt;_Other&gt;;
};

template &lt;class _Iter&gt;
<span style = "background-color:#fdd">_NODISCARD constexpr void* _Voidify_iter(_Iter _It) noexcept {</span>
    if constexpr (is_pointer_v&lt;_Iter&gt;) {
<span style = "background-color:#fdd">        return const_cast&lt;void*&gt;(static_cast&lt;const volatile void*&gt;(_It));</span>
    } else {
        return const_cast&lt;void*&gt;(static_cast&lt;const volatile void*&gt;(_STD addressof(*_It)));
    }
<span style = "background-color:#fdd">}</span>

#if _HAS_CXX20
#ifdef __EDG__ // TRANSITION, DevCom-1691516
_EXPORT_STD template &lt;class _Ty, class... _Types,
    class = void_t&lt;decltype(::new(_STD declval&lt;void*&gt;()) _Ty(_STD declval&lt;_Types&gt;()...))&gt;&gt;
#else // ^^^ no workaround / workaround vvv
_EXPORT_STD template &lt;class _Ty, class... _Types,
    void_t&lt;decltype(::new(_STD declval&lt;void*&gt;()) _Ty(_STD declval&lt;_Types&gt;()...))&gt;* = nullptr&gt;
#endif // TRANSITION, DevCom-1691516
constexpr _Ty* construct_at(_Ty* const _Location, _Types&amp;&amp;... _Args) noexcept(
    noexcept(::new(_Voidify_iter(_Location)) _Ty(_STD forward&lt;_Types&gt;(_Args)...))) /* strengthened */ {
    _MSVC_CONSTEXPR return ::new (_Voidify_iter(_Location)) _Ty(_STD forward&lt;_Types&gt;(_Args)...);
}
#endif // _HAS_CXX20

template &lt;class _Ty, class... _Types&gt;
_CONSTEXPR20 void _Construct_in_place(_Ty&amp; _Obj, _Types&amp;&amp;... _Args) noexcept(
<span style = "background-color:#fdd">    is_nothrow_constructible_v&lt;_Ty, _Types...&gt;) {</span>
#if _HAS_CXX20
    if (_STD is_constant_evaluated()) {
        _STD construct_at(_STD addressof(_Obj), _STD forward&lt;_Types&gt;(_Args)...);
    } else
#endif // _HAS_CXX20
    {
<span style = "background-color:#fdd">        ::new (_Voidify_iter(_STD addressof(_Obj))) _Ty(_STD forward&lt;_Types&gt;(_Args)...);</span>
    }
<span style = "background-color:#fdd">}</span>

template &lt;class _Ty&gt;
void _Default_construct_in_place(_Ty&amp; _Obj) noexcept(is_nothrow_default_constructible_v&lt;_Ty&gt;) {
    ::new (_Voidify_iter(_STD addressof(_Obj))) _Ty;
}

template &lt;class _Ty, class _Elem&gt;
struct _Ptr_traits_base {
    using pointer         = _Ty;
    using element_type    = _Elem;
    using difference_type = typename _Get_ptr_difference_type&lt;_Ty&gt;::type;

    template &lt;class _Other&gt;
    using rebind = typename _Get_rebind_alias&lt;_Ty, _Other&gt;::type;

    using _Reftype = conditional_t&lt;is_void_v&lt;_Elem&gt;, char, _Elem&gt;&amp;;

    _NODISCARD static _CONSTEXPR20 pointer pointer_to(_Reftype _Val) noexcept(
        noexcept(_Ty::pointer_to(_Val))) /* strengthened */ { // Per LWG-3454
        return _Ty::pointer_to(_Val);
    }
};

template &lt;class, class = void, class = void&gt;
struct _Ptr_traits_sfinae_layer {};

template &lt;class _Ty, class _Uty&gt;
struct _Ptr_traits_sfinae_layer&lt;_Ty, _Uty, void_t&lt;typename _Get_first_parameter&lt;_Ty&gt;::type&gt;&gt;
    : _Ptr_traits_base&lt;_Ty, typename _Get_first_parameter&lt;_Ty&gt;::type&gt; {};

template &lt;class _Ty&gt;
struct _Ptr_traits_sfinae_layer&lt;_Ty, void_t&lt;typename _Ty::element_type&gt;, void&gt;
    : _Ptr_traits_base&lt;_Ty, typename _Ty::element_type&gt; {};

_EXPORT_STD template &lt;class _Ty&gt;
struct pointer_traits : _Ptr_traits_sfinae_layer&lt;_Ty&gt; {};

template &lt;class _Ty&gt;
struct pointer_traits&lt;_Ty*&gt; {
    using pointer         = _Ty*;
    using element_type    = _Ty;
    using difference_type = ptrdiff_t;

    template &lt;class _Other&gt;
    using rebind = _Other*;

    using _Reftype = conditional_t&lt;is_void_v&lt;_Ty&gt;, char, _Ty&gt;&amp;;

    _NODISCARD static _CONSTEXPR20 pointer pointer_to(_Reftype _Val) noexcept {
        return _STD addressof(_Val);
    }
};

#if _HAS_CXX20
#ifdef __cpp_lib_concepts
template &lt;class _Ty&gt;
concept _Has_to_address = requires(const _Ty&amp; _Val) {
                              typename pointer_traits&lt;_Ty&gt;;
                              pointer_traits&lt;_Ty&gt;::to_address(_Val);
                          };
#else // ^^^ Use concept / use variable template vvv
template &lt;class _Ty, class = void&gt;
inline constexpr bool _Has_to_address = false; // determines whether pointer_traits&lt;_Ty&gt; has to_address

template &lt;class _Ty&gt;
inline constexpr bool
    _Has_to_address&lt;_Ty, void_t&lt;decltype(pointer_traits&lt;_Ty&gt;::to_address(_STD declval&lt;const _Ty&amp;&gt;()))&gt;&gt; = true;
#endif // __cpp_lib_concepts

_EXPORT_STD template &lt;class _Ty&gt;
_NODISCARD constexpr _Ty* to_address(_Ty* const _Val) noexcept {
    static_assert(!is_function_v&lt;_Ty&gt;,
        "N4810 20.10.4 [pointer.conversion]/2: The program is ill-formed if T is a function type.");
    return _Val;
}

_EXPORT_STD template &lt;class _Ptr&gt;
_NODISCARD constexpr auto to_address(const _Ptr&amp; _Val) noexcept {
    if constexpr (_Has_to_address&lt;_Ptr&gt;) {
        return pointer_traits&lt;_Ptr&gt;::to_address(_Val);
    } else {
        return _STD to_address(_Val.operator-&gt;()); // plain pointer overload must come first
    }
}

_EXPORT_STD struct identity {
    template &lt;class _Ty&gt;
    _NODISCARD constexpr _Ty&amp;&amp; operator()(_Ty&amp;&amp; _Left) const noexcept {
        return _STD forward&lt;_Ty&gt;(_Left);
    }

    using is_transparent = int;
};
#endif // _HAS_CXX20

template &lt;class _Fx&gt;
struct _Ref_fn { // pass function object by value as a reference
    template &lt;class... _Args&gt;
    constexpr decltype(auto) operator()(_Args&amp;&amp;... _Vals) { // forward function call operator
        if constexpr (is_member_pointer_v&lt;_Fx&gt;) {
            return _STD invoke(_Fn, _STD forward&lt;_Args&gt;(_Vals)...);
        } else {
            return _Fn(_STD forward&lt;_Args&gt;(_Vals)...);
        }
    }

    _Fx&amp; _Fn;
};

template &lt;class _Fn&gt;
constexpr auto _Pass_fn(_Fn&amp; _Func) noexcept {
    constexpr bool _Pass_by_value = conjunction_v&lt;bool_constant&lt;sizeof(_Fn) &lt;= sizeof(void*)&gt;,
        is_trivially_copy_constructible&lt;_Fn&gt;, is_trivially_destructible&lt;_Fn&gt;&gt;;
    if constexpr (_Pass_by_value) {
        return _Func;
    } else {
        return _Ref_fn&lt;_Fn&gt;{_Func}; // pass functor by "reference"
    }
}

#if _HAS_CXX23
_EXPORT_STD template &lt;class _Result_type, class _Callable, class... _Types,
    enable_if_t&lt;is_invocable_r_v&lt;_Result_type, _Callable, _Types...&gt;, int&gt; = 0&gt;
_NODISCARD constexpr _Result_type invoke_r(_Callable&amp;&amp; _Obj, _Types&amp;&amp;... _Args) noexcept(
    is_nothrow_invocable_r_v&lt;_Result_type, _Callable, _Types...&gt;) {
    if constexpr (is_void_v&lt;_Result_type&gt;) {
        (void) _STD invoke(static_cast&lt;_Callable&amp;&amp;&gt;(_Obj), static_cast&lt;_Types&amp;&amp;&gt;(_Args)...);
    } else {
        return _STD invoke(static_cast&lt;_Callable&amp;&amp;&gt;(_Obj), static_cast&lt;_Types&amp;&amp;&gt;(_Args)...);
    }
}
#endif // _HAS_CXX23

struct _Unused_parameter { // generic unused parameter struct
    constexpr _Unused_parameter() noexcept = default;
    template &lt;class _Ty&gt;
    constexpr _Unused_parameter(_Ty&amp;&amp;) noexcept {}
};

template &lt;class _Ty&gt;
using _Algorithm_int_t = conditional_t&lt;is_integral_v&lt;_Ty&gt;, _Ty, ptrdiff_t&gt;;

#ifdef __cpp_lib_concepts
template &lt;class _Ty&gt;
concept _Destructible_object = is_object_v&lt;_Ty&gt; &amp;&amp; destructible&lt;_Ty&gt;;

template &lt;template &lt;class...&gt; class _Template, class... _Args&gt;
void _Derived_from_specialization_impl(const _Template&lt;_Args...&gt;&amp;);

template &lt;class _Ty, template &lt;class...&gt; class _Template&gt;
concept _Derived_from_specialization_of =
    requires(const _Ty&amp; _Obj) {
        _STD _Derived_from_specialization_impl&lt;_Template&gt;(_Obj); // qualified: avoid ADL, handle incomplete types
    };

namespace ranges {
    namespace _Iter_move {
#if defined(__clang__) || defined(__EDG__) // TRANSITION, VSO-1681199
        void iter_move() = delete; // Block unqualified name lookup
#else // ^^^ no workaround / workaround vvv
        void iter_move();
#endif // ^^^ workaround ^^^

        // clang-format off
        template &lt;class _Ty&gt;
        concept _Has_ADL = _Has_class_or_enum_type&lt;_Ty&gt; &amp;&amp; requires(_Ty&amp;&amp; __t) {
            iter_move(static_cast&lt;_Ty&amp;&amp;&gt;(__t)); // intentional ADL
        };

        template &lt;class _Ty&gt;
        concept _Can_deref = requires(_Ty&amp;&amp; __t) {
            *static_cast&lt;_Ty&amp;&amp;&gt;(__t);
        };
        // clang-format on

        class _Cpo {
        private:
            enum class _St { _None, _Custom, _Fallback };

            template &lt;class _Ty&gt;
            _NODISCARD static _CONSTEVAL _Choice_t&lt;_St&gt; _Choose() noexcept {
                if constexpr (_Has_ADL&lt;_Ty&gt;) {
                    return {_St::_Custom, noexcept(iter_move(_STD declval&lt;_Ty&gt;()))}; // intentional ADL
                } else if constexpr (_Can_deref&lt;_Ty&gt;) {
                    return {_St::_Fallback, noexcept(*_STD declval&lt;_Ty&gt;())};
                } else {
                    return {_St::_None};
                }
            }

            template &lt;class _Ty&gt;
            static constexpr _Choice_t&lt;_St&gt; _Choice = _Choose&lt;_Ty&gt;();

        public:
            template &lt;class _Ty&gt;
                requires (_Choice&lt;_Ty&gt;._Strategy != _St::_None)
            _NODISCARD constexpr decltype(auto) operator()(_Ty&amp;&amp; _Val) const noexcept(_Choice&lt;_Ty&gt;._No_throw) {
                constexpr _St _Strat = _Choice&lt;_Ty&gt;._Strategy;

                if constexpr (_Strat == _St::_Custom) {
                    return iter_move(static_cast&lt;_Ty&amp;&amp;&gt;(_Val)); // intentional ADL
                } else if constexpr (_Strat == _St::_Fallback) {
                    using _Ref = decltype(*static_cast&lt;_Ty&amp;&amp;&gt;(_Val));
                    if constexpr (is_lvalue_reference_v&lt;_Ref&gt;) {
                        return _STD move(*static_cast&lt;_Ty&amp;&amp;&gt;(_Val));
                    } else {
                        return *static_cast&lt;_Ty&amp;&amp;&gt;(_Val);
                    }
                } else {
                    static_assert(_Always_false&lt;_Ty&gt;, "should be unreachable");
                }
            }
        };
    } // namespace _Iter_move

    inline namespace _Cpos {
        _EXPORT_STD inline constexpr _Iter_move::_Cpo iter_move;
    }
} // namespace ranges

// iter_swap defined below since it depends on indirectly_movable_storable

// clang-format off
_EXPORT_STD template &lt;class _Ty&gt;
    requires _Dereferenceable&lt;_Ty&gt; &amp;&amp; requires(_Ty&amp; __t) {
        { _RANGES iter_move(__t) } -&gt; _Can_reference;
    }
using iter_rvalue_reference_t = decltype(_RANGES iter_move(_STD declval&lt;_Ty&amp;&gt;()));

template &lt;class _It&gt;
concept _Indirectly_readable_impl = requires(const _It __i) {
    typename iter_value_t&lt;_It&gt;;
    typename iter_reference_t&lt;_It&gt;;
    typename iter_rvalue_reference_t&lt;_It&gt;;
    { *__i } -&gt; same_as&lt;iter_reference_t&lt;_It&gt;&gt;;
    { _RANGES iter_move(__i) } -&gt; same_as&lt;iter_rvalue_reference_t&lt;_It&gt;&gt;;
} &amp;&amp; common_reference_with&lt;iter_reference_t&lt;_It&gt;&amp;&amp;, iter_value_t&lt;_It&gt;&amp;&gt;
  &amp;&amp; common_reference_with&lt;iter_reference_t&lt;_It&gt;&amp;&amp;, iter_rvalue_reference_t&lt;_It&gt;&amp;&amp;&gt;
  &amp;&amp; common_reference_with&lt;iter_rvalue_reference_t&lt;_It&gt;&amp;&amp;, const iter_value_t&lt;_It&gt;&amp;&gt;;

_EXPORT_STD template &lt;class _It&gt;
concept indirectly_readable = _Indirectly_readable_impl&lt;remove_cvref_t&lt;_It&gt;&gt;;
// clang-format on

_EXPORT_STD template &lt;indirectly_readable _Ty&gt;
using iter_common_reference_t = common_reference_t&lt;iter_reference_t&lt;_Ty&gt;, iter_value_t&lt;_Ty&gt;&amp;&gt;;

_EXPORT_STD template &lt;class _It, class _Ty&gt;
concept indirectly_writable =
    requires(_It &amp;&amp; __i, _Ty&amp;&amp; __t) {
        *__i                                                                = static_cast&lt;_Ty&amp;&amp;&gt;(__t);
        *static_cast&lt;_It&amp;&amp;&gt;(__i)                                            = static_cast&lt;_Ty&amp;&amp;&gt;(__t);
        const_cast&lt;const iter_reference_t&lt;_It&gt;&amp;&amp;&gt;(*__i)                     = static_cast&lt;_Ty&amp;&amp;&gt;(__t);
        const_cast&lt;const iter_reference_t&lt;_It&gt;&amp;&amp;&gt;(*static_cast&lt;_It&amp;&amp;&gt;(__i)) = static_cast&lt;_Ty&amp;&amp;&gt;(__t);
    };

template &lt;bool _Is_integer_class&gt;
struct _Make_unsigned_like_impl {
    template &lt;class _Ty&gt;
    using _Apply = typename _Ty::_Unsigned_type;
};
template &lt;&gt;
struct _Make_unsigned_like_impl&lt;false&gt; {
    template &lt;class _Ty&gt;
    using _Apply = make_unsigned_t&lt;_Ty&gt;;
};

template &lt;class _Ty&gt;
using _Make_unsigned_like_t = typename _Make_unsigned_like_impl&lt;_Integer_class&lt;_Ty&gt;&gt;::template _Apply&lt;_Ty&gt;;

template &lt;_Integer_like _Ty&gt;
_NODISCARD constexpr auto _To_unsigned_like(const _Ty _Value) noexcept {
    return static_cast&lt;_Make_unsigned_like_t&lt;_Ty&gt;&gt;(_Value);
}

template &lt;bool _Is_integer_class&gt;
struct _Make_signed_like_impl {
    template &lt;class _Ty&gt;
    using _Apply = typename _Ty::_Signed_type;
};
template &lt;&gt;
struct _Make_signed_like_impl&lt;false&gt; {
    template &lt;class _Ty&gt;
    using _Apply = make_signed_t&lt;_Ty&gt;;
};

template &lt;class _Ty&gt;
using _Make_signed_like_t = typename _Make_signed_like_impl&lt;_Integer_class&lt;_Ty&gt;&gt;::template _Apply&lt;_Ty&gt;;

_EXPORT_STD template &lt;class _Ty&gt;
concept incrementable = regular&lt;_Ty&gt; &amp;&amp; weakly_incrementable&lt;_Ty&gt; &amp;&amp; requires(_Ty __t) {
                                                                         { __t++ } -&gt; same_as&lt;_Ty&gt;;
                                                                     };

template &lt;bool _Iterator_category_present&gt;
struct _Iter_concept_impl2 {
    template &lt;class _It, class _Traits&gt;
    using _Apply = typename _Traits::iterator_category;
};
template &lt;&gt;
struct _Iter_concept_impl2&lt;false&gt; {
    template &lt;class _It, class _Traits&gt;
        requires _Is_from_primary&lt;iterator_traits&lt;_It&gt;&gt;
    using _Apply = random_access_iterator_tag;
};

template &lt;bool _Iterator_concept_present&gt;
struct _Iter_concept_impl1 {
    template &lt;class _It, class _Traits&gt;
    using _Apply = typename _Traits::iterator_concept;
};
template &lt;&gt;
struct _Iter_concept_impl1&lt;false&gt; {
    template &lt;class _It, class _Traits&gt;
    using _Apply = typename _Iter_concept_impl2&lt;_Has_member_iterator_category&lt;_Traits&gt;&gt;::template _Apply&lt;_It, _Traits&gt;;
};

template &lt;class _It, class _Traits = conditional_t&lt;_Is_from_primary&lt;iterator_traits&lt;_It&gt;&gt;, _It, iterator_traits&lt;_It&gt;&gt;&gt;
using _Iter_concept =
    typename _Iter_concept_impl1&lt;_Has_member_iterator_concept&lt;_Traits&gt;&gt;::template _Apply&lt;_It, _Traits&gt;;

// clang-format off
_EXPORT_STD template &lt;class _It&gt;
concept input_iterator = input_or_output_iterator&lt;_It&gt; &amp;&amp; indirectly_readable&lt;_It&gt;
    &amp;&amp; requires { typename _Iter_concept&lt;_It&gt;; }
    &amp;&amp; derived_from&lt;_Iter_concept&lt;_It&gt;, input_iterator_tag&gt;;

_EXPORT_STD template &lt;class _It, class _Ty&gt;
concept output_iterator = input_or_output_iterator&lt;_It&gt; &amp;&amp; indirectly_writable&lt;_It, _Ty&gt;
    &amp;&amp; requires(_It __i, _Ty&amp;&amp; __t) {
        *__i++ = static_cast&lt;_Ty&amp;&amp;&gt;(__t);
    };

_EXPORT_STD template &lt;class _It&gt;
concept forward_iterator = input_iterator&lt;_It&gt; &amp;&amp; derived_from&lt;_Iter_concept&lt;_It&gt;, forward_iterator_tag&gt;
    &amp;&amp; incrementable&lt;_It&gt; &amp;&amp; sentinel_for&lt;_It, _It&gt;;

_EXPORT_STD template &lt;class _It&gt;
concept bidirectional_iterator = forward_iterator&lt;_It&gt; &amp;&amp; derived_from&lt;_Iter_concept&lt;_It&gt;, bidirectional_iterator_tag&gt;
    &amp;&amp; requires(_It __i) {
        { --__i } -&gt; same_as&lt;_It&amp;&gt;;
        { __i-- } -&gt; same_as&lt;_It&gt;;
    };

_EXPORT_STD template &lt;class _It&gt;
concept random_access_iterator = bidirectional_iterator&lt;_It&gt;
    &amp;&amp; derived_from&lt;_Iter_concept&lt;_It&gt;, random_access_iterator_tag&gt; &amp;&amp; totally_ordered&lt;_It&gt;
    &amp;&amp; sized_sentinel_for&lt;_It, _It&gt; &amp;&amp; requires(_It __i, const _It __j, const iter_difference_t&lt;_It&gt; __n) {
        { __i += __n } -&gt; same_as&lt;_It&amp;&gt;;
        { __j + __n } -&gt; same_as&lt;_It&gt;;
        { __n + __j } -&gt; same_as&lt;_It&gt;;
        { __i -= __n } -&gt; same_as&lt;_It&amp;&gt;;
        { __j - __n } -&gt; same_as&lt;_It&gt;;
        { __j[__n] } -&gt; same_as&lt;iter_reference_t&lt;_It&gt;&gt;;
    };

_EXPORT_STD template &lt;class _It&gt;
concept contiguous_iterator = random_access_iterator&lt;_It&gt;
    &amp;&amp; derived_from&lt;_Iter_concept&lt;_It&gt;, contiguous_iterator_tag&gt;
    &amp;&amp; is_lvalue_reference_v&lt;iter_reference_t&lt;_It&gt;&gt;
    &amp;&amp; same_as&lt;iter_value_t&lt;_It&gt;, remove_cvref_t&lt;iter_reference_t&lt;_It&gt;&gt;&gt;
    &amp;&amp; requires(const _It&amp; __i) {
        { _STD to_address(__i) } -&gt; same_as&lt;add_pointer_t&lt;iter_reference_t&lt;_It&gt;&gt;&gt;;
    };

_EXPORT_STD template &lt;class _Fn, class _It&gt;
concept indirectly_unary_invocable = indirectly_readable&lt;_It&gt;
    &amp;&amp; copy_constructible&lt;_Fn&gt;
    &amp;&amp; invocable&lt;_Fn&amp;, iter_value_t&lt;_It&gt;&amp;&gt;
    &amp;&amp; invocable&lt;_Fn&amp;, iter_reference_t&lt;_It&gt;&gt;
    &amp;&amp; invocable&lt;_Fn&amp;, iter_common_reference_t&lt;_It&gt;&gt;
    &amp;&amp; common_reference_with&lt;
        invoke_result_t&lt;_Fn&amp;, iter_value_t&lt;_It&gt;&amp;&gt;,
        invoke_result_t&lt;_Fn&amp;, iter_reference_t&lt;_It&gt;&gt;&gt;;

_EXPORT_STD template &lt;class _Fn, class _It&gt;
concept indirectly_regular_unary_invocable = indirectly_readable&lt;_It&gt;
    &amp;&amp; copy_constructible&lt;_Fn&gt;
    &amp;&amp; regular_invocable&lt;_Fn&amp;, iter_value_t&lt;_It&gt;&amp;&gt;
    &amp;&amp; regular_invocable&lt;_Fn&amp;, iter_reference_t&lt;_It&gt;&gt;
    &amp;&amp; regular_invocable&lt;_Fn&amp;, iter_common_reference_t&lt;_It&gt;&gt;
    &amp;&amp; common_reference_with&lt;
        invoke_result_t&lt;_Fn&amp;, iter_value_t&lt;_It&gt;&amp;&gt;,
        invoke_result_t&lt;_Fn&amp;, iter_reference_t&lt;_It&gt;&gt;&gt;;

_EXPORT_STD template &lt;class _Fn, class _It&gt;
concept indirect_unary_predicate = indirectly_readable&lt;_It&gt;
    &amp;&amp; copy_constructible&lt;_Fn&gt;
    &amp;&amp; predicate&lt;_Fn&amp;, iter_value_t&lt;_It&gt;&amp;&gt;
    &amp;&amp; predicate&lt;_Fn&amp;, iter_reference_t&lt;_It&gt;&gt;
    &amp;&amp; predicate&lt;_Fn&amp;, iter_common_reference_t&lt;_It&gt;&gt;;

_EXPORT_STD template &lt;class _Fn, class _It1, class _It2&gt;
concept indirect_binary_predicate = indirectly_readable&lt;_It1&gt;
    &amp;&amp; indirectly_readable&lt;_It2&gt;
    &amp;&amp; copy_constructible&lt;_Fn&gt;
    &amp;&amp; predicate&lt;_Fn&amp;, iter_value_t&lt;_It1&gt;&amp;, iter_value_t&lt;_It2&gt;&amp;&gt;
    &amp;&amp; predicate&lt;_Fn&amp;, iter_value_t&lt;_It1&gt;&amp;, iter_reference_t&lt;_It2&gt;&gt;
    &amp;&amp; predicate&lt;_Fn&amp;, iter_reference_t&lt;_It1&gt;, iter_value_t&lt;_It2&gt;&amp;&gt;
    &amp;&amp; predicate&lt;_Fn&amp;, iter_reference_t&lt;_It1&gt;, iter_reference_t&lt;_It2&gt;&gt;
    &amp;&amp; predicate&lt;_Fn&amp;, iter_common_reference_t&lt;_It1&gt;, iter_common_reference_t&lt;_It2&gt;&gt;;

_EXPORT_STD template &lt;class _Fn, class _It1, class _It2 = _It1&gt;
concept indirect_equivalence_relation = indirectly_readable&lt;_It1&gt;
    &amp;&amp; indirectly_readable&lt;_It2&gt;
    &amp;&amp; copy_constructible&lt;_Fn&gt;
    &amp;&amp; equivalence_relation&lt;_Fn&amp;, iter_value_t&lt;_It1&gt;&amp;, iter_value_t&lt;_It2&gt;&amp;&gt;
    &amp;&amp; equivalence_relation&lt;_Fn&amp;, iter_value_t&lt;_It1&gt;&amp;, iter_reference_t&lt;_It2&gt;&gt;
    &amp;&amp; equivalence_relation&lt;_Fn&amp;, iter_reference_t&lt;_It1&gt;, iter_value_t&lt;_It2&gt;&amp;&gt;
    &amp;&amp; equivalence_relation&lt;_Fn&amp;, iter_reference_t&lt;_It1&gt;, iter_reference_t&lt;_It2&gt;&gt;
    &amp;&amp; equivalence_relation&lt;_Fn&amp;, iter_common_reference_t&lt;_It1&gt;, iter_common_reference_t&lt;_It2&gt;&gt;;

_EXPORT_STD template &lt;class _Fn, class _It1, class _It2 = _It1&gt;
concept indirect_strict_weak_order = indirectly_readable&lt;_It1&gt;
    &amp;&amp; indirectly_readable&lt;_It2&gt;
    &amp;&amp; copy_constructible&lt;_Fn&gt;
    &amp;&amp; strict_weak_order&lt;_Fn&amp;, iter_value_t&lt;_It1&gt;&amp;, iter_value_t&lt;_It2&gt;&amp;&gt;
    &amp;&amp; strict_weak_order&lt;_Fn&amp;, iter_value_t&lt;_It1&gt;&amp;, iter_reference_t&lt;_It2&gt;&gt;
    &amp;&amp; strict_weak_order&lt;_Fn&amp;, iter_reference_t&lt;_It1&gt;, iter_value_t&lt;_It2&gt;&amp;&gt;
    &amp;&amp; strict_weak_order&lt;_Fn&amp;, iter_reference_t&lt;_It1&gt;, iter_reference_t&lt;_It2&gt;&gt;
    &amp;&amp; strict_weak_order&lt;_Fn&amp;, iter_common_reference_t&lt;_It1&gt;, iter_common_reference_t&lt;_It2&gt;&gt;;

_EXPORT_STD template &lt;class _Fn, class... _Its&gt;
    requires (indirectly_readable&lt;_Its&gt; &amp;&amp; ...)
        &amp;&amp; invocable&lt;_Fn, iter_reference_t&lt;_Its&gt;...&gt;
using indirect_result_t = invoke_result_t&lt;_Fn, iter_reference_t&lt;_Its&gt;...&gt;;
// clang-format on

_EXPORT_STD template &lt;indirectly_readable _It, indirectly_regular_unary_invocable&lt;_It&gt; _Proj&gt;
struct projected {
    using value_type = remove_cvref_t&lt;indirect_result_t&lt;_Proj&amp;, _It&gt;&gt;;
    indirect_result_t&lt;_Proj&amp;, _It&gt; operator*() const {
        _CSTD abort();
    }
};

template &lt;weakly_incrementable _It, class _Proj&gt;
struct incrementable_traits&lt;projected&lt;_It, _Proj&gt;&gt; {
    using difference_type = iter_difference_t&lt;_It&gt;;
};

_EXPORT_STD template &lt;class _In, class _Out&gt;
concept indirectly_movable = indirectly_readable&lt;_In&gt; &amp;&amp; indirectly_writable&lt;_Out, iter_rvalue_reference_t&lt;_In&gt;&gt;;

// clang-format off
_EXPORT_STD template &lt;class _In, class _Out&gt;
concept indirectly_movable_storable = indirectly_movable&lt;_In, _Out&gt;
    &amp;&amp; indirectly_writable&lt;_Out, iter_value_t&lt;_In&gt;&gt;
    &amp;&amp; movable&lt;iter_value_t&lt;_In&gt;&gt;
    &amp;&amp; constructible_from&lt;iter_value_t&lt;_In&gt;, iter_rvalue_reference_t&lt;_In&gt;&gt;
    &amp;&amp; assignable_from&lt;iter_value_t&lt;_In&gt;&amp;, iter_rvalue_reference_t&lt;_In&gt; &gt;;
// clang-format on

_EXPORT_STD template &lt;class _In, class _Out&gt;
concept indirectly_copyable = indirectly_readable&lt;_In&gt; &amp;&amp; indirectly_writable&lt;_Out, iter_reference_t&lt;_In&gt;&gt;;

// clang-format off
_EXPORT_STD template &lt;class _In, class _Out&gt;
concept indirectly_copyable_storable = indirectly_copyable&lt;_In, _Out&gt;
    &amp;&amp; indirectly_writable&lt;_Out, iter_value_t&lt;_In&gt;&amp;&gt;
    &amp;&amp; indirectly_writable&lt;_Out, const iter_value_t&lt;_In&gt;&amp;&gt;
    &amp;&amp; indirectly_writable&lt;_Out, iter_value_t&lt;_In&gt;&amp;&amp;&gt;
    &amp;&amp; indirectly_writable&lt;_Out, const iter_value_t&lt;_In&gt;&amp;&amp;&gt;
    &amp;&amp; copyable&lt;iter_value_t&lt;_In&gt;&gt;
    &amp;&amp; constructible_from&lt;iter_value_t&lt;_In&gt;, iter_reference_t&lt;_In&gt;&gt;
    &amp;&amp; assignable_from&lt;iter_value_t&lt;_In&gt;&amp;, iter_reference_t&lt;_In&gt;&gt;;
// clang-format on

namespace ranges {
    namespace _Iter_swap {
        template &lt;class _Ty1, class _Ty2&gt;
        void iter_swap(_Ty1, _Ty2) = delete;

        // clang-format off
        template &lt;class _Ty1, class _Ty2&gt;
        concept _Has_ADL = (_Has_class_or_enum_type&lt;_Ty1&gt; || _Has_class_or_enum_type&lt;_Ty2&gt;)
            &amp;&amp; requires(_Ty1&amp;&amp; __t1, _Ty2&amp;&amp; __t2) {
                iter_swap(static_cast&lt;_Ty1&amp;&amp;&gt;(__t1), static_cast&lt;_Ty2&amp;&amp;&gt;(__t2)); // intentional ADL
            };

        template &lt;class _Ty1, class _Ty2&gt;
        concept _Can_swap_references = indirectly_readable&lt;remove_reference_t&lt;_Ty1&gt;&gt;
            &amp;&amp; indirectly_readable&lt;remove_reference_t&lt;_Ty2&gt;&gt;
            &amp;&amp; swappable_with&lt;iter_reference_t&lt;_Ty1&gt;, iter_reference_t&lt;_Ty2&gt;&gt;;

        template &lt;class _Ty1, class _Ty2&gt;
        concept _Symmetric_indirectly_movable_storable =
               indirectly_movable_storable&lt;remove_reference_t&lt;_Ty1&gt;, remove_reference_t&lt;_Ty2&gt;&gt;
            &amp;&amp; indirectly_movable_storable&lt;remove_reference_t&lt;_Ty2&gt;, remove_reference_t&lt;_Ty1&gt;&gt;;
        // clang-format on

        template &lt;class _Xty, class _Yty&gt;
        _NODISCARD constexpr iter_value_t&lt;remove_reference_t&lt;_Xty&gt;&gt; _Iter_exchange_move(_Xty&amp;&amp; _XVal,
            _Yty&amp;&amp; _YVal) noexcept(noexcept(iter_value_t&lt;remove_reference_t&lt;_Xty&gt;&gt;(_RANGES iter_move(_XVal)))) {
            iter_value_t&lt;remove_reference_t&lt;_Xty&gt;&gt; _Tmp(_RANGES iter_move(_XVal));
            *_XVal = _RANGES iter_move(_YVal);
            return _Tmp;
        }

        class _Cpo {
        private:
            enum class _St { _None, _Custom, _Swap, _Exchange };

            template &lt;class _Ty1, class _Ty2&gt;
            _NODISCARD static _CONSTEVAL _Choice_t&lt;_St&gt; _Choose() noexcept {
                if constexpr (_Has_ADL&lt;_Ty1, _Ty2&gt;) {
                    return {_St::_Custom,
                        noexcept(iter_swap(_STD declval&lt;_Ty1&gt;(), _STD declval&lt;_Ty2&gt;()))}; // intentional ADL
                } else if constexpr (_Can_swap_references&lt;_Ty1, _Ty2&gt;) {
                    return {_St::_Swap, noexcept(_RANGES swap(*_STD declval&lt;_Ty1&gt;(), *_STD declval&lt;_Ty2&gt;()))};
                } else if constexpr (_Symmetric_indirectly_movable_storable&lt;_Ty1, _Ty2&gt;) {
                    constexpr auto _Nothrow = noexcept(*_STD declval&lt;_Ty1&gt;() = _Iter_swap::_Iter_exchange_move(
                                                           _STD declval&lt;_Ty2&gt;(), _STD declval&lt;_Ty1&gt;()));
                    return {_St::_Exchange, _Nothrow};
                } else {
                    return {_St::_None};
                }
            }

            template &lt;class _Ty1, class _Ty2&gt;
            static constexpr _Choice_t&lt;_St&gt; _Choice = _Choose&lt;_Ty1, _Ty2&gt;();

        public:
            template &lt;class _Ty1, class _Ty2&gt;
                requires (_Choice&lt;_Ty1, _Ty2&gt;._Strategy != _St::_None)
            constexpr void operator()(_Ty1&amp;&amp; _Val1, _Ty2&amp;&amp; _Val2) const noexcept(_Choice&lt;_Ty1, _Ty2&gt;._No_throw) {
                constexpr _St _Strat = _Choice&lt;_Ty1, _Ty2&gt;._Strategy;

                if constexpr (_Strat == _St::_Custom) {
                    (void) iter_swap(static_cast&lt;_Ty1&amp;&amp;&gt;(_Val1), static_cast&lt;_Ty2&amp;&amp;&gt;(_Val2)); // intentional ADL
                } else if constexpr (_Strat == _St::_Swap) {
                    _RANGES swap(*static_cast&lt;_Ty1&amp;&amp;&gt;(_Val1), *static_cast&lt;_Ty2&amp;&amp;&gt;(_Val2));
                } else if constexpr (_Strat == _St::_Exchange) {
                    *static_cast&lt;_Ty1&amp;&amp;&gt;(_Val1) =
                        _Iter_swap::_Iter_exchange_move(static_cast&lt;_Ty2&amp;&amp;&gt;(_Val2), static_cast&lt;_Ty1&amp;&amp;&gt;(_Val1));
                } else {
                    static_assert(_Always_false&lt;_Ty1&gt;, "should be unreachable");
                }
            }
        };
    } // namespace _Iter_swap

    inline namespace _Cpos {
        _EXPORT_STD inline constexpr _Iter_swap::_Cpo iter_swap;
    }
} // namespace ranges

// clang-format off
_EXPORT_STD template &lt;class _It1, class _It2 = _It1&gt;
concept indirectly_swappable = indirectly_readable&lt;_It1&gt; &amp;&amp; indirectly_readable&lt;_It2&gt;
    &amp;&amp; requires(const _It1 __i1, const _It2 __i2) {
        _RANGES iter_swap(__i1, __i1);
        _RANGES iter_swap(__i2, __i2);
        _RANGES iter_swap(__i1, __i2);
        _RANGES iter_swap(__i2, __i1);
    };
// clang-format on

_EXPORT_STD template &lt;class _It1, class _It2, class _Rel, class _Proj1 = identity, class _Proj2 = identity&gt;
concept indirectly_comparable = indirect_binary_predicate&lt;_Rel, projected&lt;_It1, _Proj1&gt;, projected&lt;_It2, _Proj2&gt;&gt;;

_EXPORT_STD template &lt;class _It&gt;
concept permutable = forward_iterator&lt;_It&gt; &amp;&amp; indirectly_movable_storable&lt;_It, _It&gt; &amp;&amp; indirectly_swappable&lt;_It, _It&gt;;

namespace ranges {
    _EXPORT_STD struct less;
} // namespace ranges

_EXPORT_STD template &lt;class _It1, class _It2, class _Out, class _Pr = ranges::less, class _Pj1 = identity,
    class _Pj2 = identity&gt;
concept mergeable = input_iterator&lt;_It1&gt; &amp;&amp; input_iterator&lt;_It2&gt; //
                 &amp;&amp; weakly_incrementable&lt;_Out&gt; //
                 &amp;&amp; indirectly_copyable&lt;_It1, _Out&gt; //
                 &amp;&amp; indirectly_copyable&lt;_It2, _Out&gt; //
                 &amp;&amp; indirect_strict_weak_order&lt;_Pr, projected&lt;_It1, _Pj1&gt;, projected&lt;_It2, _Pj2&gt;&gt;;

_EXPORT_STD template &lt;class _It, class _Pr = ranges::less, class _Proj = identity&gt;
concept sortable = permutable&lt;_It&gt; &amp;&amp; indirect_strict_weak_order&lt;_Pr, projected&lt;_It, _Proj&gt;&gt;;

template &lt;class _Iter&gt;
using _Iter_ref_t = iter_reference_t&lt;_Iter&gt;;

template &lt;class _Iter&gt;
using _Iter_value_t = iter_value_t&lt;_Iter&gt;;

template &lt;class _Iter&gt;
using _Iter_diff_t = iter_difference_t&lt;_Iter&gt;;

#else // ^^^ __cpp_lib_concepts / !__cpp_lib_concepts vvv
template &lt;class _Iter&gt;
using _Iter_ref_t = typename iterator_traits&lt;_Iter&gt;::reference;

template &lt;class _Iter&gt;
using _Iter_value_t = typename iterator_traits&lt;_Iter&gt;::value_type;

template &lt;class _Iter&gt;
using _Iter_diff_t = typename iterator_traits&lt;_Iter&gt;::difference_type;

template &lt;class _Ty&gt;
using _Make_unsigned_like_t = make_unsigned_t&lt;_Ty&gt;;
#endif // __cpp_lib_concepts

template &lt;class... _Iters&gt;
using _Common_diff_t = common_type_t&lt;_Iter_diff_t&lt;_Iters&gt;...&gt;;

template &lt;class _Iter&gt;
using _Iter_cat_t = typename iterator_traits&lt;_Iter&gt;::iterator_category;

template &lt;class _Ty, class = void&gt;
_INLINE_VAR constexpr bool _Is_iterator_v = false;

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool _Is_iterator_v&lt;_Ty, void_t&lt;_Iter_cat_t&lt;_Ty&gt;&gt;&gt; = true;

template &lt;class _Ty&gt;
struct _Is_iterator : bool_constant&lt;_Is_iterator_v&lt;_Ty&gt;&gt; {};

template &lt;class _Iter&gt;
_INLINE_VAR constexpr bool _Is_cpp17_input_iter_v = is_convertible_v&lt;_Iter_cat_t&lt;_Iter&gt;, input_iterator_tag&gt;;

template &lt;class _Iter&gt;
_INLINE_VAR constexpr bool _Is_ranges_input_iter_v =
#ifdef __cpp_lib_concepts
    (input_iterator&lt;_Iter&gt; &amp;&amp; sentinel_for&lt;_Iter, _Iter&gt;) ||
#endif
    _Is_cpp17_input_iter_v&lt;_Iter&gt;;

template &lt;class _Iter&gt;
_INLINE_VAR constexpr bool _Is_cpp17_fwd_iter_v = is_convertible_v&lt;_Iter_cat_t&lt;_Iter&gt;, forward_iterator_tag&gt;;

template &lt;class _Iter&gt;
_INLINE_VAR constexpr bool _Is_ranges_fwd_iter_v =
#ifdef __cpp_lib_concepts
    forward_iterator&lt;_Iter&gt; ||
#endif
    _Is_cpp17_fwd_iter_v&lt;_Iter&gt;;

template &lt;class _Iter&gt;
_INLINE_VAR constexpr bool _Is_cpp17_bidi_iter_v = is_convertible_v&lt;_Iter_cat_t&lt;_Iter&gt;, bidirectional_iterator_tag&gt;;

template &lt;class _Iter&gt;
_INLINE_VAR constexpr bool _Is_ranges_bidi_iter_v =
#ifdef __cpp_lib_concepts
    bidirectional_iterator&lt;_Iter&gt; ||
#endif
    _Is_cpp17_bidi_iter_v&lt;_Iter&gt;;

template &lt;class _Iter&gt;
_INLINE_VAR constexpr bool _Is_cpp17_random_iter_v = is_convertible_v&lt;_Iter_cat_t&lt;_Iter&gt;, random_access_iterator_tag&gt;;

template &lt;class _Iter&gt;
_INLINE_VAR constexpr bool _Is_ranges_random_iter_v =
#ifdef __cpp_lib_concepts
    random_access_iterator&lt;_Iter&gt; ||
#endif
    _Is_cpp17_random_iter_v&lt;_Iter&gt;;

#define _REQUIRE_CPP17_MUTABLE_ITERATOR(_Iter) \
    static_assert(_Is_cpp17_fwd_iter_v&lt;_Iter&gt;, \
        "Non-ranges algorithms require that mutable iterators be Cpp17ForwardIterators or stronger.")

template &lt;class, class = void&gt;
struct _Is_checked_helper {}; // default definition, no longer used, retained due to pseudo-documentation

#if _ITERATOR_DEBUG_LEVEL != 0
template &lt;class _Ty&gt;
constexpr void _Verify_range(const _Ty* const _First, const _Ty* const _Last) noexcept {
    // special case range verification for pointers
    _STL_VERIFY(_First &lt;= _Last, "transposed pointer range");
}
#endif // _ITERATOR_DEBUG_LEVEL != 0

template &lt;class _Iter, class = void&gt;
_INLINE_VAR constexpr bool _Allow_inheriting_unwrap_v = true;

template &lt;class _Iter&gt;
_INLINE_VAR constexpr bool _Allow_inheriting_unwrap_v&lt;_Iter, void_t&lt;typename _Iter::_Prevent_inheriting_unwrap&gt;&gt; =
    is_same_v&lt;_Iter, typename _Iter::_Prevent_inheriting_unwrap&gt;;

template &lt;class _Iter, class _Sentinel = _Iter, class = void&gt;
_INLINE_VAR constexpr bool _Range_verifiable_v = false;

template &lt;class _Iter, class _Sentinel&gt;
_INLINE_VAR constexpr bool _Range_verifiable_v&lt;_Iter, _Sentinel,
    void_t&lt;decltype(_Verify_range(_STD declval&lt;const _Iter&amp;&gt;(), _STD declval&lt;const _Sentinel&amp;&gt;()))&gt;&gt; =
    _Allow_inheriting_unwrap_v&lt;_Iter&gt;;

template &lt;class _Iter, class _Sentinel&gt;
constexpr void _Adl_verify_range(const _Iter&amp; _First, const _Sentinel&amp; _Last) {
    // check that [_First, _Last) forms an iterator range
    if constexpr (_Range_verifiable_v&lt;_Iter, _Sentinel&gt;) {
        _Verify_range(_First, _Last);
    }
}

template &lt;class _Iter, class = void&gt;
_INLINE_VAR constexpr bool _Unwrappable_v = false;

template &lt;class _Iter&gt;
_INLINE_VAR constexpr bool _Unwrappable_v&lt;_Iter,
    void_t&lt;decltype(_STD declval&lt;_Remove_cvref_t&lt;_Iter&gt;&amp;&gt;()._Seek_to(_STD declval&lt;_Iter&gt;()._Unwrapped()))&gt;&gt; =
    _Allow_inheriting_unwrap_v&lt;_Remove_cvref_t&lt;_Iter&gt;&gt;;

template &lt;class _Iter, class = void&gt;
_INLINE_VAR constexpr bool _Has_nothrow_unwrapped = false;
template &lt;class _Iter&gt;
_INLINE_VAR constexpr bool _Has_nothrow_unwrapped&lt;_Iter, void_t&lt;decltype(_STD declval&lt;_Iter&gt;()._Unwrapped())&gt;&gt; =
    noexcept(_STD declval&lt;_Iter&gt;()._Unwrapped());

template &lt;class _Iter&gt;
_NODISCARD constexpr decltype(auto) _Get_unwrapped(_Iter&amp;&amp; _It) noexcept(
    !_Unwrappable_v&lt;_Iter&gt; || _Has_nothrow_unwrapped&lt;_Iter&gt;) {
    // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
    if constexpr (is_pointer_v&lt;decay_t&lt;_Iter&gt;&gt;) { // special-case pointers and arrays
        return _It + 0;
    } else if constexpr (_Unwrappable_v&lt;_Iter&gt;) {
        return static_cast&lt;_Iter&amp;&amp;&gt;(_It)._Unwrapped();
    } else {
        return static_cast&lt;_Iter&amp;&amp;&gt;(_It);
    }
}

template &lt;class _Iter&gt;
using _Unwrapped_t = _Remove_cvref_t&lt;decltype(_Get_unwrapped(_STD declval&lt;_Iter&gt;()))&gt;;

template &lt;class _Iter, class = bool&gt;
_INLINE_VAR constexpr bool _Do_unwrap_when_unverified_v = false;

template &lt;class _Iter&gt;
_INLINE_VAR constexpr bool
    _Do_unwrap_when_unverified_v&lt;_Iter, decltype(static_cast&lt;bool&gt;(_Iter::_Unwrap_when_unverified))&gt; =
        static_cast&lt;bool&gt;(_Iter::_Unwrap_when_unverified);

template &lt;class _Iter&gt;
_INLINE_VAR constexpr bool _Unwrappable_for_unverified_v =
    _Unwrappable_v&lt;_Iter&gt; &amp;&amp; _Do_unwrap_when_unverified_v&lt;_Remove_cvref_t&lt;_Iter&gt;&gt;;

template &lt;class _Iter&gt;
_NODISCARD constexpr decltype(auto) _Get_unwrapped_unverified(_Iter&amp;&amp; _It) {
    // unwrap an iterator not previously subjected to _Adl_verify_range
    if constexpr (is_pointer_v&lt;decay_t&lt;_Iter&gt;&gt;) { // special-case pointers and arrays
        return _It + 0;
    } else if constexpr (_Unwrappable_for_unverified_v&lt;_Iter&gt;) {
        return static_cast&lt;_Iter&amp;&amp;&gt;(_It)._Unwrapped();
    } else {
        return static_cast&lt;_Iter&amp;&amp;&gt;(_It);
    }
}

template &lt;class _Iter&gt;
using _Unwrapped_unverified_t = _Remove_cvref_t&lt;decltype(_Get_unwrapped_unverified(_STD declval&lt;_Iter&gt;()))&gt;;

struct _Distance_unknown {
    constexpr _Distance_unknown operator-() const noexcept {
        return {};
    }
};

template &lt;class _Diff&gt;
_INLINE_VAR constexpr _Diff _Max_possible_v{static_cast&lt;_Make_unsigned_like_t&lt;_Diff&gt;&gt;(-1) &gt;&gt; 1};

template &lt;class _Diff&gt;
_INLINE_VAR constexpr _Diff _Min_possible_v{-_Max_possible_v&lt;_Diff&gt; - 1};

template &lt;class _Iter, class = void&gt;
_INLINE_VAR constexpr bool _Offset_verifiable_v = false;

template &lt;class _Iter&gt;
_INLINE_VAR constexpr bool
    _Offset_verifiable_v&lt;_Iter, void_t&lt;decltype(_STD declval&lt;const _Iter&amp;&gt;()._Verify_offset(_Iter_diff_t&lt;_Iter&gt;{}))&gt;&gt; =
        true;

template &lt;class _Iter&gt;
_INLINE_VAR constexpr bool _Unwrappable_for_offset_v =
    _Unwrappable_v&lt;_Iter&gt; &amp;&amp; _Offset_verifiable_v&lt;_Remove_cvref_t&lt;_Iter&gt;&gt;;

template &lt;class _Iter, class _Diff&gt;
_NODISCARD constexpr decltype(auto) _Get_unwrapped_n(_Iter&amp;&amp; _It, const _Diff _Off) {
    if constexpr (is_pointer_v&lt;decay_t&lt;_Iter&gt;&gt;) {
        return _It + 0;
    } else if constexpr (_Unwrappable_for_offset_v&lt;_Iter&gt; &amp;&amp; is_integral_v&lt;_Diff&gt;) {
        // ask an iterator to assert that the iterator moved _Off positions is valid, and unwrap
        using _IDiff     = _Iter_diff_t&lt;_Remove_cvref_t&lt;_Iter&gt;&gt;;
        using _CDiff     = common_type_t&lt;_Diff, _IDiff&gt;;
        const auto _COff = static_cast&lt;_CDiff&gt;(_Off);

        _STL_ASSERT(_COff &lt;= static_cast&lt;_CDiff&gt;(_Max_possible_v&lt;_IDiff&gt;)
                        &amp;&amp; (is_unsigned_v&lt;_Diff&gt; || static_cast&lt;_CDiff&gt;(_Min_possible_v&lt;_IDiff&gt;) &lt;= _COff),
            "integer overflow");
        (void) _COff;

        _It._Verify_offset(static_cast&lt;_IDiff&gt;(_Off));
        return static_cast&lt;_Iter&amp;&amp;&gt;(_It)._Unwrapped();
    } else if constexpr (_Unwrappable_for_unverified_v&lt;_Iter&gt;) {
        // iterator doesn't support offset-based asserts, or offset unknown; defer to unverified unwrap
        return static_cast&lt;_Iter&amp;&amp;&gt;(_It)._Unwrapped();
    } else {
        // pass through iterator that doesn't participate in checking
        return static_cast&lt;_Iter&amp;&amp;&gt;(_It);
    }
}

template &lt;class _Iter, class _UIter, class = void&gt;
_INLINE_VAR constexpr bool _Wrapped_seekable_v = false;

template &lt;class _Iter, class _UIter&gt;
_INLINE_VAR constexpr bool
    _Wrapped_seekable_v&lt;_Iter, _UIter, void_t&lt;decltype(_STD declval&lt;_Iter&amp;&gt;()._Seek_to(_STD declval&lt;_UIter&gt;()))&gt;&gt; =
        true;

template &lt;class _Iter, class _UIter&gt;
constexpr void _Seek_wrapped(_Iter&amp; _It, _UIter&amp;&amp; _UIt) {
    if constexpr (_Wrapped_seekable_v&lt;_Iter, _UIter&gt;) {
        _It._Seek_to(_STD forward&lt;_UIter&gt;(_UIt));
    } else {
        _It = _STD forward&lt;_UIter&gt;(_UIt);
    }
}

#if _HAS_CXX17
template &lt;class _Ty, class = void&gt;
struct _Is_allocator : false_type {}; // selected when _Ty can't possibly be an allocator

template &lt;class _Ty&gt;
struct _Is_allocator&lt;_Ty, void_t&lt;typename _Ty::value_type, decltype(_STD declval&lt;_Ty&amp;&gt;().deallocate(
                                                               _STD declval&lt;_Ty&amp;&gt;().allocate(size_t{1}), size_t{1}))&gt;&gt;
    : true_type {}; // selected when _Ty resembles an allocator, N4687 26.2.1 [container.requirements.general]/17

// deduction guide utilities (N4892 [associative.general]/2)
template &lt;class _Iter&gt;
using _Guide_key_t = remove_const_t&lt;typename iterator_traits&lt;_Iter&gt;::value_type::first_type&gt;;

template &lt;class _Iter&gt;
using _Guide_val_t = typename iterator_traits&lt;_Iter&gt;::value_type::second_type;

template &lt;class _Iter&gt;
using _Guide_pair_t = pair&lt;add_const_t&lt;typename iterator_traits&lt;_Iter&gt;::value_type::first_type&gt;,
    typename iterator_traits&lt;_Iter&gt;::value_type::second_type&gt;;

_EXPORT_STD template &lt;class _Ty&gt;
struct is_execution_policy : false_type {};

_EXPORT_STD template &lt;class _Ty&gt;
inline constexpr bool is_execution_policy_v = is_execution_policy&lt;_Ty&gt;::value;

// Note: The noexcept specifiers on all parallel algorithm overloads enforce termination as per
// N4713 23.19.4 [execpol.seq]/2, 23.19.5 [execpol.par]/2, and 23.19.6 [execpol.parunseq]/2
template &lt;class _ExPo&gt;
using _Enable_if_execution_policy_t = typename remove_reference_t&lt;_ExPo&gt;::_Standard_execution_policy;

#define _REQUIRE_PARALLEL_ITERATOR(_Iter) \
    static_assert(_Is_ranges_fwd_iter_v&lt;_Iter&gt;, "Parallel algorithms require forward iterators or stronger.")

#endif // _HAS_CXX17

template &lt;class _Checked, class _Iter&gt;
_NODISCARD constexpr auto _Idl_distance(const _Iter&amp; _First, const _Iter&amp; _Last) {
    // tries to get the distance between _First and _Last if they are random-access iterators
    if constexpr (_Is_ranges_random_iter_v&lt;_Iter&gt;) {
        return static_cast&lt;_Iter_diff_t&lt;_Checked&gt;&gt;(_Last - _First);
    } else {
        return _Distance_unknown{};
    }
}

template &lt;class _Elem, bool _Is_enum = is_enum_v&lt;_Elem&gt;&gt;
struct _Unwrap_enum { // if _Elem is an enum, gets its underlying type; otherwise leaves _Elem unchanged
    using type = underlying_type_t&lt;_Elem&gt;;
};

template &lt;class _Elem&gt;
struct _Unwrap_enum&lt;_Elem, false&gt; { // passthrough non-enum type
    using type = _Elem;
};

template &lt;class _Elem&gt;
using _Unwrap_enum_t = typename _Unwrap_enum&lt;_Elem&gt;::type;

#if _ITERATOR_DEBUG_LEVEL &lt; 2
#define _DEBUG_LT_PRED(pred, x, y) static_cast&lt;bool&gt;(pred(x, y))
#define _DEBUG_ORDER_UNWRAPPED(first, last, pred)
#define _DEBUG_ORDER_SET_UNWRAPPED(otherIter, first, last, pred)

#else // _ITERATOR_DEBUG_LEVEL &lt; 2
#define _DEBUG_LT_PRED(pred, x, y)                _Debug_lt_pred(pred, x, y)
#define _DEBUG_ORDER_UNWRAPPED(first, last, pred) _Debug_order_unchecked(first, last, pred)
#define _DEBUG_ORDER_SET_UNWRAPPED(otherIter, first, last, pred) \
    _Debug_order_set_unchecked&lt;otherIter&gt;(first, last, pred)

template &lt;class _Pr, class _Ty1, class _Ty2,
    enable_if_t&lt;is_same_v&lt;_Remove_cvref_t&lt;_Ty1&gt;, _Remove_cvref_t&lt;_Ty2&gt;&gt;, int&gt; = 0&gt;
constexpr bool _Debug_lt_pred(_Pr&amp;&amp; _Pred, _Ty1&amp;&amp; _Left, _Ty2&amp;&amp; _Right) noexcept(
    noexcept(_Pred(_Left, _Right)) &amp;&amp; noexcept(_Pred(_Right, _Left))) {
    // test if _Pred(_Left, _Right) and _Pred is strict weak ordering, when the arguments are the cv-same-type
    const auto _Result = static_cast&lt;bool&gt;(_Pred(_Left, _Right));
    if (_Result) {
        _STL_VERIFY(!_Pred(_Right, _Left), "invalid comparator");
    }

    return _Result;
}

template &lt;class _Pr, class _Ty1, class _Ty2,
    enable_if_t&lt;!is_same_v&lt;_Remove_cvref_t&lt;_Ty1&gt;, _Remove_cvref_t&lt;_Ty2&gt;&gt;, int&gt; = 0&gt;
constexpr bool _Debug_lt_pred(_Pr&amp;&amp; _Pred, _Ty1&amp;&amp; _Left, _Ty2&amp;&amp; _Right) noexcept(noexcept(_Pred(_Left, _Right))) {
    // test if _Pred(_Left, _Right); no debug checks as the types differ
    return static_cast&lt;bool&gt;(_Pred(_Left, _Right));
}

template &lt;class _InIt, class _Sentinel, class _Pr&gt;
constexpr void _Debug_order_unchecked(_InIt _First, _Sentinel _Last, _Pr&amp;&amp; _Pred) {
    // test if range is ordered by predicate
    if constexpr (_Is_ranges_fwd_iter_v&lt;_InIt&gt;) {
        if (_First != _Last) {
            for (auto _Next = _First; ++_Next != _Last; _First = _Next) {
                _STL_VERIFY(!static_cast&lt;bool&gt;(_Pred(*_Next, *_First)), "sequence not ordered");
            }
        }
    }
}

template &lt;class _OtherIt, class _InIt, class _Pr&gt;
constexpr void _Debug_order_set_unchecked(_InIt _First, _InIt _Last, _Pr&amp;&amp; _Pred) {
    // test if range is ordered by predicate
    if constexpr (is_same_v&lt;_Iter_value_t&lt;_OtherIt&gt;, _Iter_value_t&lt;_InIt&gt;&gt;) {
        _Debug_order_unchecked(_First, _Last, _Pred);
    }
}
#endif // _ITERATOR_DEBUG_LEVEL &lt; 2

// from &lt;iterator&gt;
_EXPORT_STD template &lt;class _InIt, class _Diff&gt;
_CONSTEXPR17 void advance(_InIt&amp; _Where, _Diff _Off) { // increment iterator by offset
    if constexpr (_Is_ranges_random_iter_v&lt;_InIt&gt;) {
        _Where += _Off;
    } else {
        if constexpr (is_signed_v&lt;_Diff&gt; &amp;&amp; !_Is_ranges_bidi_iter_v&lt;_InIt&gt;) {
            _STL_ASSERT(_Off &gt;= 0, "negative advance of non-bidirectional iterator");
        }

        decltype(auto) _UWhere      = _Get_unwrapped_n(_STD move(_Where), _Off);
        constexpr bool _Need_rewrap = !is_reference_v&lt;decltype(_Get_unwrapped_n(_STD move(_Where), _Off))&gt;;

        if constexpr (is_signed_v&lt;_Diff&gt; &amp;&amp; _Is_ranges_bidi_iter_v&lt;_InIt&gt;) {
            for (; _Off &lt; 0; ++_Off) {
                --_UWhere;
            }
        }

        for (; 0 &lt; _Off; --_Off) {
            ++_UWhere;
        }

        if constexpr (_Need_rewrap) {
            _Seek_wrapped(_Where, _STD move(_UWhere));
        }
    }
}

_EXPORT_STD template &lt;class _InIt&gt;
_NODISCARD _CONSTEXPR17 _Iter_diff_t&lt;_InIt&gt; distance(_InIt _First, _InIt _Last) {
    if constexpr (_Is_ranges_random_iter_v&lt;_InIt&gt;) {
        return _Last - _First; // assume the iterator will do debug checking
    } else {
        _Adl_verify_range(_First, _Last);
        auto _UFirst             = _Get_unwrapped(_First);
        const auto _ULast        = _Get_unwrapped(_Last);
        _Iter_diff_t&lt;_InIt&gt; _Off = 0;
        for (; _UFirst != _ULast; ++_UFirst) {
            ++_Off;
        }

        return _Off;
    }
}

template &lt;class _InIt&gt;
constexpr _InIt _Next_iter(_InIt _First) { // increment iterator
    return ++_First;
}

_EXPORT_STD template &lt;class _InIt&gt;
_NODISCARD _CONSTEXPR17 _InIt next(_InIt _First, _Iter_diff_t&lt;_InIt&gt; _Off = 1) { // increment iterator
    static_assert(_Is_ranges_input_iter_v&lt;_InIt&gt;, "next requires input iterator");

    _STD advance(_First, _Off);
    return _First;
}

template &lt;class _BidIt&gt;
constexpr _BidIt _Prev_iter(_BidIt _First) { // decrement iterator
    return --_First;
}

_EXPORT_STD template &lt;class _BidIt&gt;
_NODISCARD _CONSTEXPR17 _BidIt prev(_BidIt _First, _Iter_diff_t&lt;_BidIt&gt; _Off = 1) { // decrement iterator
    static_assert(_Is_ranges_bidi_iter_v&lt;_BidIt&gt;, "prev requires bidirectional iterator");

    _STD advance(_First, -_Off);
    return _First;
}

template &lt;class _Iter, class _Pointer, bool = is_pointer_v&lt;_Remove_cvref_t&lt;_Iter&gt;&gt;&gt;
_INLINE_VAR constexpr bool _Has_nothrow_operator_arrow = _Is_nothrow_convertible_v&lt;_Iter, _Pointer&gt;;

template &lt;class _Iter, class _Pointer&gt;
_INLINE_VAR constexpr bool _Has_nothrow_operator_arrow&lt;_Iter, _Pointer, false&gt; =
    noexcept(_Fake_copy_init&lt;_Pointer&gt;(_STD declval&lt;_Iter&gt;().operator-&gt;()));

_EXPORT_STD template &lt;class _BidIt&gt;
class reverse_iterator {
public:
    using iterator_type = _BidIt;

#ifdef __cpp_lib_concepts
    using iterator_concept =
        conditional_t&lt;random_access_iterator&lt;_BidIt&gt;, random_access_iterator_tag, bidirectional_iterator_tag&gt;;
    using iterator_category = conditional_t&lt;derived_from&lt;_Iter_cat_t&lt;_BidIt&gt;, random_access_iterator_tag&gt;,
        random_access_iterator_tag, _Iter_cat_t&lt;_BidIt&gt;&gt;;
#else // ^^^ __cpp_lib_concepts / !__cpp_lib_concepts vvv
    using iterator_category = _Iter_cat_t&lt;_BidIt&gt;;
#endif // __cpp_lib_concepts
    using value_type      = _Iter_value_t&lt;_BidIt&gt;;
    using difference_type = _Iter_diff_t&lt;_BidIt&gt;;
    using pointer         = typename iterator_traits&lt;_BidIt&gt;::pointer;
    using reference       = _Iter_ref_t&lt;_BidIt&gt;;

    template &lt;class&gt;
    friend class reverse_iterator;

    _CONSTEXPR17 reverse_iterator() = default;

    _CONSTEXPR17 explicit reverse_iterator(_BidIt _Right) noexcept(
        is_nothrow_move_constructible_v&lt;_BidIt&gt;) // strengthened
        : current(_STD move(_Right)) {}

    // clang-format off
    template &lt;class _Other&gt;
#ifdef __cpp_lib_concepts
        requires (!is_same_v&lt;_Other, _BidIt&gt;) &amp;&amp; convertible_to&lt;const _Other&amp;, _BidIt&gt;
#endif // __cpp_lib_concepts
    _CONSTEXPR17 reverse_iterator(const reverse_iterator&lt;_Other&gt;&amp; _Right) noexcept(
        is_nothrow_constructible_v&lt;_BidIt, const _Other&amp;&gt;) // strengthened
        : current(_Right.current) {}

    template &lt;class _Other&gt;
#ifdef __cpp_lib_concepts
        requires (!is_same_v&lt;_Other, _BidIt&gt;) &amp;&amp; convertible_to&lt;const _Other&amp;, _BidIt&gt;
            &amp;&amp; assignable_from&lt;_BidIt&amp;, const _Other&amp;&gt;
#endif // __cpp_lib_concepts
    _CONSTEXPR17 reverse_iterator&amp; operator=(const reverse_iterator&lt;_Other&gt;&amp; _Right) noexcept(
        is_nothrow_assignable_v&lt;_BidIt&amp;, const _Other&amp;&gt;) /* strengthened */ {
        current = _Right.current;
        return *this;
    }
    // clang-format on

    _NODISCARD _CONSTEXPR17 _BidIt base() const noexcept(is_nothrow_copy_constructible_v&lt;_BidIt&gt;) /* strengthened */ {
        return current;
    }

    _NODISCARD _CONSTEXPR17 reference operator*() const
        noexcept(is_nothrow_copy_constructible_v&lt;_BidIt&gt;&amp;&amp; noexcept(*--(_STD declval&lt;_BidIt&amp;&gt;()))) /* strengthened */ {
        _BidIt _Tmp = current;
        return *--_Tmp;
    }

    _NODISCARD _CONSTEXPR17 pointer operator-&gt;() const
        noexcept(is_nothrow_copy_constructible_v&lt;_BidIt&gt;&amp;&amp; noexcept(--(_STD declval&lt;_BidIt&amp;&gt;()))
                 &amp;&amp; _Has_nothrow_operator_arrow&lt;_BidIt&amp;, pointer&gt;) /* strengthened */
#ifdef __cpp_lib_concepts
        requires (is_pointer_v&lt;_BidIt&gt; || requires(const _BidIt __i) { __i.operator-&gt;(); })
#endif
    {
        _BidIt _Tmp = current;
        --_Tmp;
        if constexpr (is_pointer_v&lt;_BidIt&gt;) {
            return _Tmp;
        } else {
            return _Tmp.operator-&gt;();
        }
    }

    _CONSTEXPR17 reverse_iterator&amp; operator++() noexcept(noexcept(--current)) /* strengthened */ {
        --current;
        return *this;
    }

    _CONSTEXPR17 reverse_iterator operator++(int) noexcept(
        is_nothrow_copy_constructible_v&lt;_BidIt&gt;&amp;&amp; noexcept(--current)) /* strengthened */ {
        reverse_iterator _Tmp = *this;
        --current;
        return _Tmp;
    }

    _CONSTEXPR17 reverse_iterator&amp; operator--() noexcept(noexcept(++current)) /* strengthened */ {
        ++current;
        return *this;
    }

    _CONSTEXPR17 reverse_iterator operator--(int) noexcept(
        is_nothrow_copy_constructible_v&lt;_BidIt&gt;&amp;&amp; noexcept(++current)) /* strengthened */ {
        reverse_iterator _Tmp = *this;
        ++current;
        return _Tmp;
    }

    _NODISCARD _CONSTEXPR17 reverse_iterator operator+(const difference_type _Off) const
        noexcept(noexcept(reverse_iterator(current - _Off))) /* strengthened */ {
        return reverse_iterator(current - _Off);
    }

    _CONSTEXPR17 reverse_iterator&amp; operator+=(const difference_type _Off) noexcept(
        noexcept(current -= _Off)) /* strengthened */ {
        current -= _Off;
        return *this;
    }

    _NODISCARD _CONSTEXPR17 reverse_iterator operator-(const difference_type _Off) const
        noexcept(noexcept(reverse_iterator(current + _Off))) /* strengthened */ {
        return reverse_iterator(current + _Off);
    }

    _CONSTEXPR17 reverse_iterator&amp; operator-=(const difference_type _Off) noexcept(
        noexcept(current += _Off)) /* strengthened */ {
        current += _Off;
        return *this;
    }

    _NODISCARD _CONSTEXPR17 reference operator[](const difference_type _Off) const
        noexcept(noexcept(_Fake_copy_init&lt;reference&gt;(current[_Off]))) /* strengthened */ {
        return current[static_cast&lt;difference_type&gt;(-_Off - 1)];
    }

#ifdef __cpp_lib_concepts
    _NODISCARD_FRIEND constexpr iter_rvalue_reference_t&lt;_BidIt&gt; iter_move(const reverse_iterator&amp; _It) noexcept(
        is_nothrow_copy_constructible_v&lt;_BidIt&gt;&amp;&amp; noexcept(_RANGES iter_move(--_STD declval&lt;_BidIt&amp;&gt;()))) {
        auto _Tmp = _It.current;
        --_Tmp;
        return _RANGES iter_move(_Tmp);
    }

    template &lt;indirectly_swappable&lt;_BidIt&gt; _BidIt2&gt;
    friend constexpr void iter_swap(const reverse_iterator&amp; _Left, const reverse_iterator&lt;_BidIt2&gt;&amp; _Right) noexcept(
        is_nothrow_copy_constructible_v&lt;_BidIt&gt;&amp;&amp; is_nothrow_copy_constructible_v&lt;_BidIt2&gt;&amp;&amp; noexcept(
            _RANGES iter_swap(--_STD declval&lt;_BidIt&amp;&gt;(), --_STD declval&lt;_BidIt2&amp;&gt;()))) {
        auto _LTmp = _Left.current;
        auto _RTmp = _Right.base();
        --_LTmp;
        --_RTmp;
        _RANGES iter_swap(_LTmp, _RTmp);
    }
#endif // __cpp_lib_concepts

    using _Prevent_inheriting_unwrap = reverse_iterator;

    template &lt;class _BidIt2, enable_if_t&lt;_Range_verifiable_v&lt;_BidIt, _BidIt2&gt;, int&gt; = 0&gt;
    friend constexpr void _Verify_range(
        const reverse_iterator&amp; _First, const reverse_iterator&lt;_BidIt2&gt;&amp; _Last) noexcept {
        _Verify_range(_Last._Get_current(), _First.current); // note reversed parameters
    }

    template &lt;class _BidIt2 = _BidIt, enable_if_t&lt;_Offset_verifiable_v&lt;_BidIt2&gt;, int&gt; = 0&gt;
    constexpr void _Verify_offset(const difference_type _Off) const noexcept {
        _STL_VERIFY(_Off != _Min_possible_v&lt;difference_type&gt;, "integer overflow");
        current._Verify_offset(-_Off);
    }

    template &lt;class _BidIt2 = _BidIt, enable_if_t&lt;_Unwrappable_v&lt;const _BidIt2&amp;&gt;, int&gt; = 0&gt;
    _NODISCARD constexpr reverse_iterator&lt;_Unwrapped_t&lt;const _BidIt2&amp;&gt;&gt; _Unwrapped() const&amp; noexcept(
        noexcept(static_cast&lt;reverse_iterator&lt;_Unwrapped_t&lt;const _BidIt2&amp;&gt;&gt;&gt;(current._Unwrapped()))) {
        return static_cast&lt;reverse_iterator&lt;_Unwrapped_t&lt;const _BidIt2&amp;&gt;&gt;&gt;(current._Unwrapped());
    }
    template &lt;class _BidIt2 = _BidIt, enable_if_t&lt;_Unwrappable_v&lt;_BidIt2&gt;, int&gt; = 0&gt;
    _NODISCARD constexpr reverse_iterator&lt;_Unwrapped_t&lt;_BidIt2&gt;&gt; _Unwrapped() &amp;&amp; noexcept(
        noexcept(static_cast&lt;reverse_iterator&lt;_Unwrapped_t&lt;_BidIt2&gt;&gt;&gt;(_STD move(current)._Unwrapped()))) {
        return static_cast&lt;reverse_iterator&lt;_Unwrapped_t&lt;_BidIt2&gt;&gt;&gt;(_STD move(current)._Unwrapped());
    }

    static constexpr bool _Unwrap_when_unverified = _Do_unwrap_when_unverified_v&lt;_BidIt&gt;;

    template &lt;class _Src, enable_if_t&lt;_Wrapped_seekable_v&lt;_BidIt, const _Src&amp;&gt;, int&gt; = 0&gt;
    constexpr void _Seek_to(const reverse_iterator&lt;_Src&gt;&amp; _It) noexcept(noexcept(current._Seek_to(_It.current))) {
        current._Seek_to(_It.current);
    }

    _NODISCARD constexpr const _BidIt&amp; _Get_current() const noexcept {
        return current;
    }

protected:
    _BidIt current{};
};

_EXPORT_STD template &lt;class _BidIt1, class _BidIt2&gt;
_NODISCARD _CONSTEXPR17 bool
    operator==(const reverse_iterator&lt;_BidIt1&gt;&amp; _Left, const reverse_iterator&lt;_BidIt2&gt;&amp; _Right) noexcept(
        noexcept(_Fake_copy_init&lt;bool&gt;(_Left._Get_current() == _Right._Get_current()))) /* strengthened */
#ifdef __cpp_lib_concepts
    // clang-format off
    requires requires {
        { _Left._Get_current() == _Right._Get_current() } -&gt; _Implicitly_convertible_to&lt;bool&gt;;
    }
// clang-format on
#endif // __cpp_lib_concepts
{
    return _Left._Get_current() == _Right._Get_current();
}

_EXPORT_STD template &lt;class _BidIt1, class _BidIt2&gt;
_NODISCARD _CONSTEXPR17 bool
    operator!=(const reverse_iterator&lt;_BidIt1&gt;&amp; _Left, const reverse_iterator&lt;_BidIt2&gt;&amp; _Right) noexcept(
        noexcept(_Fake_copy_init&lt;bool&gt;(_Left._Get_current() != _Right._Get_current()))) /* strengthened */
#ifdef __cpp_lib_concepts
    // clang-format off
    requires requires {
        { _Left._Get_current() != _Right._Get_current() } -&gt; _Implicitly_convertible_to&lt;bool&gt;;
    }
// clang-format on
#endif // __cpp_lib_concepts
{
    return _Left._Get_current() != _Right._Get_current();
}

_EXPORT_STD template &lt;class _BidIt1, class _BidIt2&gt;
_NODISCARD _CONSTEXPR17 bool
    operator&lt;(const reverse_iterator&lt;_BidIt1&gt;&amp; _Left, const reverse_iterator&lt;_BidIt2&gt;&amp; _Right) noexcept(
        noexcept(_Fake_copy_init&lt;bool&gt;(_Left._Get_current() &gt; _Right._Get_current()))) /* strengthened */
#ifdef __cpp_lib_concepts
    // clang-format off
    requires requires {
        { _Left._Get_current() &gt; _Right._Get_current() } -&gt; _Implicitly_convertible_to&lt;bool&gt;;
    }
// clang-format on
#endif // __cpp_lib_concepts
{
    return _Left._Get_current() &gt; _Right._Get_current();
}

_EXPORT_STD template &lt;class _BidIt1, class _BidIt2&gt;
_NODISCARD _CONSTEXPR17 bool
    operator&gt;(const reverse_iterator&lt;_BidIt1&gt;&amp; _Left, const reverse_iterator&lt;_BidIt2&gt;&amp; _Right) noexcept(
        noexcept(_Fake_copy_init&lt;bool&gt;(_Left._Get_current() &lt; _Right._Get_current()))) /* strengthened */
#ifdef __cpp_lib_concepts
    // clang-format off
    requires requires {
        { _Left._Get_current() &lt; _Right._Get_current() } -&gt; _Implicitly_convertible_to&lt;bool&gt;;
    }
// clang-format on
#endif // __cpp_lib_concepts
{
    return _Left._Get_current() &lt; _Right._Get_current();
}

_EXPORT_STD template &lt;class _BidIt1, class _BidIt2&gt;
_NODISCARD _CONSTEXPR17 bool
    operator&lt;=(const reverse_iterator&lt;_BidIt1&gt;&amp; _Left, const reverse_iterator&lt;_BidIt2&gt;&amp; _Right) noexcept(
        noexcept(_Fake_copy_init&lt;bool&gt;(_Left._Get_current() &gt;= _Right._Get_current()))) /* strengthened */
#ifdef __cpp_lib_concepts
    // clang-format off
    requires requires {
        { _Left._Get_current() &gt;= _Right._Get_current() } -&gt; _Implicitly_convertible_to&lt;bool&gt;;
    }
// clang-format on
#endif // __cpp_lib_concepts
{
    return _Left._Get_current() &gt;= _Right._Get_current();
}

_EXPORT_STD template &lt;class _BidIt1, class _BidIt2&gt;
_NODISCARD _CONSTEXPR17 bool
    operator&gt;=(const reverse_iterator&lt;_BidIt1&gt;&amp; _Left, const reverse_iterator&lt;_BidIt2&gt;&amp; _Right) noexcept(
        noexcept(_Fake_copy_init&lt;bool&gt;(_Left._Get_current() &lt;= _Right._Get_current()))) /* strengthened */
#ifdef __cpp_lib_concepts
    // clang-format off
    requires requires {
        { _Left._Get_current() &lt;= _Right._Get_current() } -&gt; _Implicitly_convertible_to&lt;bool&gt;;
    }
// clang-format on
#endif // __cpp_lib_concepts
{
    return _Left._Get_current() &lt;= _Right._Get_current();
}

#ifdef __cpp_lib_concepts
_EXPORT_STD template &lt;class _BidIt1, three_way_comparable_with&lt;_BidIt1&gt; _BidIt2&gt;
_NODISCARD constexpr compare_three_way_result_t&lt;_BidIt1, _BidIt2&gt;
    operator&lt;=&gt;(const reverse_iterator&lt;_BidIt1&gt;&amp; _Left, const reverse_iterator&lt;_BidIt2&gt;&amp; _Right) noexcept(
        noexcept(_Right._Get_current() &lt;=&gt; _Left._Get_current())) /* strengthened */ {
    return _Right._Get_current() &lt;=&gt; _Left._Get_current();
}
#endif // __cpp_lib_concepts

_EXPORT_STD template &lt;class _BidIt1, class _BidIt2&gt;
_NODISCARD _CONSTEXPR17 auto
    operator-(const reverse_iterator&lt;_BidIt1&gt;&amp; _Left, const reverse_iterator&lt;_BidIt2&gt;&amp; _Right) noexcept(
        noexcept(_Right._Get_current() - _Left._Get_current())) /* strengthened */
    -&gt; decltype(_Right._Get_current() - _Left._Get_current()) {
    return _Right._Get_current() - _Left._Get_current();
}

_EXPORT_STD template &lt;class _BidIt&gt;
_NODISCARD _CONSTEXPR17 reverse_iterator&lt;_BidIt&gt; operator+(typename reverse_iterator&lt;_BidIt&gt;::difference_type _Off,
    const reverse_iterator&lt;_BidIt&gt;&amp; _Right) noexcept(noexcept(_Right + _Off)) /* strengthened */ {
    return _Right + _Off;
}

_EXPORT_STD template &lt;class _BidIt&gt;
_NODISCARD _CONSTEXPR17 reverse_iterator&lt;_BidIt&gt; make_reverse_iterator(_BidIt _Iter) noexcept(
    is_nothrow_move_constructible_v&lt;_BidIt&gt;) /* strengthened */ {
    return reverse_iterator&lt;_BidIt&gt;(_STD move(_Iter));
}

#ifdef __cpp_lib_concepts
template &lt;class _BidIt1, class _BidIt2&gt;
    requires (!sized_sentinel_for&lt;_BidIt1, _BidIt2&gt;)
inline constexpr bool disable_sized_sentinel_for&lt;reverse_iterator&lt;_BidIt1&gt;, reverse_iterator&lt;_BidIt2&gt;&gt; = true;
#endif // __cpp_lib_concepts

_EXPORT_STD template &lt;class _Container&gt;
_NODISCARD _CONSTEXPR17 auto begin(_Container&amp; _Cont) noexcept(noexcept(_Cont.begin())) /* strengthened */
    -&gt; decltype(_Cont.begin()) {
    return _Cont.begin();
}

_EXPORT_STD template &lt;class _Container&gt;
_NODISCARD _CONSTEXPR17 auto begin(const _Container&amp; _Cont) noexcept(noexcept(_Cont.begin())) /* strengthened */
    -&gt; decltype(_Cont.begin()) {
    return _Cont.begin();
}

_EXPORT_STD template &lt;class _Container&gt;
_NODISCARD _CONSTEXPR17 auto end(_Container&amp; _Cont) noexcept(noexcept(_Cont.end())) /* strengthened */
    -&gt; decltype(_Cont.end()) {
    return _Cont.end();
}

_EXPORT_STD template &lt;class _Container&gt;
_NODISCARD _CONSTEXPR17 auto end(const _Container&amp; _Cont) noexcept(noexcept(_Cont.end())) /* strengthened */
    -&gt; decltype(_Cont.end()) {
    return _Cont.end();
}

_EXPORT_STD template &lt;class _Ty, size_t _Size&gt;
_NODISCARD constexpr _Ty* begin(_Ty (&amp;_Array)[_Size]) noexcept {
    return _Array;
}

_EXPORT_STD template &lt;class _Ty, size_t _Size&gt;
_NODISCARD constexpr _Ty* end(_Ty (&amp;_Array)[_Size]) noexcept {
    return _Array + _Size;
}

_EXPORT_STD template &lt;class _Container&gt;
_NODISCARD constexpr auto cbegin(const _Container&amp; _Cont) noexcept(noexcept(_STD begin(_Cont)))
    -&gt; decltype(_STD begin(_Cont)) {
    return _STD begin(_Cont);
}

_EXPORT_STD template &lt;class _Container&gt;
_NODISCARD constexpr auto cend(const _Container&amp; _Cont) noexcept(noexcept(_STD end(_Cont)))
    -&gt; decltype(_STD end(_Cont)) {
    return _STD end(_Cont);
}

_EXPORT_STD template &lt;class _Container&gt;
_NODISCARD _CONSTEXPR17 auto rbegin(_Container&amp; _Cont) noexcept(noexcept(_Cont.rbegin())) /* strengthened */
    -&gt; decltype(_Cont.rbegin()) {
    return _Cont.rbegin();
}

_EXPORT_STD template &lt;class _Container&gt;
_NODISCARD _CONSTEXPR17 auto rbegin(const _Container&amp; _Cont) noexcept(noexcept(_Cont.rbegin())) /* strengthened */
    -&gt; decltype(_Cont.rbegin()) {
    return _Cont.rbegin();
}

_EXPORT_STD template &lt;class _Container&gt;
_NODISCARD _CONSTEXPR17 auto rend(_Container&amp; _Cont) noexcept(noexcept(_Cont.rend())) /* strengthened */
    -&gt; decltype(_Cont.rend()) {
    return _Cont.rend();
}

_EXPORT_STD template &lt;class _Container&gt;
_NODISCARD _CONSTEXPR17 auto rend(const _Container&amp; _Cont) noexcept(noexcept(_Cont.rend())) /* strengthened */
    -&gt; decltype(_Cont.rend()) {
    return _Cont.rend();
}

_EXPORT_STD template &lt;class _Ty, size_t _Size&gt;
_NODISCARD _CONSTEXPR17 reverse_iterator&lt;_Ty*&gt; rbegin(_Ty (&amp;_Array)[_Size]) noexcept /* strengthened */ {
    return reverse_iterator&lt;_Ty*&gt;(_Array + _Size);
}

_EXPORT_STD template &lt;class _Ty, size_t _Size&gt;
_NODISCARD _CONSTEXPR17 reverse_iterator&lt;_Ty*&gt; rend(_Ty (&amp;_Array)[_Size]) noexcept /* strengthened */ {
    return reverse_iterator&lt;_Ty*&gt;(_Array);
}

_EXPORT_STD template &lt;class _Elem&gt;
_NODISCARD _CONSTEXPR17 reverse_iterator&lt;const _Elem*&gt; rbegin(initializer_list&lt;_Elem&gt; _Ilist) noexcept
/* strengthened */ {
    return reverse_iterator&lt;const _Elem*&gt;(_Ilist.end());
}

_EXPORT_STD template &lt;class _Elem&gt;
_NODISCARD _CONSTEXPR17 reverse_iterator&lt;const _Elem*&gt; rend(initializer_list&lt;_Elem&gt; _Ilist) noexcept
/* strengthened */ {
    return reverse_iterator&lt;const _Elem*&gt;(_Ilist.begin());
}

_EXPORT_STD template &lt;class _Container&gt;
_NODISCARD _CONSTEXPR17 auto crbegin(const _Container&amp; _Cont) noexcept(noexcept(_STD rbegin(_Cont))) /* strengthened */
    -&gt; decltype(_STD rbegin(_Cont)) {
    return _STD rbegin(_Cont);
}

_EXPORT_STD template &lt;class _Container&gt;
_NODISCARD _CONSTEXPR17 auto crend(const _Container&amp; _Cont) noexcept(noexcept(_STD rend(_Cont))) /* strengthened */
    -&gt; decltype(_STD rend(_Cont)) {
    return _STD rend(_Cont);
}

_EXPORT_STD template &lt;class _Container&gt;
_NODISCARD constexpr auto size(const _Container&amp; _Cont) noexcept(noexcept(_Cont.size())) /* strengthened */
    -&gt; decltype(_Cont.size()) {
    return _Cont.size();
}

_EXPORT_STD template &lt;class _Ty, size_t _Size&gt;
_NODISCARD constexpr size_t size(const _Ty (&amp;)[_Size]) noexcept {
    return _Size;
}

#if _HAS_CXX20
_EXPORT_STD template &lt;class _Container&gt;
_NODISCARD constexpr auto ssize(const _Container&amp; _Cont) noexcept(noexcept(
    static_cast&lt;common_type_t&lt;ptrdiff_t, make_signed_t&lt;decltype(_Cont.size())&gt;&gt;&gt;(_Cont.size()))) /* strengthened */
    -&gt; common_type_t&lt;ptrdiff_t, make_signed_t&lt;decltype(_Cont.size())&gt;&gt; {
    using _Common = common_type_t&lt;ptrdiff_t, make_signed_t&lt;decltype(_Cont.size())&gt;&gt;;
    return static_cast&lt;_Common&gt;(_Cont.size());
}

_EXPORT_STD template &lt;class _Ty, ptrdiff_t _Size&gt;
_NODISCARD constexpr ptrdiff_t ssize(const _Ty (&amp;)[_Size]) noexcept {
    return _Size;
}
#endif // _HAS_CXX20

_EXPORT_STD template &lt;class _Container&gt;
_NODISCARD_EMPTY_NON_MEMBER constexpr auto empty(const _Container&amp; _Cont) noexcept(
    noexcept(_Cont.empty())) /* strengthened */
    -&gt; decltype(_Cont.empty()) {
    return _Cont.empty();
}

_EXPORT_STD template &lt;class _Ty, size_t _Size&gt;
_NODISCARD_EMPTY_NON_MEMBER constexpr bool empty(const _Ty (&amp;)[_Size]) noexcept {
    return false;
}

_EXPORT_STD template &lt;class _Elem&gt;
_NODISCARD_EMPTY_NON_MEMBER constexpr bool empty(initializer_list&lt;_Elem&gt; _Ilist) noexcept {
    return _Ilist.size() == 0;
}

_EXPORT_STD template &lt;class _Container&gt;
_NODISCARD constexpr auto data(_Container&amp; _Cont) noexcept(noexcept(_Cont.data())) /* strengthened */
    -&gt; decltype(_Cont.data()) {
    return _Cont.data();
}

_EXPORT_STD template &lt;class _Container&gt;
_NODISCARD constexpr auto data(const _Container&amp; _Cont) noexcept(noexcept(_Cont.data())) /* strengthened */
    -&gt; decltype(_Cont.data()) {
    return _Cont.data();
}

_EXPORT_STD template &lt;class _Ty, size_t _Size&gt;
_NODISCARD constexpr _Ty* data(_Ty (&amp;_Array)[_Size]) noexcept {
    return _Array;
}

_EXPORT_STD template &lt;class _Elem&gt;
_NODISCARD constexpr const _Elem* data(initializer_list&lt;_Elem&gt; _Ilist) noexcept {
    return _Ilist.begin();
}

#ifdef __cpp_lib_concepts
#if _HAS_CXX23
_EXPORT_STD template &lt;indirectly_readable _Ty&gt;
using iter_const_reference_t = common_reference_t&lt;const iter_value_t&lt;_Ty&gt;&amp;&amp;, iter_reference_t&lt;_Ty&gt;&gt;;

template &lt;class _Ty&gt;
concept _Constant_iterator = input_iterator&lt;_Ty&gt; &amp;&amp; same_as&lt;iter_const_reference_t&lt;_Ty&gt;, iter_reference_t&lt;_Ty&gt;&gt;;

_EXPORT_STD template &lt;input_iterator _Iter&gt;
class basic_const_iterator;

_EXPORT_STD template &lt;input_iterator _Iter&gt;
using const_iterator = conditional_t&lt;_Constant_iterator&lt;_Iter&gt;, _Iter, basic_const_iterator&lt;_Iter&gt;&gt;;

template &lt;class _Sent&gt;
struct _Const_sentinel {
    using type = _Sent;
};

template &lt;input_iterator _Sent&gt;
struct _Const_sentinel&lt;_Sent&gt; {
    using type = const_iterator&lt;_Sent&gt;;
};

_EXPORT_STD template &lt;semiregular _Sent&gt;
using const_sentinel = typename _Const_sentinel&lt;_Sent&gt;::type;

// clang-format off
template &lt;class _Ty&gt;
concept _Not_a_const_iterator = !_Is_specialization_v&lt;_Ty, basic_const_iterator&gt;;
// clang-format on

template &lt;class&gt;
struct _Basic_const_iterator_category {};

template &lt;forward_iterator _Iter&gt;
struct _Basic_const_iterator_category&lt;_Iter&gt; {
    using iterator_category = typename iterator_traits&lt;_Iter&gt;::iterator_category;
};

// TRANSITION, LLVM-55945: These are distinct concepts as a workaround
template &lt;class _Ty, class _Iter&gt;
concept _Bci_order = _Different_from&lt;_Ty, basic_const_iterator&lt;_Iter&gt;&gt; &amp;&amp; random_access_iterator&lt;_Iter&gt;
                  &amp;&amp; totally_ordered_with&lt;_Iter, _Ty&gt;;

template &lt;class _Ty, class _Iter&gt;
concept _Bci_order_3way = _Bci_order&lt;_Ty, _Iter&gt; &amp;&amp; three_way_comparable_with&lt;_Iter, _Ty&gt;;

template &lt;class _Ty, class _Iter&gt;
concept _Not_bci_order =
    _Not_a_const_iterator&lt;_Ty&gt; &amp;&amp; random_access_iterator&lt;_Iter&gt; &amp;&amp; totally_ordered_with&lt;_Iter, _Ty&gt;;

_EXPORT_STD template &lt;input_iterator _Iter&gt;
class basic_const_iterator : public _Basic_const_iterator_category&lt;_Iter&gt; {
private:
    /* [[no_unique_address]] */ _Iter _Current{};

    using _Reference = iter_const_reference_t&lt;_Iter&gt;;

    _NODISCARD static _CONSTEVAL auto _Get_iter_concept() noexcept {
        if constexpr (contiguous_iterator&lt;_Iter&gt;) {
            return contiguous_iterator_tag{};
        } else if constexpr (random_access_iterator&lt;_Iter&gt;) {
            return random_access_iterator_tag{};
        } else if constexpr (bidirectional_iterator&lt;_Iter&gt;) {
            return bidirectional_iterator_tag{};
        } else if constexpr (forward_iterator&lt;_Iter&gt;) {
            return forward_iterator_tag{};
        } else {
            return input_iterator_tag{};
        }
    }

public:
    using iterator_concept = decltype(_Get_iter_concept());
    using value_type       = iter_value_t&lt;_Iter&gt;;
    using difference_type  = iter_difference_t&lt;_Iter&gt;;

    // clang-format off
    basic_const_iterator() requires default_initializable&lt;_Iter&gt; = default;
    // clang-format on

    constexpr basic_const_iterator(_Iter _Current_) noexcept(is_nothrow_move_constructible_v&lt;_Iter&gt;) // strengthened
        : _Current(_STD move(_Current_)) {}

    template &lt;convertible_to&lt;_Iter&gt; _Other&gt;
    constexpr basic_const_iterator(basic_const_iterator&lt;_Other&gt; _Current_) noexcept(
        is_nothrow_constructible_v&lt;_Iter, _Other&gt;) // strengthened
        : _Current(_STD move(_Current_._Current)) {}

    template &lt;_Different_from&lt;basic_const_iterator&gt; _Other&gt;
        requires convertible_to&lt;_Other, _Iter&gt;
    constexpr basic_const_iterator(_Other&amp;&amp; _Current_) noexcept(
        is_nothrow_constructible_v&lt;_Iter, _Other&gt;) // strengthened
        : _Current(_STD forward&lt;_Other&gt;(_Current_)) {}

    _NODISCARD constexpr const _Iter&amp; base() const&amp; noexcept {
        return _Current;
    }

    _NODISCARD constexpr _Iter base() &amp;&amp; noexcept(is_nothrow_move_constructible_v&lt;_Iter&gt;) /* strengthened */ {
        return _STD move(_Current);
    }

    _NODISCARD constexpr _Reference operator*() const
        noexcept(noexcept(static_cast&lt;_Reference&gt;(*_Current))) /* strengthened */ {
        return static_cast&lt;_Reference&gt;(*_Current);
    }

    _NODISCARD constexpr const auto* operator-&gt;() const
        noexcept(contiguous_iterator&lt;_Iter&gt; || noexcept(*_Current)) /* strengthened */
        requires is_lvalue_reference_v&lt;iter_reference_t&lt;_Iter&gt;&gt;
              &amp;&amp; same_as&lt;remove_cvref_t&lt;iter_reference_t&lt;_Iter&gt;&gt;, value_type&gt;
    {
        if constexpr (contiguous_iterator&lt;_Iter&gt;) {
            return _STD to_address(_Current);
        } else {
            return _STD addressof(*_Current);
        }
    }

    constexpr basic_const_iterator&amp; operator++() noexcept(noexcept(++_Current)) /* strengthened */ {
        ++_Current;
        return *this;
    }

    constexpr void operator++(int) noexcept(noexcept(++_Current)) /* strengthened */ {
        ++_Current;
    }

    constexpr basic_const_iterator operator++(int) noexcept(
        noexcept(++*this) &amp;&amp; is_nothrow_copy_constructible_v&lt;basic_const_iterator&gt;) // strengthened
        requires forward_iterator&lt;_Iter&gt;
    {
        auto _Tmp = *this;
        ++*this;
        return _Tmp;
    }

    constexpr basic_const_iterator&amp; operator--() noexcept(noexcept(--_Current)) // strengthened
        requires bidirectional_iterator&lt;_Iter&gt;
    {
        --_Current;
        return *this;
    }

    constexpr basic_const_iterator operator--(int) noexcept(
        noexcept(--*this) &amp;&amp; is_nothrow_copy_constructible_v&lt;basic_const_iterator&gt;) // strengthened
        requires bidirectional_iterator&lt;_Iter&gt;
    {
        auto _Tmp = *this;
        --*this;
        return _Tmp;
    }

    constexpr basic_const_iterator&amp; operator+=(const difference_type _Off) noexcept(
        noexcept(_Current += _Off)) // strengthened
        requires random_access_iterator&lt;_Iter&gt;
    {
        _Current += _Off;
        return *this;
    }

    constexpr basic_const_iterator&amp; operator-=(const difference_type _Off) noexcept(
        noexcept(_Current -= _Off)) // strengthened
        requires random_access_iterator&lt;_Iter&gt;
    {
        _Current -= _Off;
        return *this;
    }

    _NODISCARD constexpr _Reference operator[](const difference_type _Idx) const
        noexcept(noexcept(static_cast&lt;_Reference&gt;(_Current[_Idx]))) // strengthened
        requires random_access_iterator&lt;_Iter&gt;
    {
        return static_cast&lt;_Reference&gt;(_Current[_Idx]);
    }

    template &lt;sentinel_for&lt;_Iter&gt; _Sent&gt;
    _NODISCARD constexpr bool operator==(const _Sent&amp; _Se) const
        noexcept(noexcept(_Fake_copy_init&lt;bool&gt;(_Current == _Se))) /* strengthened */ {
        return _Current == _Se;
    }

    _NODISCARD constexpr bool operator&lt;(const basic_const_iterator&amp; _Right) const
        noexcept(noexcept(_Fake_copy_init&lt;bool&gt;(_Current &lt; _Right._Current))) // strengthened
        requires random_access_iterator&lt;_Iter&gt;
    {
        return _Current &lt; _Right._Current;
    }

    _NODISCARD constexpr bool operator&gt;(const basic_const_iterator&amp; _Right) const
        noexcept(noexcept(_Fake_copy_init&lt;bool&gt;(_Current &gt; _Right._Current))) // strengthened
        requires random_access_iterator&lt;_Iter&gt;
    {
        return _Current &gt; _Right._Current;
    }

    _NODISCARD constexpr bool operator&lt;=(const basic_const_iterator&amp; _Right) const
        noexcept(noexcept(_Fake_copy_init&lt;bool&gt;(_Current &lt;= _Right._Current))) // strengthened
        requires random_access_iterator&lt;_Iter&gt;
    {
        return _Current &lt;= _Right._Current;
    }

    _NODISCARD constexpr bool operator&gt;=(const basic_const_iterator&amp; _Right) const
        noexcept(noexcept(_Fake_copy_init&lt;bool&gt;(_Current &gt;= _Right._Current))) // strengthened
        requires random_access_iterator&lt;_Iter&gt;
    {
        return _Current &gt;= _Right._Current;
    }

    _NODISCARD constexpr auto operator&lt;=&gt;(const basic_const_iterator&amp; _Right) const
        noexcept(noexcept(_Current &lt;=&gt; _Right._Current)) // strengthened
        requires random_access_iterator&lt;_Iter&gt; &amp;&amp; three_way_comparable&lt;_Iter&gt;
    {
        return _Current &lt;=&gt; _Right._Current;
    }

    template &lt;_Bci_order&lt;_Iter&gt; _Other&gt;
    _NODISCARD constexpr bool operator&lt;(const _Other&amp; _Right) const
        noexcept(noexcept(_Fake_copy_init&lt;bool&gt;(_Current &lt; _Right))) /* strengthened */ {
        return _Current &lt; _Right;
    }

    template &lt;_Bci_order&lt;_Iter&gt; _Other&gt;
    _NODISCARD constexpr bool operator&gt;(const _Other&amp; _Right) const
        noexcept(noexcept(_Fake_copy_init&lt;bool&gt;(_Current &gt; _Right))) /* strengthened */ {
        return _Current &gt; _Right;
    }

    template &lt;_Bci_order&lt;_Iter&gt; _Other&gt;
    _NODISCARD constexpr bool operator&lt;=(const _Other&amp; _Right) const
        noexcept(noexcept(_Fake_copy_init&lt;bool&gt;(_Current &lt;= _Right))) /* strengthened */ {
        return _Current &lt;= _Right;
    }

    template &lt;_Bci_order&lt;_Iter&gt; _Other&gt;
    _NODISCARD constexpr bool operator&gt;=(const _Other&amp; _Right) const
        noexcept(noexcept(_Fake_copy_init&lt;bool&gt;(_Current &gt;= _Right))) /* strengthened */ {
        return _Current &gt;= _Right;
    }

    template &lt;_Bci_order_3way&lt;_Iter&gt; _Other&gt;
    _NODISCARD constexpr auto operator&lt;=&gt;(const _Other&amp; _Right) const
        noexcept(noexcept(_Current &lt;=&gt; _Right)) /* strengthened */ {
        return _Current &lt;=&gt; _Right;
    }

    template &lt;_Not_bci_order&lt;_Iter&gt; _Other&gt;
    _NODISCARD_FRIEND constexpr bool operator&lt;(const _Other&amp; _Left, const basic_const_iterator&amp; _Right) noexcept(
        noexcept(_Fake_copy_init&lt;bool&gt;(_Left &lt; _Right._Current))) /* strengthened */ {
        return _Left &lt; _Right._Current;
    }

    template &lt;_Not_bci_order&lt;_Iter&gt; _Other&gt;
    _NODISCARD_FRIEND constexpr bool operator&gt;(const _Other&amp; _Left, const basic_const_iterator&amp; _Right) noexcept(
        noexcept(_Fake_copy_init&lt;bool&gt;(_Left &gt; _Right._Current))) /* strengthened */ {
        return _Left &gt; _Right._Current;
    }

    template &lt;_Not_bci_order&lt;_Iter&gt; _Other&gt;
    _NODISCARD_FRIEND constexpr bool operator&lt;=(const _Other&amp; _Left, const basic_const_iterator&amp; _Right) noexcept(
        noexcept(_Fake_copy_init&lt;bool&gt;(_Left &lt;= _Right._Current))) /* strengthened */ {
        return _Left &lt;= _Right._Current;
    }

    template &lt;_Not_bci_order&lt;_Iter&gt; _Other&gt;
    _NODISCARD_FRIEND constexpr bool operator&gt;=(const _Other&amp; _Left, const basic_const_iterator&amp; _Right) noexcept(
        noexcept(_Fake_copy_init&lt;bool&gt;(_Left &gt;= _Right._Current))) /* strengthened */ {
        return _Left &gt;= _Right._Current;
    }

    _NODISCARD_FRIEND constexpr basic_const_iterator operator+(const basic_const_iterator&amp; _It,
        const difference_type _Off) noexcept(noexcept(basic_const_iterator{_It._Current + _Off})) // strengthened
        requires random_access_iterator&lt;_Iter&gt;
    {
        return basic_const_iterator{_It._Current + _Off};
    }

    _NODISCARD_FRIEND constexpr basic_const_iterator operator+(const difference_type _Off,
        const basic_const_iterator&amp; _It) noexcept(noexcept(basic_const_iterator{_It._Current + _Off})) // strengthened
        requires random_access_iterator&lt;_Iter&gt;
    {
        return basic_const_iterator{_It._Current + _Off};
    }

    _NODISCARD_FRIEND constexpr basic_const_iterator operator-(const basic_const_iterator&amp; _It,
        const difference_type _Off) noexcept(noexcept(basic_const_iterator{_It._Current - _Off})) // strengthened
        requires random_access_iterator&lt;_Iter&gt;
    {
        return basic_const_iterator{_It._Current - _Off};
    }

    template &lt;sized_sentinel_for&lt;_Iter&gt; _Sent&gt;
    _NODISCARD constexpr difference_type operator-(const _Sent&amp; _Se) const
        noexcept(noexcept(_Current - _Se)) /* strengthened */ {
        return _Current - _Se;
    }

    template &lt;_Not_a_const_iterator _Sent&gt;
        requires sized_sentinel_for&lt;_Sent, _Iter&gt;
    _NODISCARD_FRIEND constexpr difference_type operator-(const _Sent&amp; _Se, const basic_const_iterator&amp; _It) noexcept(
        noexcept(_Se - _It._Current)) /* strengthened */ {
        return _Se - _It._Current;
    }
};

template &lt;class _Ty1, common_with&lt;_Ty1&gt; _Ty2&gt;
struct common_type&lt;basic_const_iterator&lt;_Ty1&gt;, _Ty2&gt; {
    using type = basic_const_iterator&lt;common_type_t&lt;_Ty1, _Ty2&gt;&gt;;
};

template &lt;class _Ty1, common_with&lt;_Ty1&gt; _Ty2&gt;
struct common_type&lt;_Ty2, basic_const_iterator&lt;_Ty1&gt;&gt; {
    using type = basic_const_iterator&lt;common_type_t&lt;_Ty1, _Ty2&gt;&gt;;
};

template &lt;class _Ty1, common_with&lt;_Ty1&gt; _Ty2&gt;
struct common_type&lt;basic_const_iterator&lt;_Ty1&gt;, basic_const_iterator&lt;_Ty2&gt;&gt; {
    using type = basic_const_iterator&lt;common_type_t&lt;_Ty1, _Ty2&gt;&gt;;
};

_EXPORT_STD template &lt;input_iterator _Iter&gt;
_NODISCARD constexpr const_iterator&lt;_Iter&gt; make_const_iterator(_Iter _It) noexcept(
    is_nothrow_constructible_v&lt;const_iterator&lt;_Iter&gt;, _Iter&amp;&gt;) /* strengthened */ {
    return _It;
}

_EXPORT_STD template &lt;semiregular _Sent&gt;
_NODISCARD constexpr const_sentinel&lt;_Sent&gt; make_const_sentinel(_Sent _Se) noexcept(
    is_nothrow_constructible_v&lt;const_sentinel&lt;_Sent&gt;, _Sent&amp;&gt;) /* strengthened */ {
    return _Se;
}
#endif // _HAS_CXX23

namespace ranges {
    template &lt;class&gt;
    inline constexpr bool _Has_complete_elements = false;

    template &lt;class _Ty&gt;
        requires requires(_Ty&amp; __t) { sizeof(__t[0]); }
    inline constexpr bool _Has_complete_elements&lt;_Ty&gt; = true;

    _EXPORT_STD template &lt;class&gt;
    inline constexpr bool enable_borrowed_range = false;

    template &lt;class _Rng&gt;
    concept _Should_range_access = is_lvalue_reference_v&lt;_Rng&gt; || enable_borrowed_range&lt;remove_cvref_t&lt;_Rng&gt;&gt;;

    namespace _Begin {
#if defined(__clang__) || defined(__EDG__) // TRANSITION, VSO-1681199
        void begin() = delete; // Block unqualified name lookup
#else // ^^^ no workaround / workaround vvv
        void begin();
#endif // ^^^ workaround ^^^

        template &lt;class _Ty&gt;
        concept _Has_member = requires(_Ty __t) {
                                  { _Fake_copy_init(__t.begin()) } -&gt; input_or_output_iterator;
                              };

        template &lt;class _Ty&gt;
        concept _Has_ADL = _Has_class_or_enum_type&lt;_Ty&gt; //
                        &amp;&amp; requires(_Ty __t) {
                               { _Fake_copy_init(begin(__t)) } -&gt; input_or_output_iterator; // intentional ADL
                           };

        class _Cpo {
        private:
            enum class _St { _None, _Array, _Member, _Non_member };

            template &lt;class _Ty&gt;
            _NODISCARD static _CONSTEVAL _Choice_t&lt;_St&gt; _Choose() noexcept {
                _STL_INTERNAL_STATIC_ASSERT(is_lvalue_reference_v&lt;_Ty&gt;);
                if constexpr (is_array_v&lt;remove_reference_t&lt;_Ty&gt;&gt;) {
                    static_assert(_Has_complete_elements&lt;_Ty&gt;,
                        "The range access customization point objects "
                        "std::ranges::begin, std::ranges::end, std::ranges::rbegin, std::ranges::rend, "
                        "and std::ranges::data do not accept arrays with incomplete element types.");
                    return {_St::_Array, true};
                } else if constexpr (_Has_member&lt;_Ty&gt;) {
                    return {_St::_Member, noexcept(_Fake_copy_init(_STD declval&lt;_Ty&gt;().begin()))};
                } else if constexpr (_Has_ADL&lt;_Ty&gt;) {
                    return {_St::_Non_member, noexcept(_Fake_copy_init(begin(_STD declval&lt;_Ty&gt;())))}; // intentional ADL
                } else {
                    return {_St::_None};
                }
            }

            template &lt;class _Ty&gt;
            static constexpr _Choice_t&lt;_St&gt; _Choice = _Choose&lt;_Ty&gt;();

        public:
            template &lt;_Should_range_access _Ty&gt;
                requires (_Choice&lt;_Ty&amp;&gt;._Strategy != _St::_None)
            _NODISCARD constexpr auto operator()(_Ty&amp;&amp; _Val) const noexcept(_Choice&lt;_Ty&amp;&gt;._No_throw) {
                constexpr _St _Strat = _Choice&lt;_Ty&amp;&gt;._Strategy;

                if constexpr (_Strat == _St::_Array) {
                    return _Val;
                } else if constexpr (_Strat == _St::_Member) {
                    return _Val.begin();
                } else if constexpr (_Strat == _St::_Non_member) {
                    return begin(_Val); // intentional ADL
                } else {
                    static_assert(_Always_false&lt;_Ty&gt;, "Should be unreachable");
                }
            }
        };
    } // namespace _Begin

    inline namespace _Cpos {
        _EXPORT_STD inline constexpr _Begin::_Cpo begin;
    }

    _EXPORT_STD template &lt;class _Ty&gt;
    using iterator_t = decltype(_RANGES begin(_STD declval&lt;_Ty&amp;&gt;()));

    namespace _End {
#if defined(__clang__) || defined(__EDG__) // TRANSITION, VSO-1681199
        void end() = delete; // Block unqualified name lookup
#else // ^^^ no workaround / workaround vvv
        void end();
#endif // ^^^ workaround ^^^

        template &lt;class _Ty&gt;
        concept _Has_member = requires(_Ty __t) {
                                  { _Fake_copy_init(__t.end()) } -&gt; sentinel_for&lt;iterator_t&lt;_Ty&gt;&gt;;
                              };

        template &lt;class _Ty&gt;
        concept _Has_ADL = _Has_class_or_enum_type&lt;_Ty&gt; //
                        &amp;&amp; requires(_Ty __t) {
                               { _Fake_copy_init(end(__t)) } -&gt; sentinel_for&lt;iterator_t&lt;_Ty&gt;&gt;; // intentional ADL
                           };

        class _Cpo {
        private:
            enum class _St { _None, _Array, _Member, _Non_member };

            template &lt;class _Ty&gt;
            _NODISCARD static _CONSTEVAL _Choice_t&lt;_St&gt; _Choose() noexcept {
                _STL_INTERNAL_STATIC_ASSERT(is_lvalue_reference_v&lt;_Ty&gt;);
                using _UnRef = remove_reference_t&lt;_Ty&gt;;

                if constexpr (is_array_v&lt;_UnRef&gt;) {
                    static_assert(_Has_complete_elements&lt;_UnRef&gt;,
                        "The range access customization point objects "
                        "std::ranges::begin, std::ranges::end, std::ranges::rbegin, std::ranges::rend, "
                        "and std::ranges::data do not accept arrays with incomplete element types.");
                    if constexpr (extent_v&lt;_UnRef&gt; != 0) {
                        return {_St::_Array, true};
                    } else {
                        return {_St::_None};
                    }
                } else if constexpr (_Has_member&lt;_Ty&gt;) {
                    return {_St::_Member, noexcept(_Fake_copy_init(_STD declval&lt;_Ty&gt;().end()))};
                } else if constexpr (_Has_ADL&lt;_Ty&gt;) {
                    return {_St::_Non_member, noexcept(_Fake_copy_init(end(_STD declval&lt;_Ty&gt;())))}; // intentional ADL
                } else {
                    return {_St::_None};
                }
            }

            template &lt;class _Ty&gt;
            static constexpr _Choice_t&lt;_St&gt; _Choice = _Choose&lt;_Ty&gt;();

        public:
            template &lt;_Should_range_access _Ty&gt;
                requires (_Choice&lt;_Ty&amp;&gt;._Strategy != _St::_None)
            _NODISCARD constexpr auto operator()(_Ty&amp;&amp; _Val) const noexcept(_Choice&lt;_Ty&amp;&gt;._No_throw) {
                constexpr _St _Strat = _Choice&lt;_Ty&amp;&gt;._Strategy;

                if constexpr (_Strat == _St::_Array) {
                    // extent_v&lt;remove_reference_t&lt;_Ty&amp;&gt;&gt; reuses specializations from _Choose
                    return _Val + extent_v&lt;remove_reference_t&lt;_Ty&amp;&gt;&gt;;
                } else if constexpr (_Strat == _St::_Member) {
                    return _Val.end();
                } else if constexpr (_Strat == _St::_Non_member) {
                    return end(_Val); // intentional ADL
                } else {
                    static_assert(_Always_false&lt;_Ty&gt;, "should be unreachable");
                }
            }
        };
    } // namespace _End

    inline namespace _Cpos {
        _EXPORT_STD inline constexpr _End::_Cpo end;
    }

    _EXPORT_STD template &lt;class _Rng&gt;
    concept range = requires(_Rng &amp; __r) {
                        _RANGES begin(__r);
                        _RANGES end(__r);
                    };

    _EXPORT_STD template &lt;class _Rng&gt;
    concept input_range = range&lt;_Rng&gt; &amp;&amp; input_iterator&lt;iterator_t&lt;_Rng&gt;&gt;;

    _EXPORT_STD template &lt;range _Rng&gt;
    using sentinel_t = decltype(_RANGES end(_STD declval&lt;_Rng&amp;&gt;()));

    template &lt;class _Wrapped&gt;
    concept _Weakly_unwrappable =
        same_as&lt;typename remove_cvref_t&lt;_Wrapped&gt;::_Prevent_inheriting_unwrap, remove_cvref_t&lt;_Wrapped&gt;&gt;
        &amp;&amp; requires(_Wrapped&amp;&amp; _Wr) { _STD forward&lt;_Wrapped&gt;(_Wr)._Unwrapped(); };

    template &lt;class _Sent&gt;
    concept _Weakly_unwrappable_sentinel = _Weakly_unwrappable&lt;const remove_reference_t&lt;_Sent&gt;&amp;&gt;;

    template &lt;class _Iter&gt;
    concept _Weakly_unwrappable_iterator = //
        _Weakly_unwrappable&lt;_Iter&gt; //
        &amp;&amp; requires(
            _Iter&amp;&amp; _It, remove_cvref_t&lt;_Iter&gt;&amp; _MutIt) { _MutIt._Seek_to(_STD forward&lt;_Iter&gt;(_It)._Unwrapped()); };

    template &lt;class _Sent, class _Iter&gt;
    concept _Unwrappable_sentinel_for = //
        _Weakly_unwrappable_sentinel&lt;_Sent&gt; //
        &amp;&amp; _Weakly_unwrappable_iterator&lt;_Iter&gt; //
        &amp;&amp; requires(_Iter&amp;&amp; _It, const remove_reference_t&lt;_Sent&gt;&amp; _Se) {
               { _Se._Unwrapped() } -&gt; sentinel_for&lt;decltype(_STD forward&lt;_Iter&gt;(_It)._Unwrapped())&gt;;
           };

    template &lt;class _Sent, class _Iter&gt;
    _NODISCARD constexpr decltype(auto) _Unwrap_iter(_Iter&amp;&amp; _It) noexcept(
        !_Unwrappable_sentinel_for&lt;_Sent, _Iter&gt; || _Has_nothrow_unwrapped&lt;_Iter&gt;) {
        _STL_INTERNAL_STATIC_ASSERT(sentinel_for&lt;remove_cvref_t&lt;_Sent&gt;, remove_cvref_t&lt;_Iter&gt;&gt;);
        if constexpr (is_pointer_v&lt;remove_cvref_t&lt;_Iter&gt;&gt;) {
            return _It + 0;
        } else if constexpr (_Unwrappable_sentinel_for&lt;_Sent, _Iter&gt;) {
            return static_cast&lt;_Iter&amp;&amp;&gt;(_It)._Unwrapped();
        } else {
            return static_cast&lt;_Iter&amp;&amp;&gt;(_It);
        }
    }

    template &lt;class _Iter, class _Sent&gt;
    _NODISCARD constexpr decltype(auto) _Unwrap_sent(_Sent&amp;&amp; _Se) noexcept(
        !_Unwrappable_sentinel_for&lt;_Sent, _Iter&gt; || _Has_nothrow_unwrapped&lt;_Sent&gt;) {
        _STL_INTERNAL_STATIC_ASSERT(sentinel_for&lt;remove_cvref_t&lt;_Sent&gt;, remove_cvref_t&lt;_Iter&gt;&gt;);
        if constexpr (is_pointer_v&lt;remove_cvref_t&lt;_Sent&gt;&gt;) {
            return _Se + 0;
        } else if constexpr (_Unwrappable_sentinel_for&lt;_Sent, _Iter&gt;) {
            return static_cast&lt;_Sent&amp;&amp;&gt;(_Se)._Unwrapped();
        } else {
            return static_cast&lt;_Sent&amp;&amp;&gt;(_Se);
        }
    }

    template &lt;range _Rng, class _Iter&gt;
    _NODISCARD constexpr decltype(auto) _Unwrap_range_iter(_Iter&amp;&amp; _It) noexcept(
        noexcept(_Unwrap_iter&lt;sentinel_t&lt;_Rng&gt;&gt;(static_cast&lt;_Iter&amp;&amp;&gt;(_It)))) {
        _STL_INTERNAL_STATIC_ASSERT(same_as&lt;remove_cvref_t&lt;_Iter&gt;, iterator_t&lt;_Rng&gt;&gt;);
        return _Unwrap_iter&lt;sentinel_t&lt;_Rng&gt;&gt;(static_cast&lt;_Iter&amp;&amp;&gt;(_It));
    }

    template &lt;range _Rng, class _Sent&gt;
    _NODISCARD constexpr decltype(auto) _Unwrap_range_sent(_Sent&amp;&amp; _Se) noexcept(
        noexcept(_Unwrap_sent&lt;iterator_t&lt;_Rng&gt;&gt;(static_cast&lt;_Sent&amp;&amp;&gt;(_Se)))) {
        _STL_INTERNAL_STATIC_ASSERT(same_as&lt;remove_cvref_t&lt;_Sent&gt;, sentinel_t&lt;_Rng&gt;&gt;);
        return _Unwrap_sent&lt;iterator_t&lt;_Rng&gt;&gt;(static_cast&lt;_Sent&amp;&amp;&gt;(_Se));
    }

    template &lt;class _Iter, class _Sent&gt;
    using _Unwrap_iter_t = remove_cvref_t&lt;decltype(_Unwrap_iter&lt;_Sent&gt;(_STD declval&lt;_Iter&gt;()))&gt;;
    template &lt;class _Sent, class _Iter&gt;
    using _Unwrap_sent_t = remove_cvref_t&lt;decltype(_Unwrap_sent&lt;_Iter&gt;(_STD declval&lt;_Sent&gt;()))&gt;;

    template &lt;range _Rng&gt;
    using _Unwrapped_iterator_t = _Unwrap_iter_t&lt;iterator_t&lt;_Rng&gt;, sentinel_t&lt;_Rng&gt;&gt;;
    template &lt;range _Rng&gt;
    using _Unwrapped_sentinel_t = _Unwrap_sent_t&lt;sentinel_t&lt;_Rng&gt;, iterator_t&lt;_Rng&gt;&gt;;

    namespace _Unchecked_begin {
        template &lt;class _Ty&gt;
        concept _Has_member = requires(_Ty&amp; __t) {
                                  { __t._Unchecked_begin() } -&gt; input_or_output_iterator;
                              };

        template &lt;class _Ty&gt;
        concept _Can_begin = requires(_Ty&amp; __t) { _Unwrap_range_iter&lt;_Ty&gt;(_RANGES begin(__t)); };

        class _Cpo {
        private:
            enum class _St { _None, _Member, _Unwrap };

            template &lt;class _Ty&gt;
            _NODISCARD static _CONSTEVAL _Choice_t&lt;_St&gt; _Choose() noexcept {
                _STL_INTERNAL_STATIC_ASSERT(is_lvalue_reference_v&lt;_Ty&gt;);
                if constexpr (_Has_member&lt;_Ty&gt;) {
                    _STL_INTERNAL_STATIC_ASSERT(
                        same_as&lt;decltype(_STD declval&lt;_Ty&gt;()._Unchecked_begin()), _Unwrapped_iterator_t&lt;_Ty&gt;&gt;);
                    return {_St::_Member, noexcept(_Fake_copy_init(_STD declval&lt;_Ty&gt;()._Unchecked_begin()))};
                } else if constexpr (_Can_begin&lt;_Ty&gt;) {
                    return {_St::_Unwrap,
                        noexcept(_Fake_copy_init(_Unwrap_range_iter&lt;_Ty&gt;(_RANGES begin(_STD declval&lt;_Ty&gt;()))))};
                } else {
                    return {_St::_None};
                }
            }

            template &lt;class _Ty&gt;
            static constexpr _Choice_t&lt;_St&gt; _Choice = _Choose&lt;_Ty&gt;();

        public:
            template &lt;_Should_range_access _Ty&gt;
                requires (_Choice&lt;_Ty&amp;&gt;._Strategy != _St::_None)
            _NODISCARD constexpr auto operator()(_Ty&amp;&amp; _Val) const noexcept(_Choice&lt;_Ty&amp;&gt;._No_throw) {
                constexpr _St _Strat = _Choice&lt;_Ty&amp;&gt;._Strategy;

                if constexpr (_Strat == _St::_Member) {
                    return _Val._Unchecked_begin();
                } else if constexpr (_Strat == _St::_Unwrap) {
                    return _Unwrap_range_iter&lt;_Ty&gt;(_RANGES begin(_Val));
                } else {
                    static_assert(_Always_false&lt;_Ty&gt;, "Should be unreachable");
                }
            }
        };
    } // namespace _Unchecked_begin

    inline namespace _Cpos {
        inline constexpr _Unchecked_begin::_Cpo _Ubegin;
    }

    namespace _Unchecked_end {
        template &lt;class _Ty&gt;
        concept _Has_member = _Unchecked_begin::_Has_member&lt;_Ty&gt;
                           &amp;&amp; requires(_Ty&amp; __t) {
                                  __t._Unchecked_begin(); // required explicitly for better diagnostics
                                  { __t._Unchecked_end() } -&gt; sentinel_for&lt;decltype(__t._Unchecked_begin())&gt;;
                              };

        template &lt;class _Ty&gt;
        concept _Can_end = requires(_Ty&amp; __t) { _Unwrap_range_sent&lt;_Ty&gt;(_RANGES end(__t)); };

        class _Cpo {
        private:
            enum class _St { _None, _Member, _Unwrap };

            template &lt;class _Ty&gt;
            _NODISCARD static _CONSTEVAL _Choice_t&lt;_St&gt; _Choose() noexcept {
                _STL_INTERNAL_STATIC_ASSERT(is_lvalue_reference_v&lt;_Ty&gt;);
                if constexpr (_Has_member&lt;_Ty&gt;) {
                    return {_St::_Member, noexcept(_STD declval&lt;_Ty&gt;()._Unchecked_end())};
                } else if constexpr (_Can_end&lt;_Ty&gt;) {
                    return {_St::_Unwrap, noexcept(_Unwrap_range_sent&lt;_Ty&gt;(_RANGES end(_STD declval&lt;_Ty&gt;())))};
                } else {
                    return {_St::_None};
                }
            }

            template &lt;class _Ty&gt;
            static constexpr _Choice_t&lt;_St&gt; _Choice = _Choose&lt;_Ty&gt;();

        public:
            template &lt;_Should_range_access _Ty&gt;
                requires (_Choice&lt;_Ty&amp;&gt;._Strategy != _St::_None)
            _NODISCARD constexpr auto operator()(_Ty&amp;&amp; _Val) const noexcept(_Choice&lt;_Ty&amp;&gt;._No_throw) {
                constexpr _St _Strat = _Choice&lt;_Ty&amp;&gt;._Strategy;

                if constexpr (_Strat == _St::_Member) {
                    return _Val._Unchecked_end();
                } else if constexpr (_Strat == _St::_Unwrap) {
                    return _Unwrap_range_sent&lt;_Ty&gt;(_RANGES end(_Val));
                } else {
                    static_assert(_Always_false&lt;_Ty&gt;, "Should be unreachable");
                }
            }
        };
    } // namespace _Unchecked_end

    inline namespace _Cpos {
        inline constexpr _Unchecked_end::_Cpo _Uend;
    }

    _EXPORT_STD template &lt;class _Rng&gt;
    concept borrowed_range = range&lt;_Rng&gt; &amp;&amp; _Should_range_access&lt;_Rng&gt;;

    _EXPORT_STD template &lt;range _Rng&gt;
    using range_difference_t = iter_difference_t&lt;iterator_t&lt;_Rng&gt;&gt;;

    _EXPORT_STD template &lt;range _Rng&gt;
    using range_value_t = iter_value_t&lt;iterator_t&lt;_Rng&gt;&gt;;

    _EXPORT_STD template &lt;range _Rng&gt;
    using range_reference_t = iter_reference_t&lt;iterator_t&lt;_Rng&gt;&gt;;

    _EXPORT_STD template &lt;range _Rng&gt;
    using range_rvalue_reference_t = iter_rvalue_reference_t&lt;iterator_t&lt;_Rng&gt;&gt;;

#if _HAS_CXX23
    _EXPORT_STD template &lt;class _Rng&gt;
    concept constant_range = input_range&lt;_Rng&gt; &amp;&amp; _Constant_iterator&lt;iterator_t&lt;_Rng&gt;&gt;;

    template &lt;input_range _Rng&gt;
    _NODISCARD constexpr auto&amp; _Possibly_const_range(_Rng&amp; _Range) noexcept {
        if constexpr (constant_range&lt;const _Rng&gt; &amp;&amp; !constant_range&lt;_Rng&gt;) {
            return _STD as_const(_Range);
        } else {
            return _Range;
        }
    }

    template &lt;class _Ty&gt;
    _NODISCARD constexpr auto _As_const_pointer(const _Ty* _Ptr) noexcept {
        return _Ptr;
    }

    template &lt;class _Ty&gt;
    using _Begin_on_const = decltype(_RANGES begin(_RANGES _Possibly_const_range(_STD declval&lt;_Ty&amp;&gt;())));

    // TRANSITION, LLVM-55945
    template &lt;class _Ty&gt;
    concept _Range_accessible_and_begin_adaptable =
        _Should_range_access&lt;_Ty&gt;
        &amp;&amp; requires(
            _Ty&amp; _Val) { const_iterator&lt;_Begin_on_const&lt;_Ty&gt;&gt;{_RANGES begin(_RANGES _Possibly_const_range(_Val))}; };

    template &lt;class _Ty&gt;
    using _End_on_const = decltype(_RANGES end(_RANGES _Possibly_const_range(_STD declval&lt;_Ty&amp;&gt;())));

    // TRANSITION, LLVM-55945
    template &lt;class _Ty&gt;
    concept _Range_accessible_and_end_adaptable =
        _Should_range_access&lt;_Ty&gt;
        &amp;&amp; requires(
            _Ty&amp; _Val) { const_sentinel&lt;_End_on_const&lt;_Ty&gt;&gt;{_RANGES end(_RANGES _Possibly_const_range(_Val))}; };
#endif // _HAS_CXX23

    struct _Cbegin_fn {
#if _HAS_CXX23
        template &lt;_Range_accessible_and_begin_adaptable _Ty&gt;
        _NODISCARD constexpr auto operator()(_Ty&amp;&amp; _Val) const noexcept(
            noexcept(const_iterator&lt;_Begin_on_const&lt;_Ty&gt;&gt;{_RANGES begin(_RANGES _Possibly_const_range(_Val))})) {
            return const_iterator&lt;_Begin_on_const&lt;_Ty&gt;&gt;{_RANGES begin(_RANGES _Possibly_const_range(_Val))};
        }
#else // ^^^ C++23 / C++20 vvv
        template &lt;class _Ty, class _CTy = _Const_thru_ref&lt;_Ty&gt;&gt;
        _NODISCARD constexpr auto operator()(_Ty&amp;&amp; _Val) const
            noexcept(noexcept(_RANGES begin(static_cast&lt;_CTy&amp;&amp;&gt;(_Val))))
            requires requires { _RANGES begin(static_cast&lt;_CTy&amp;&amp;&gt;(_Val)); }
        {
            return _RANGES begin(static_cast&lt;_CTy&amp;&amp;&gt;(_Val));
        }
#endif // C++20
    };

    inline namespace _Cpos {
        _EXPORT_STD inline constexpr _Cbegin_fn cbegin;
    }

    struct _Cend_fn {
#if _HAS_CXX23
        template &lt;_Range_accessible_and_end_adaptable _Ty&gt;
        _NODISCARD constexpr auto operator()(_Ty&amp;&amp; _Val) const
            noexcept(noexcept(const_sentinel&lt;_End_on_const&lt;_Ty&gt;&gt;{_RANGES end(_RANGES _Possibly_const_range(_Val))})) {
            return const_sentinel&lt;_End_on_const&lt;_Ty&gt;&gt;{_RANGES end(_RANGES _Possibly_const_range(_Val))};
        }
#else // ^^^ C++23 / C++20 vvv
        template &lt;class _Ty, class _CTy = _Const_thru_ref&lt;_Ty&gt;&gt;
        _NODISCARD constexpr auto operator()(_Ty&amp;&amp; _Val) const
            noexcept(noexcept(_RANGES end(static_cast&lt;_CTy&amp;&amp;&gt;(_Val))))
            requires requires { _RANGES end(static_cast&lt;_CTy&amp;&amp;&gt;(_Val)); }
        {
            return _RANGES end(static_cast&lt;_CTy&amp;&amp;&gt;(_Val));
        }
#endif // C++20
    };

    inline namespace _Cpos {
        _EXPORT_STD inline constexpr _Cend_fn cend;
    }

    namespace _Rbegin {
#if defined(__clang__) || defined(__EDG__) // TRANSITION, VSO-1681199
        void rbegin() = delete; // Block unqualified name lookup
#else // ^^^ no workaround / workaround vvv
        void rbegin();
#endif // ^^^ workaround ^^^

        template &lt;class _Ty&gt;
        concept _Has_member = requires(_Ty __t) {
                                  { _Fake_copy_init(__t.rbegin()) } -&gt; input_or_output_iterator;
                              };

        template &lt;class _Ty&gt;
        concept _Has_ADL = _Has_class_or_enum_type&lt;_Ty&gt; //
                        &amp;&amp; requires(_Ty __t) {
                               { _Fake_copy_init(rbegin(__t)) } -&gt; input_or_output_iterator; // intentional ADL
                           };

        template &lt;class _Ty&gt;
        concept _Can_make_reverse = requires(_Ty __t) {
                                        { _RANGES begin(__t) } -&gt; bidirectional_iterator;
                                        { _RANGES end(__t) } -&gt; same_as&lt;decltype(_RANGES begin(__t))&gt;;
                                    };

        class _Cpo {
        private:
            enum class _St { _None, _Member, _Non_member, _Make_reverse };

            template &lt;class _Ty&gt;
            _NODISCARD static _CONSTEVAL _Choice_t&lt;_St&gt; _Choose() noexcept {
                _STL_INTERNAL_STATIC_ASSERT(is_lvalue_reference_v&lt;_Ty&gt;);
                if constexpr (_Has_member&lt;_Ty&gt;) {
                    return {_St::_Member, noexcept(_Fake_copy_init(_STD declval&lt;_Ty&gt;().rbegin()))};
                } else if constexpr (_Has_ADL&lt;_Ty&gt;) {
                    return {
                        _St::_Non_member, noexcept(_Fake_copy_init(rbegin(_STD declval&lt;_Ty&gt;())))}; // intentional ADL
                } else if constexpr (_Can_make_reverse&lt;_Ty&gt;) {
                    return {_St::_Make_reverse, noexcept(_STD make_reverse_iterator(_RANGES end(_STD declval&lt;_Ty&gt;())))};
                } else {
                    return {_St::_None};
                }
            }

            template &lt;class _Ty&gt;
            static constexpr _Choice_t&lt;_St&gt; _Choice = _Choose&lt;_Ty&gt;();

        public:
            template &lt;_Should_range_access _Ty&gt;
                requires (_Choice&lt;_Ty&amp;&gt;._Strategy != _St::_None)
            _NODISCARD constexpr auto operator()(_Ty&amp;&amp; _Val) const noexcept(_Choice&lt;_Ty&amp;&gt;._No_throw) {
                constexpr _St _Strat = _Choice&lt;_Ty&amp;&gt;._Strategy;

                if constexpr (_Strat == _St::_Member) {
                    return _Val.rbegin();
                } else if constexpr (_Strat == _St::_Non_member) {
                    return rbegin(_Val); // intentional ADL
                } else if constexpr (_Strat == _St::_Make_reverse) {
                    return _STD make_reverse_iterator(_RANGES end(_Val));
                } else {
                    static_assert(_Always_false&lt;_Ty&gt;, "should be unreachable");
                }
            }
        };
    } // namespace _Rbegin

    inline namespace _Cpos {
        _EXPORT_STD inline constexpr _Rbegin::_Cpo rbegin;
    }

    namespace _Rend {
#if defined(__clang__) || defined(__EDG__) // TRANSITION, VSO-1681199
        void rend() = delete; // Block unqualified name lookup
#else // ^^^ no workaround / workaround vvv
        void rend();
#endif // ^^^ workaround ^^^

        template &lt;class _Ty&gt;
        concept _Has_member = requires(_Ty __t) {
                                  { _Fake_copy_init(__t.rend()) } -&gt; sentinel_for&lt;decltype(_RANGES rbegin(__t))&gt;;
                              };

        template &lt;class _Ty&gt;
        concept _Has_ADL = _Has_class_or_enum_type&lt;_Ty&gt; //
                        &amp;&amp; requires(_Ty __t) {
                               // intentional ADL
                               { _Fake_copy_init(rend(__t)) } -&gt; sentinel_for&lt;decltype(_RANGES rbegin(__t))&gt;;
                           };

        template &lt;class _Ty&gt;
        concept _Can_make_reverse = requires(_Ty __t) {
                                        { _RANGES begin(__t) } -&gt; bidirectional_iterator;
                                        { _RANGES end(__t) } -&gt; same_as&lt;decltype(_RANGES begin(__t))&gt;;
                                    };

        class _Cpo {
        private:
            enum class _St { _None, _Member, _Non_member, _Make_reverse };

            template &lt;class _Ty&gt;
            _NODISCARD static _CONSTEVAL _Choice_t&lt;_St&gt; _Choose() noexcept {
                _STL_INTERNAL_STATIC_ASSERT(is_lvalue_reference_v&lt;_Ty&gt;);
                if constexpr (_Has_member&lt;_Ty&gt;) {
                    return {_St::_Member, noexcept(_Fake_copy_init(_STD declval&lt;_Ty&gt;().rend()))};
                } else if constexpr (_Has_ADL&lt;_Ty&gt;) {
                    return {_St::_Non_member, noexcept(_Fake_copy_init(rend(_STD declval&lt;_Ty&gt;())))}; // intentional ADL
                } else if constexpr (_Can_make_reverse&lt;_Ty&gt;) {
                    return {
                        _St::_Make_reverse, noexcept(_STD make_reverse_iterator(_RANGES begin(_STD declval&lt;_Ty&gt;())))};
                } else {
                    return {_St::_None};
                }
            }

            template &lt;class _Ty&gt;
            static constexpr _Choice_t&lt;_St&gt; _Choice = _Choose&lt;_Ty&gt;();

        public:
            template &lt;_Should_range_access _Ty&gt;
                requires (_Choice&lt;_Ty&amp;&gt;._Strategy != _St::_None)
            _NODISCARD constexpr auto operator()(_Ty&amp;&amp; _Val) const noexcept(_Choice&lt;_Ty&amp;&gt;._No_throw) {
                constexpr _St _Strat = _Choice&lt;_Ty&amp;&gt;._Strategy;

                if constexpr (_Strat == _St::_Member) {
                    return _Val.rend();
                } else if constexpr (_Strat == _St::_Non_member) {
                    return rend(_Val); // intentional ADL
                } else if constexpr (_Strat == _St::_Make_reverse) {
                    return _STD make_reverse_iterator(_RANGES begin(_Val));
                } else {
                    static_assert(_Always_false&lt;_Ty&gt;, "should be unreachable");
                }
            }
        };
    } // namespace _Rend

    inline namespace _Cpos {
        _EXPORT_STD inline constexpr _Rend::_Cpo rend;
    }

#if _HAS_CXX23
    template &lt;class _Ty&gt;
    using _Rbegin_on_const = decltype(_RANGES rbegin(_RANGES _Possibly_const_range(_STD declval&lt;_Ty&amp;&gt;())));

    // TRANSITION, LLVM-55945
    template &lt;class _Ty&gt;
    concept _Range_accessible_and_rbegin_adaptable =
        _Should_range_access&lt;_Ty&gt;
        &amp;&amp; requires(
            _Ty&amp; _Val) { const_iterator&lt;_Rbegin_on_const&lt;_Ty&gt;&gt;{_RANGES rbegin(_RANGES _Possibly_const_range(_Val))}; };

    template &lt;class _Ty&gt;
    using _Rend_on_const = decltype(_RANGES rend(_RANGES _Possibly_const_range(_STD declval&lt;_Ty&amp;&gt;())));

    // TRANSITION, LLVM-55945
    template &lt;class _Ty&gt;
    concept _Range_accessible_and_rend_adaptable =
        _Should_range_access&lt;_Ty&gt;
        &amp;&amp; requires(
            _Ty&amp; _Val) { const_sentinel&lt;_Rend_on_const&lt;_Ty&gt;&gt;{_RANGES rend(_RANGES _Possibly_const_range(_Val))}; };
#endif // _HAS_CXX23

    struct _Crbegin_fn {
#if _HAS_CXX23
        template &lt;_Range_accessible_and_rbegin_adaptable _Ty&gt;
        _NODISCARD constexpr auto operator()(_Ty&amp;&amp; _Val) const noexcept(
            noexcept(const_iterator&lt;_Rbegin_on_const&lt;_Ty&gt;&gt;{_RANGES rbegin(_RANGES _Possibly_const_range(_Val))})) {
            return const_iterator&lt;_Rbegin_on_const&lt;_Ty&gt;&gt;{_RANGES rbegin(_RANGES _Possibly_const_range(_Val))};
        }
#else // ^^^ C++23 / C++20 vvv
        template &lt;class _Ty, class _CTy = _Const_thru_ref&lt;_Ty&gt;&gt;
        _NODISCARD constexpr auto operator()(_Ty&amp;&amp; _Val) const
            noexcept(noexcept(_RANGES rbegin(static_cast&lt;_CTy&amp;&amp;&gt;(_Val))))
            requires requires { _RANGES rbegin(static_cast&lt;_CTy&amp;&amp;&gt;(_Val)); }
        {
            return _RANGES rbegin(static_cast&lt;_CTy&amp;&amp;&gt;(_Val));
        }
#endif // C++20
    };

    inline namespace _Cpos {
        _EXPORT_STD inline constexpr _Crbegin_fn crbegin;
    }

    struct _Crend_fn {
#if _HAS_CXX23
        template &lt;_Range_accessible_and_rend_adaptable _Ty&gt;
        _NODISCARD constexpr auto operator()(_Ty&amp;&amp; _Val) const
            noexcept(noexcept(const_sentinel&lt;_Rend_on_const&lt;_Ty&gt;&gt;{_RANGES rend(_RANGES _Possibly_const_range(_Val))})) {
            return const_sentinel&lt;_Rend_on_const&lt;_Ty&gt;&gt;{_RANGES rend(_RANGES _Possibly_const_range(_Val))};
        }
#else // ^^^ C++23 / C++20 vvv
        template &lt;class _Ty, class _CTy = _Const_thru_ref&lt;_Ty&gt;&gt;
        _NODISCARD constexpr auto operator()(_Ty&amp;&amp; _Val) const
            noexcept(noexcept(_RANGES rend(static_cast&lt;_CTy&amp;&amp;&gt;(_Val))))
            requires requires { _RANGES rend(static_cast&lt;_CTy&amp;&amp;&gt;(_Val)); }
        {
            return _RANGES rend(static_cast&lt;_CTy&amp;&amp;&gt;(_Val));
        }
#endif // C++20
    };

    inline namespace _Cpos {
        _EXPORT_STD inline constexpr _Crend_fn crend;
    }

    _EXPORT_STD template &lt;class&gt;
    inline constexpr bool disable_sized_range = false;

    namespace _Size {
#if defined(__clang__) || defined(__EDG__) // TRANSITION, VSO-1681199
        void size() = delete; // Block unqualified name lookup
#else // ^^^ no workaround / workaround vvv
        void size();
#endif // ^^^ workaround ^^^

        template &lt;class _Ty, class _UnCV&gt;
        concept _Has_member = (!disable_sized_range&lt;_UnCV&gt;) //
                           &amp;&amp; requires(_Ty __t) {
                                  { _Fake_copy_init(__t.size()) } -&gt; _Integer_like;
                              };

        template &lt;class _Ty, class _UnCV&gt;
        concept _Has_ADL = _Has_class_or_enum_type&lt;_Ty&gt; &amp;&amp; (!disable_sized_range&lt;_UnCV&gt;) //
                        &amp;&amp; requires(_Ty __t) {
                               { _Fake_copy_init(size(__t)) } -&gt; _Integer_like; // intentional ADL
                           };

        template &lt;class _Ty&gt;
        concept _Can_difference = requires(_Ty __t) {
                                      { _RANGES begin(__t) } -&gt; forward_iterator;
                                      { _RANGES end(__t) } -&gt; sized_sentinel_for&lt;decltype(_RANGES begin(__t))&gt;;
                                  };

        class _Cpo {
        private:
            enum class _St { _None, _Array, _Member, _Non_member, _Subtract };

            template &lt;class _Ty&gt;
            _NODISCARD static _CONSTEVAL _Choice_t&lt;_St&gt; _Choose() noexcept {
                _STL_INTERNAL_STATIC_ASSERT(is_lvalue_reference_v&lt;_Ty&gt;);
                using _UnCV = remove_cvref_t&lt;_Ty&gt;;

                if constexpr (is_array_v&lt;_UnCV&gt;) {
                    if constexpr (extent_v&lt;_UnCV&gt; != 0) {
                        return {_St::_Array, true};
                    } else {
                        return {_St::_None};
                    }
                } else if constexpr (_Has_member&lt;_Ty, _UnCV&gt;) {
                    return {_St::_Member, noexcept(_Fake_copy_init(_STD declval&lt;_Ty&gt;().size()))};
                } else if constexpr (_Has_ADL&lt;_Ty, _UnCV&gt;) {
                    return {_St::_Non_member, noexcept(_Fake_copy_init(size(_STD declval&lt;_Ty&gt;())))}; // intentional ADL
                } else if constexpr (_Can_difference&lt;_Ty&gt;) {
                    return {_St::_Subtract,
                        noexcept(_RANGES end(_STD declval&lt;_Ty&gt;()) - _RANGES begin(_STD declval&lt;_Ty&gt;()))};
                } else {
                    return {_St::_None};
                }
            }

            template &lt;class _Ty&gt;
            static constexpr _Choice_t&lt;_St&gt; _Choice = _Choose&lt;_Ty&gt;();

        public:
            template &lt;class _Ty&gt;
                requires (_Choice&lt;_Ty&amp;&gt;._Strategy != _St::_None)
            _NODISCARD constexpr auto operator()(_Ty&amp;&amp; _Val) const noexcept(_Choice&lt;_Ty&amp;&gt;._No_throw) {
                constexpr _St _Strat = _Choice&lt;_Ty&amp;&gt;._Strategy;

                if constexpr (_Strat == _St::_Array) {
                    // extent_v&lt;remove_cvref_t&lt;_Ty&amp;&gt;&gt; reuses specializations from _Choose
                    return extent_v&lt;remove_cvref_t&lt;_Ty&amp;&gt;&gt;;
                } else if constexpr (_Strat == _St::_Member) {
                    return _Val.size();
                } else if constexpr (_Strat == _St::_Non_member) {
                    return size(_Val); // intentional ADL
                } else if constexpr (_Strat == _St::_Subtract) {
                    const auto _Delta = _RANGES end(_Val) - _RANGES begin(_Val);
                    return static_cast&lt;_Make_unsigned_like_t&lt;remove_cv_t&lt;decltype(_Delta)&gt;&gt;&gt;(_Delta);
                } else {
                    static_assert(_Always_false&lt;_Ty&gt;, "should be unreachable");
                }
            }
        };
    } // namespace _Size

    inline namespace _Cpos {
        _EXPORT_STD inline constexpr _Size::_Cpo size;
    }

    namespace _Empty {
        template &lt;class _Ty&gt;
        concept _Has_member = requires(_Ty __t) { static_cast&lt;bool&gt;(__t.empty()); };

        template &lt;class _Ty&gt;
        concept _Has_size = requires(_Ty __t) { _RANGES size(__t); };

        template &lt;class _Ty&gt;
        concept _Can_begin_end = requires(_Ty __t) {
                                     { _RANGES begin(__t) } -&gt; forward_iterator;
                                     _RANGES end(__t);
                                 };

        class _Cpo {
        private:
            enum class _St { _None, _Member, _Size, _Compare };

            template &lt;class _Ty&gt;
            _NODISCARD static _CONSTEVAL _Choice_t&lt;_St&gt; _Choose() noexcept {
                _STL_INTERNAL_STATIC_ASSERT(is_lvalue_reference_v&lt;_Ty&gt;);
                if constexpr (is_unbounded_array_v&lt;remove_reference_t&lt;_Ty&gt;&gt;) {
                    return {_St::_None};
                } else if constexpr (_Has_member&lt;_Ty&gt;) {
                    return {_St::_Member, noexcept(static_cast&lt;bool&gt;(_STD declval&lt;_Ty&gt;().empty()))};
                } else if constexpr (_Has_size&lt;_Ty&gt;) {
                    return {_St::_Size, noexcept(_RANGES size(_STD declval&lt;_Ty&gt;()))};
                } else if constexpr (_Can_begin_end&lt;_Ty&gt;) {
                    constexpr auto _Nothrow = noexcept(
                        static_cast&lt;bool&gt;(_RANGES begin(_STD declval&lt;_Ty&gt;()) == _RANGES end(_STD declval&lt;_Ty&gt;())));
                    return {_St::_Compare, _Nothrow};
                } else {
                    return {_St::_None};
                }
            }

            template &lt;class _Ty&gt;
            static constexpr _Choice_t&lt;_St&gt; _Choice = _Choose&lt;_Ty&gt;();

        public:
            // clang-format off
            template &lt;class _Ty&gt;
                requires (_Choice&lt;_Ty&amp;&gt;._Strategy != _St::_None)
            _NODISCARD constexpr bool operator()(_Ty&amp;&amp; _Val) const noexcept(_Choice&lt;_Ty&amp;&gt;._No_throw) {
                constexpr _St _Strat = _Choice&lt;_Ty&amp;&gt;._Strategy;

                if constexpr (_Strat == _St::_Member) {
                    return static_cast&lt;bool&gt;(_Val.empty());
                } else if constexpr (_Strat == _St::_Size) {
                    return _RANGES size(_Val) == 0;
                } else if constexpr (_Strat == _St::_Compare) {
                    return static_cast&lt;bool&gt;(_RANGES begin(_Val) == _RANGES end(_Val));
                } else {
                    static_assert(_Always_false&lt;_Ty&gt;, "should be unreachable");
                }
            }
            // clang-format on
        };
    } // namespace _Empty

    inline namespace _Cpos {
        _EXPORT_STD inline constexpr _Empty::_Cpo empty;
    }

    namespace _Data {
        template &lt;class _Ty&gt;
        concept _Points_to_object = is_pointer_v&lt;_Ty&gt; &amp;&amp; is_object_v&lt;remove_pointer_t&lt;_Ty&gt;&gt;;

        template &lt;class _Ty&gt;
        concept _Has_member = requires(_Ty __t) {
                                  { _Fake_copy_init(__t.data()) } -&gt; _Points_to_object;
                              };

        template &lt;class _Ty&gt;
        concept _Has_contiguous_iterator = requires(_Ty __t) {
                                               { _RANGES begin(__t) } -&gt; contiguous_iterator;
                                           };

        class _Cpo {
        private:
            enum class _St { _None, _Member, _Address };

            template &lt;class _Ty&gt;
            _NODISCARD static _CONSTEVAL _Choice_t&lt;_St&gt; _Choose() noexcept {
                _STL_INTERNAL_STATIC_ASSERT(is_lvalue_reference_v&lt;_Ty&gt;);
                if constexpr (_Has_member&lt;_Ty&gt;) {
                    return {_St::_Member, noexcept(_STD declval&lt;_Ty&gt;().data())};
                } else if constexpr (_Has_contiguous_iterator&lt;_Ty&gt;) {
                    return {_St::_Address, noexcept(_STD to_address(_RANGES begin(_STD declval&lt;_Ty&gt;())))};
                } else {
                    return {_St::_None};
                }
            }

            template &lt;class _Ty&gt;
            static constexpr _Choice_t&lt;_St&gt; _Choice = _Choose&lt;_Ty&gt;();

        public:
            template &lt;_Should_range_access _Ty&gt;
                requires (_Choice&lt;_Ty&amp;&gt;._Strategy != _St::_None)
            _NODISCARD constexpr auto operator()(_Ty&amp;&amp; _Val) const noexcept(_Choice&lt;_Ty&amp;&gt;._No_throw) {
                constexpr _St _Strat = _Choice&lt;_Ty&amp;&gt;._Strategy;

                if constexpr (_Strat == _St::_Member) {
                    return _Val.data();
                } else if constexpr (_Strat == _St::_Address) {
                    return _STD to_address(_RANGES begin(_Val));
                } else {
                    static_assert(_Always_false&lt;_Ty&gt;, "should be unreachable");
                }
            }
        };
    } // namespace _Data

    inline namespace _Cpos {
        _EXPORT_STD inline constexpr _Data::_Cpo data;
    }

#if _HAS_CXX23
    // TRANSITION, LLVM-55945
    template &lt;class _Ty&gt;
    concept _Range_accessible_and_data_adaptable =
        _Should_range_access&lt;_Ty&gt;
        &amp;&amp; requires(_Ty&amp; _Val) { _RANGES _As_const_pointer(_RANGES data(_RANGES _Possibly_const_range(_Val))); };
#endif // _HAS_CXX23

    struct _Cdata_fn {
#if _HAS_CXX23
        template &lt;_Range_accessible_and_data_adaptable _Ty&gt;
        _NODISCARD constexpr auto operator()(_Ty&amp;&amp; _Val) const
            noexcept(noexcept(_RANGES data(_RANGES _Possibly_const_range(_Val)))) {
            return _RANGES _As_const_pointer(_RANGES data(_RANGES _Possibly_const_range(_Val)));
        }
#else // ^^^ C++23 / C++20 vvv
        template &lt;class _Ty, class _CTy = _Const_thru_ref&lt;_Ty&gt;&gt;
        _NODISCARD constexpr auto operator()(_Ty&amp;&amp; _Val) const
            noexcept(noexcept(_RANGES data(static_cast&lt;_CTy&amp;&amp;&gt;(_Val))))
            requires requires { _RANGES data(static_cast&lt;_CTy&amp;&amp;&gt;(_Val)); }
        {
            return _RANGES data(static_cast&lt;_CTy&amp;&amp;&gt;(_Val));
        }
#endif // C++20
    };

    inline namespace _Cpos {
        _EXPORT_STD inline constexpr _Cdata_fn cdata;
    }

    _EXPORT_STD template &lt;class _Rng&gt;
    concept sized_range = range&lt;_Rng&gt; &amp;&amp; requires(_Rng &amp; __r) { _RANGES size(__r); };

    _EXPORT_STD template &lt;sized_range _Rng&gt;
    using range_size_t = decltype(_RANGES size(_STD declval&lt;_Rng&amp;&gt;()));

    _EXPORT_STD struct view_base {};

    template &lt;class _Ty, template &lt;class...&gt; class _Template&gt;
    concept _Strictly_derived_from_specialization_of =
        is_object_v&lt;_Ty&gt; &amp;&amp; _Derived_from_specialization_of&lt;_Ty, _Template&gt;;

    _EXPORT_STD template &lt;class _Derived&gt;
        requires is_class_v&lt;_Derived&gt; &amp;&amp; same_as&lt;_Derived, remove_cv_t&lt;_Derived&gt;&gt;
    class view_interface;

    _EXPORT_STD template &lt;class _Ty&gt;
    inline constexpr bool enable_view =
        derived_from&lt;_Ty, view_base&gt; || _Strictly_derived_from_specialization_of&lt;_Ty, view_interface&gt;;

    _EXPORT_STD template &lt;class _Ty&gt;
    concept view = range&lt;_Ty&gt; &amp;&amp; movable&lt;_Ty&gt; &amp;&amp; enable_view&lt;_Ty&gt;;

    _EXPORT_STD template &lt;class _Rng, class _Ty&gt;
    concept output_range = range&lt;_Rng&gt; &amp;&amp; output_iterator&lt;iterator_t&lt;_Rng&gt;, _Ty&gt;;

    _EXPORT_STD template &lt;class _Rng&gt;
    concept forward_range = range&lt;_Rng&gt; &amp;&amp; forward_iterator&lt;iterator_t&lt;_Rng&gt;&gt;;

    _EXPORT_STD template &lt;class _Rng&gt;
    concept bidirectional_range = range&lt;_Rng&gt; &amp;&amp; bidirectional_iterator&lt;iterator_t&lt;_Rng&gt;&gt;;

    _EXPORT_STD template &lt;class _Rng&gt;
    concept random_access_range = range&lt;_Rng&gt; &amp;&amp; random_access_iterator&lt;iterator_t&lt;_Rng&gt;&gt;;

    _EXPORT_STD template &lt;class _Rng&gt;
    concept contiguous_range = range&lt;_Rng&gt; &amp;&amp; contiguous_iterator&lt;iterator_t&lt;_Rng&gt;&gt;
                            &amp;&amp; requires(_Rng &amp; __r) {
                                   { _RANGES data(__r) } -&gt; same_as&lt;add_pointer_t&lt;range_reference_t&lt;_Rng&gt;&gt;&gt;;
                               };

    class _Not_quite_object {
    public:
        // Some overload sets in the library have the property that their constituent function templates are not visible
        // to argument-dependent name lookup (ADL) and that they inhibit ADL when found via unqualified name lookup.
        // This property allows these overload sets to be implemented as function objects. We derive such function
        // objects from this type to remove some typical object-ish behaviors which helps users avoid depending on their
        // non-specified object-ness.

        struct _Construct_tag {
            explicit _Construct_tag() = default;
        };

        _Not_quite_object() = delete;

        constexpr explicit _Not_quite_object(_Construct_tag) noexcept {}

        _Not_quite_object(const _Not_quite_object&amp;)            = delete;
        _Not_quite_object&amp; operator=(const _Not_quite_object&amp;) = delete;

        void operator&amp;() const = delete;

    protected:
        ~_Not_quite_object() = default;
    };

    class _Advance_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template &lt;input_or_output_iterator _It&gt;
        constexpr void operator()(_It&amp; _Where, iter_difference_t&lt;_It&gt; _Off) const {
            if constexpr (random_access_iterator&lt;_It&gt;) {
                _Where += _Off;
            } else {
                if constexpr (!bidirectional_iterator&lt;_It&gt;) {
                    _STL_ASSERT(_Off &gt;= 0, "negative advance of non-bidirectional iterator");
                }

                decltype(auto) _UWhere      = _Get_unwrapped_n(_STD move(_Where), _Off);
                constexpr bool _Need_rewrap = !is_reference_v&lt;decltype(_Get_unwrapped_n(_STD move(_Where), _Off))&gt;;

                if constexpr (bidirectional_iterator&lt;_It&gt;) {
                    for (; _Off &lt; 0; ++_Off) {
                        --_UWhere;
                    }
                }

                for (; _Off &gt; 0; --_Off) {
                    ++_UWhere;
                }

                if constexpr (_Need_rewrap) {
                    _Seek_wrapped(_Where, _STD move(_UWhere));
                }
            }
        }

        template &lt;input_or_output_iterator _It, sentinel_for&lt;_It&gt; _Se&gt;
        constexpr void operator()(_It&amp; _Where, _Se _Last) const {
            if constexpr (assignable_from&lt;_It&amp;, _Se&gt;) {
                _Where = static_cast&lt;_Se&amp;&amp;&gt;(_Last);
            } else if constexpr (sized_sentinel_for&lt;_Se, _It&gt;) {
                (*this)(_Where, _Last - _Where);
            } else {
                _Adl_verify_range(_Where, _Last);

                decltype(auto) _UWhere      = _Unwrap_iter&lt;_Se&gt;(static_cast&lt;_It&amp;&amp;&gt;(_Where));
                constexpr bool _Need_rewrap = !is_reference_v&lt;decltype(_Unwrap_iter&lt;_Se&gt;(static_cast&lt;_It&amp;&amp;&gt;(_Where)))&gt;;
                decltype(auto) _ULast       = _Unwrap_sent&lt;_It&gt;(static_cast&lt;_Se&amp;&amp;&gt;(_Last));

                while (_UWhere != _ULast) {
                    ++_UWhere;
                }

                if constexpr (_Need_rewrap) {
                    _Seek_wrapped(_Where, _STD move(_UWhere));
                }
            }
        }

        template &lt;input_or_output_iterator _It, sentinel_for&lt;_It&gt; _Se&gt;
        constexpr iter_difference_t&lt;_It&gt; operator()(_It&amp; _Where, iter_difference_t&lt;_It&gt; _Off, _Se _Last) const {
            if constexpr (sized_sentinel_for&lt;_Se, _It&gt;) {
                const iter_difference_t&lt;_It&gt; _Delta = _Last - _Where;
                if ((_Off &lt; 0 &amp;&amp; _Off &lt;= _Delta) || (_Off &gt; 0 &amp;&amp; _Off &gt;= _Delta)) {
                    if constexpr (assignable_from&lt;_It&amp;, _Se&gt;) {
                        _Where = static_cast&lt;_Se&amp;&amp;&gt;(_Last);
                    } else {
                        (*this)(_Where, _Delta);
                    }
                    return _Off - _Delta;
                }

                (*this)(_Where, _Off);
                return 0;
            } else {
                // performance note: develop unwrapping technology for (i, n, s)?
                if constexpr (bidirectional_iterator&lt;_It&gt;) {
                    for (; _Off &lt; 0 &amp;&amp; _Where != _Last; ++_Off) {
                        --_Where;
                    }
                } else {
                    _STL_ASSERT(_Off &gt;= 0, "negative advance of non-bidirectional iterator");
                }

                for (; _Off &gt; 0 &amp;&amp; _Where != _Last; --_Off) {
                    ++_Where;
                }

                return _Off;
            }
        }
    };

    _EXPORT_STD inline constexpr _Advance_fn advance{_Not_quite_object::_Construct_tag{}};

    class _Distance_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template &lt;class _It, sentinel_for&lt;_It&gt; _Se&gt;
            requires (!sized_sentinel_for&lt;_Se, _It&gt;)
        _NODISCARD constexpr iter_difference_t&lt;_It&gt; operator()(_It _First, _Se _Last) const
            noexcept(noexcept(_Distance_unchecked(
                _Get_unwrapped(_STD move(_First)), _Get_unwrapped(_STD move(_Last))))) /* strengthened */ {
            _Adl_verify_range(_First, _Last);
            return _Distance_unchecked(_Unwrap_iter&lt;_Se&gt;(_STD move(_First)), _Unwrap_sent&lt;_It&gt;(_STD move(_Last)));
        }

        template &lt;class _It, sized_sentinel_for&lt;decay_t&lt;_It&gt;&gt; _Se&gt;
        _NODISCARD constexpr iter_difference_t&lt;decay_t&lt;_It&gt;&gt; operator()(_It&amp;&amp; _First, const _Se _Last) const
            noexcept(noexcept(_Last - static_cast&lt;const decay_t&lt;_It&gt;&amp;&gt;(_First))) /* strengthened */ {
            return _Last - static_cast&lt;const decay_t&lt;_It&gt;&amp;&gt;(_First);
        }

        template &lt;range _Rng&gt;
        _NODISCARD constexpr range_difference_t&lt;_Rng&gt; operator()(_Rng&amp;&amp; _Range) const
            noexcept(_Nothrow_size&lt;_Rng&gt;) /* strengthened */ {
            if constexpr (sized_range&lt;_Rng&gt;) {
                return static_cast&lt;range_difference_t&lt;_Rng&gt;&gt;(_RANGES size(_Range));
            } else {
                return _Distance_unchecked(_Ubegin(_Range), _Uend(_Range));
            }
        }

    private:
        template &lt;class _It, class _Se&gt;
        _NODISCARD static constexpr iter_difference_t&lt;_It&gt; _Distance_unchecked(_It _First, const _Se _Last) noexcept(
            noexcept(++_First != _Last)) {
            _STL_INTERNAL_STATIC_ASSERT(sentinel_for&lt;_Se, _It&gt;);

            iter_difference_t&lt;_It&gt; _Count = 0;
            for (; _First != _Last; ++_First) {
                ++_Count;
            }

            return _Count;
        }

        template &lt;class _Rng&gt;
        static constexpr bool _Nothrow_size =
            noexcept(_Distance_unchecked(_Ubegin(_STD declval&lt;_Rng&amp;&gt;()), _Uend(_STD declval&lt;_Rng&amp;&gt;())));

        template &lt;sized_range _Rng&gt;
        static constexpr bool _Nothrow_size&lt;_Rng&gt; = noexcept(_RANGES size(_STD declval&lt;_Rng&amp;&gt;()));
    };

    _EXPORT_STD inline constexpr _Distance_fn distance{_Not_quite_object::_Construct_tag{}};

    class _Ssize_fn {
    public:
        // clang-format off
        template &lt;class _Rng&gt;
        _NODISCARD constexpr auto operator()(_Rng&amp;&amp; _Range) const requires requires { _RANGES size(_Range); } {
            using _Sty = _Make_signed_like_t&lt;decltype(_RANGES size(_Range))&gt;;
            using _Ty  = common_type_t&lt;conditional_t&lt;is_integral_v&lt;_Sty&gt;, ptrdiff_t, _Sty&gt;, _Sty&gt;;
            return static_cast&lt;_Ty&gt;(_RANGES size(_Range));
        }
        // clang-format on
    };

    inline namespace _Cpos {
        _EXPORT_STD inline constexpr _Ssize_fn ssize;
    }

    class _Next_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template &lt;input_or_output_iterator _It&gt;
        _NODISCARD constexpr _It operator()(_It _Where) const {
            ++_Where;
            return _Where;
        }

        template &lt;input_or_output_iterator _It&gt;
        _NODISCARD constexpr _It operator()(_It _Where, const iter_difference_t&lt;_It&gt; _Off) const {
            _RANGES advance(_Where, _Off);
            return _Where;
        }

        template &lt;input_or_output_iterator _It, sentinel_for&lt;_It&gt; _Se&gt;
        _NODISCARD constexpr _It operator()(_It _Where, _Se _Last) const {
            _RANGES advance(_Where, static_cast&lt;_Se&amp;&amp;&gt;(_Last));
            return _Where;
        }

        template &lt;input_or_output_iterator _It, sentinel_for&lt;_It&gt; _Se&gt;
        _NODISCARD constexpr _It operator()(_It _Where, const iter_difference_t&lt;_It&gt; _Off, _Se _Last) const {
            _RANGES advance(_Where, _Off, static_cast&lt;_Se&amp;&amp;&gt;(_Last));
            return _Where;
        }
    };

    _EXPORT_STD inline constexpr _Next_fn next{_Not_quite_object::_Construct_tag{}};

    class _Prev_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template &lt;bidirectional_iterator _It&gt;
        _NODISCARD constexpr _It operator()(_It _Where) const {
            --_Where;
            return _Where;
        }

        template &lt;bidirectional_iterator _It&gt;
        _NODISCARD constexpr _It operator()(_It _Where, const iter_difference_t&lt;_It&gt; _Off) const {
            _STL_ASSERT(_Off != _Min_possible_v&lt;iter_difference_t&lt;_It&gt;&gt;, "integer overflow");
            _RANGES advance(_Where, -_Off);
            return _Where;
        }

        template &lt;bidirectional_iterator _It&gt;
        _NODISCARD constexpr _It operator()(_It _Where, const iter_difference_t&lt;_It&gt; _Off, _It _Last) const {
            _STL_ASSERT(_Off != _Min_possible_v&lt;iter_difference_t&lt;_It&gt;&gt;, "integer overflow");
            _RANGES advance(_Where, -_Off, static_cast&lt;_It&amp;&amp;&gt;(_Last));
            return _Where;
        }
    };

    _EXPORT_STD inline constexpr _Prev_fn prev{_Not_quite_object::_Construct_tag{}};

    template &lt;forward_iterator _It, sentinel_for&lt;_It&gt; _Se&gt;
    _NODISCARD constexpr _It _Find_last_iterator(
        const _It&amp; _First, const _Se&amp; _Last, const iter_difference_t&lt;_It&gt; _Count) {
        // Find the iterator in [_First, _Last) (of length _Count) which equals _Last
        _STL_INTERNAL_CHECK(_RANGES distance(_First, _Last) == _Count);
        if constexpr (is_same_v&lt;_It, _Se&gt;) {
            return _Last;
        } else {
            return _RANGES next(_First, _Count);
        }
    }

    _EXPORT_STD struct equal_to {
        // clang-format off
        template &lt;class _Ty1, class _Ty2&gt;
            requires equality_comparable_with&lt;_Ty1, _Ty2&gt;
        _NODISCARD constexpr bool operator()(_Ty1&amp;&amp; _Left, _Ty2&amp;&amp; _Right) const noexcept(noexcept(
            static_cast&lt;bool&gt;(static_cast&lt;_Ty1&amp;&amp;&gt;(_Left) == static_cast&lt;_Ty2&amp;&amp;&gt;(_Right)))) /* strengthened */ {
            return static_cast&lt;bool&gt;(static_cast&lt;_Ty1&amp;&amp;&gt;(_Left) == static_cast&lt;_Ty2&amp;&amp;&gt;(_Right));
        }
        // clang-format on

        using is_transparent = int;
    };

    _EXPORT_STD struct less {
        // clang-format off
        template &lt;class _Ty1, class _Ty2&gt;
            requires totally_ordered_with&lt;_Ty1, _Ty2&gt;
        _NODISCARD constexpr bool operator()(_Ty1&amp;&amp; _Left, _Ty2&amp;&amp; _Right) const noexcept(noexcept(
            static_cast&lt;bool&gt;(static_cast&lt;_Ty1&amp;&amp;&gt;(_Left) &lt; static_cast&lt;_Ty2&amp;&amp;&gt;(_Right)))) /* strengthened */ {
            return static_cast&lt;bool&gt;(static_cast&lt;_Ty1&amp;&amp;&gt;(_Left) &lt; static_cast&lt;_Ty2&amp;&amp;&gt;(_Right));
        }
        // clang-format on

        using is_transparent = int;
    };

    _EXPORT_STD struct greater {
        // clang-format off
        template &lt;class _Ty1, class _Ty2&gt;
            requires totally_ordered_with&lt;_Ty1, _Ty2&gt;
        _NODISCARD constexpr bool operator()(_Ty1&amp;&amp; _Left, _Ty2&amp;&amp; _Right) const noexcept(noexcept(
            static_cast&lt;bool&gt;(static_cast&lt;_Ty2&amp;&amp;&gt;(_Right) &lt; static_cast&lt;_Ty1&amp;&amp;&gt;(_Left)))) /* strengthened */ {
            return static_cast&lt;bool&gt;(static_cast&lt;_Ty2&amp;&amp;&gt;(_Right) &lt; static_cast&lt;_Ty1&amp;&amp;&gt;(_Left));
        }
        // clang-format on

        using is_transparent = int;
    };

    _EXPORT_STD template &lt;class _Rng&gt;
    concept common_range = range&lt;_Rng&gt; &amp;&amp; same_as&lt;iterator_t&lt;_Rng&gt;, sentinel_t&lt;_Rng&gt;&gt;;

    template &lt;class _It, class _Se&gt;
    concept _Bidi_common = is_same_v&lt;_It, _Se&gt; &amp;&amp; bidirectional_iterator&lt;_It&gt;;
    template &lt;class _Rng&gt;
    concept _Bidi_common_range = common_range&lt;_Rng&gt; &amp;&amp; bidirectional_iterator&lt;iterator_t&lt;_Rng&gt;&gt;;

    template &lt;class _Ty&gt;
    concept _Can_empty = requires(_Ty __t) { _RANGES empty(__t); };

    _EXPORT_STD template &lt;class _Derived&gt;
        requires is_class_v&lt;_Derived&gt; &amp;&amp; same_as&lt;_Derived, remove_cv_t&lt;_Derived&gt;&gt;
    class view_interface {
    private:
        _NODISCARD constexpr _Derived&amp; _Cast() noexcept {
            static_assert(derived_from&lt;_Derived, view_interface&gt;,
                "view_interface's template argument D must derive from view_interface&lt;D&gt; (N4849 [view.interface]/2).");
            static_assert(view&lt;_Derived&gt;,
                "view_interface's template argument must model the view concept (N4849 [view.interface]/2).");
            return static_cast&lt;_Derived&amp;&gt;(*this);
        }

        _NODISCARD constexpr const _Derived&amp; _Cast() const noexcept {
            static_assert(derived_from&lt;_Derived, view_interface&gt;,
                "view_interface's template argument D must derive from view_interface&lt;D&gt; (N4849 [view.interface]/2).");
            static_assert(view&lt;_Derived&gt;,
                "view_interface's template argument must model the view concept (N4849 [view.interface]/2).");
            return static_cast&lt;const _Derived&amp;&gt;(*this);
        }

    public:
#ifdef __clang__ // TRANSITION, LLVM-44833
        template &lt;class _Dx = _Derived&gt;
        _NODISCARD constexpr bool empty()
            requires sized_range&lt;_Dx&gt; || forward_range&lt;_Dx&gt;
#else // ^^^ workaround / no workaround vvv
        _NODISCARD constexpr bool empty()
            requires sized_range&lt;_Derived&gt; || forward_range&lt;_Derived&gt;
#endif // TRANSITION, LLVM-44833
        {
            auto&amp; _Self = _Cast();
            if constexpr (sized_range&lt;_Derived&gt;) {
                return _RANGES size(_Self) == 0;
            } else {
                return _RANGES begin(_Self) == _RANGES end(_Self);
            }
        }

#ifdef __clang__ // TRANSITION, LLVM-44833
        template &lt;class _Dx = _Derived&gt;
        _NODISCARD constexpr bool empty() const
            requires sized_range&lt;const _Dx&gt; || forward_range&lt;const _Dx&gt;
#else // ^^^ workaround / no workaround vvv
        _NODISCARD constexpr bool empty() const
            requires sized_range&lt;const _Derived&gt; || forward_range&lt;const _Derived&gt;
#endif // TRANSITION, LLVM-44833
        {
            auto&amp; _Self = _Cast();
            if constexpr (sized_range&lt;const _Derived&gt;) {
                return _RANGES size(_Self) == 0;
            } else {
                return _RANGES begin(_Self) == _RANGES end(_Self);
            }
        }

#if _HAS_CXX23
#ifdef __clang__ // TRANSITION, LLVM-44833
        template &lt;class _Dx = _Derived&gt;
        _NODISCARD constexpr auto cbegin()
            requires input_range&lt;_Dx&gt;
#else // ^^^ workaround / no workaround vvv
        _NODISCARD constexpr auto cbegin()
            requires input_range&lt;_Derived&gt;
#endif // TRANSITION, LLVM-44833
        {
            return _RANGES cbegin(_Cast());
        }

#ifdef __clang__ // TRANSITION, LLVM-44833
        template &lt;class _Dx = _Derived&gt;
        _NODISCARD constexpr auto cbegin() const
            requires input_range&lt;const _Dx&gt;
#else // ^^^ workaround / no workaround vvv
        _NODISCARD constexpr auto cbegin() const
            requires input_range&lt;const _Derived&gt;
#endif // TRANSITION, LLVM-44833
        {
            return _RANGES cbegin(_Cast());
        }

#ifdef __clang__ // TRANSITION, LLVM-44833
        template &lt;class _Dx = _Derived&gt;
        _NODISCARD constexpr auto cend()
            requires input_range&lt;_Dx&gt;
#else // ^^^ workaround / no workaround vvv
        _NODISCARD constexpr auto cend()
            requires input_range&lt;_Derived&gt;
#endif // TRANSITION, LLVM-44833
        {
            return _RANGES cend(_Cast());
        }

#ifdef __clang__ // TRANSITION, LLVM-44833
        template &lt;class _Dx = _Derived&gt;
        _NODISCARD constexpr auto cend() const
            requires input_range&lt;const _Dx&gt;
#else // ^^^ workaround / no workaround vvv
        _NODISCARD constexpr auto cend() const
            requires input_range&lt;const _Derived&gt;
#endif // TRANSITION, LLVM-44833
        {
            return _RANGES cend(_Cast());
        }
#endif // _HAS_CXX23

#ifdef __clang__ // TRANSITION, LLVM-44833
        template &lt;class _Dx = _Derived&gt;
        constexpr explicit operator bool()
            requires _Can_empty&lt;_Dx&gt;
#else // ^^^ workaround / no workaround vvv
        constexpr explicit operator bool()
            requires _Can_empty&lt;_Derived&gt;
#endif // TRANSITION, LLVM-44833
        {
            return !_RANGES empty(_Cast());
        }

#ifdef __clang__ // TRANSITION, LLVM-44833
        template &lt;class _Dx = _Derived&gt;
        constexpr explicit operator bool() const
            requires _Can_empty&lt;const _Dx&gt;
#else // ^^^ workaround / no workaround vvv
        constexpr explicit operator bool() const
            requires _Can_empty&lt;const _Derived&gt;
#endif // TRANSITION, LLVM-44833
        {
            return !_RANGES empty(_Cast());
        }

#ifdef __clang__ // TRANSITION, LLVM-44833
        template &lt;class _Dx = _Derived&gt;
        _NODISCARD constexpr auto data()
            requires contiguous_iterator&lt;iterator_t&lt;_Dx&gt;&gt;
#else // ^^^ workaround / no workaround vvv
        _NODISCARD constexpr auto data()
            requires contiguous_iterator&lt;iterator_t&lt;_Derived&gt;&gt;
#endif // TRANSITION, LLVM-44833
        {
            return _STD to_address(_RANGES begin(_Cast()));
        }

#ifdef __clang__ // TRANSITION, LLVM-44833
        template &lt;class _Dx = _Derived&gt;
        _NODISCARD constexpr auto data() const
            requires range&lt;const _Dx&gt; &amp;&amp; contiguous_iterator&lt;iterator_t&lt;const _Dx&gt;&gt;
#else // ^^^ workaround / no workaround vvv
        _NODISCARD constexpr auto data() const
            requires range&lt;const _Derived&gt; &amp;&amp; contiguous_iterator&lt;iterator_t&lt;const _Derived&gt;&gt;
#endif // TRANSITION, LLVM-44833
        {
            return _STD to_address(_RANGES begin(_Cast()));
        }

#ifdef __clang__ // TRANSITION, LLVM-44833
        template &lt;class _Dx = _Derived&gt;
        _NODISCARD constexpr auto size()
            requires forward_range&lt;_Dx&gt; &amp;&amp; sized_sentinel_for&lt;sentinel_t&lt;_Dx&gt;, iterator_t&lt;_Dx&gt;&gt;
#else // ^^^ workaround / no workaround vvv
        _NODISCARD constexpr auto size()
            requires forward_range&lt;_Derived&gt; &amp;&amp; sized_sentinel_for&lt;sentinel_t&lt;_Derived&gt;, iterator_t&lt;_Derived&gt;&gt;
#endif // TRANSITION, LLVM-44833
        {
            auto&amp; _Self = _Cast();
            return _STD _To_unsigned_like(_RANGES end(_Self) - _RANGES begin(_Self));
        }

#ifdef __clang__ // TRANSITION, LLVM-44833
        template &lt;class _Dx = _Derived&gt;
        _NODISCARD constexpr auto size() const
            requires forward_range&lt;const _Dx&gt; &amp;&amp; sized_sentinel_for&lt;sentinel_t&lt;const _Dx&gt;, iterator_t&lt;const _Dx&gt;&gt;
#else // ^^^ workaround / no workaround vvv
        _NODISCARD constexpr auto size() const
            requires forward_range&lt;const _Derived&gt;
                  &amp;&amp; sized_sentinel_for&lt;sentinel_t&lt;const _Derived&gt;, iterator_t&lt;const _Derived&gt;&gt;
#endif // TRANSITION, LLVM-44833
        {
            auto&amp; _Self = _Cast();
            return _STD _To_unsigned_like(_RANGES end(_Self) - _RANGES begin(_Self));
        }

#ifdef __clang__ // TRANSITION, LLVM-44833
        template &lt;class _Dx = _Derived&gt;
        _NODISCARD constexpr decltype(auto) front()
            requires forward_range&lt;_Dx&gt;
#else // ^^^ workaround / no workaround vvv
        _NODISCARD constexpr decltype(auto) front()
            requires forward_range&lt;_Derived&gt;
#endif // TRANSITION, LLVM-44833
        {
            auto&amp; _Self = _Cast();
#if _CONTAINER_DEBUG_LEVEL &gt; 0
            _STL_VERIFY(!_RANGES empty(_Self), "front called on empty view_interface");
#endif // _CONTAINER_DEBUG_LEVEL &gt; 0
            return *_RANGES begin(_Self);
        }

#ifdef __clang__ // TRANSITION, LLVM-44833
        template &lt;class _Dx = _Derived&gt;
        _NODISCARD constexpr decltype(auto) front() const
            requires forward_range&lt;const _Dx&gt;
#else // ^^^ workaround / no workaround vvv
        _NODISCARD constexpr decltype(auto) front() const
            requires forward_range&lt;const _Derived&gt;
#endif // TRANSITION, LLVM-44833
        {
            auto&amp; _Self = _Cast();
#if _CONTAINER_DEBUG_LEVEL &gt; 0
            _STL_VERIFY(!_RANGES empty(_Self), "front called on empty view_interface");
#endif // _CONTAINER_DEBUG_LEVEL &gt; 0
            return *_RANGES begin(_Self);
        }

#ifdef __clang__ // TRANSITION, LLVM-44833
        template &lt;class _Dx = _Derived&gt;
        _NODISCARD constexpr decltype(auto) back()
            requires bidirectional_range&lt;_Dx&gt; &amp;&amp; common_range&lt;_Dx&gt;
#else // ^^^ workaround / no workaround vvv
        _NODISCARD constexpr decltype(auto) back()
            requires bidirectional_range&lt;_Derived&gt; &amp;&amp; common_range&lt;_Derived&gt;
#endif // TRANSITION, LLVM-44833
        {
            auto&amp; _Self = _Cast();
#if _CONTAINER_DEBUG_LEVEL &gt; 0
            _STL_VERIFY(!_RANGES empty(_Self), "back called on empty view_interface");
#endif // _CONTAINER_DEBUG_LEVEL &gt; 0
            auto _Last = _RANGES end(_Self);
            return *--_Last;
        }

#ifdef __clang__ // TRANSITION, LLVM-44833
        template &lt;class _Dx = _Derived&gt;
        _NODISCARD constexpr decltype(auto) back() const
            requires bidirectional_range&lt;const _Dx&gt; &amp;&amp; common_range&lt;const _Dx&gt;
#else // ^^^ workaround / no workaround vvv
        _NODISCARD constexpr decltype(auto) back() const
            requires bidirectional_range&lt;const _Derived&gt; &amp;&amp; common_range&lt;const _Derived&gt;
#endif // TRANSITION, LLVM-44833
        {
            auto&amp; _Self = _Cast();
#if _CONTAINER_DEBUG_LEVEL &gt; 0
            _STL_VERIFY(!_RANGES empty(_Self), "back called on empty view_interface");
#endif // _CONTAINER_DEBUG_LEVEL &gt; 0
            auto _Last = _RANGES end(_Self);
            return *--_Last;
        }

        template &lt;random_access_range _Rng = _Derived&gt;
        _NODISCARD constexpr decltype(auto) operator[](const range_difference_t&lt;_Rng&gt; _Idx) {
            auto&amp; _Self = _Cast();
#if _CONTAINER_DEBUG_LEVEL &gt; 0
            if constexpr (sized_range&lt;_Derived&gt;) {
                using _U_diff = _Make_unsigned_like_t&lt;range_difference_t&lt;_Rng&gt;&gt;;
                _STL_VERIFY(static_cast&lt;_U_diff&gt;(_Idx) &lt; static_cast&lt;_U_diff&gt;(_RANGES size(_Self)),
                    "index out of range for view_interface");
            }
#endif // _CONTAINER_DEBUG_LEVEL &gt; 0
            return _RANGES begin(_Self)[_Idx];
        }

        template &lt;random_access_range _Rng = const _Derived&gt;
        _NODISCARD constexpr decltype(auto) operator[](const range_difference_t&lt;_Rng&gt; _Idx) const {
            auto&amp; _Self = _Cast();
#if _CONTAINER_DEBUG_LEVEL &gt; 0
            if constexpr (sized_range&lt;_Derived&gt;) {
                using _U_diff = _Make_unsigned_like_t&lt;range_difference_t&lt;_Rng&gt;&gt;;
                _STL_VERIFY(static_cast&lt;_U_diff&gt;(_Idx) &lt; static_cast&lt;_U_diff&gt;(_RANGES size(_Self)),
                    "index out of range for view_interface");
            }
#endif // _CONTAINER_DEBUG_LEVEL &gt; 0
            return _RANGES begin(_Self)[_Idx];
        }
    };
} // namespace ranges

// These declarations must be visible to qualified name lookup for _STD get in _Pair_like below, even if &lt;tuple&gt; hasn't
// yet been included.
_EXPORT_STD template &lt;size_t _Index, class... _Types&gt;
_NODISCARD constexpr tuple_element_t&lt;_Index, tuple&lt;_Types...&gt;&gt;&amp; get(tuple&lt;_Types...&gt;&amp; _Tuple) noexcept;
_EXPORT_STD template &lt;size_t _Index, class... _Types&gt;
_NODISCARD constexpr const tuple_element_t&lt;_Index, tuple&lt;_Types...&gt;&gt;&amp; get(const tuple&lt;_Types...&gt;&amp; _Tuple) noexcept;
_EXPORT_STD template &lt;size_t _Index, class... _Types&gt;
_NODISCARD constexpr tuple_element_t&lt;_Index, tuple&lt;_Types...&gt;&gt;&amp;&amp; get(tuple&lt;_Types...&gt;&amp;&amp; _Tuple) noexcept;
_EXPORT_STD template &lt;size_t _Index, class... _Types&gt;
_NODISCARD constexpr const tuple_element_t&lt;_Index, tuple&lt;_Types...&gt;&gt;&amp;&amp; get(const tuple&lt;_Types...&gt;&amp;&amp; _Tuple) noexcept;

namespace ranges {
    // clang-format off
    template &lt;class _From, class _To&gt;
    concept _Uses_nonqualification_pointer_conversion =
        is_pointer_v&lt;_From&gt; &amp;&amp; is_pointer_v&lt;_To&gt;
        &amp;&amp; !convertible_to&lt;remove_pointer_t&lt;_From&gt;(*)[], remove_pointer_t&lt;_To&gt;(*)[]&gt;;

    template &lt;class _From, class _To&gt;
    concept _Convertible_to_non_slicing = convertible_to&lt;_From, _To&gt;
        &amp;&amp; !_Uses_nonqualification_pointer_conversion&lt;decay_t&lt;_From&gt;, decay_t&lt;_To&gt;&gt;;

    template &lt;class _Ty&gt;
    concept _Pair_like = !is_reference_v&lt;_Ty&gt; &amp;&amp; requires(_Ty __t) {
        typename tuple_size&lt;_Ty&gt;::type;
        requires derived_from&lt;tuple_size&lt;_Ty&gt;, integral_constant&lt;size_t, 2&gt;&gt;;
        typename tuple_element_t&lt;0, remove_const_t&lt;_Ty&gt;&gt;;
        typename tuple_element_t&lt;1, remove_const_t&lt;_Ty&gt;&gt;;
        { _STD get&lt;0&gt;(__t) } -&gt; convertible_to&lt;const tuple_element_t&lt;0, _Ty&gt;&amp;&gt;;
        { _STD get&lt;1&gt;(__t) } -&gt; convertible_to&lt;const tuple_element_t&lt;1, _Ty&gt;&amp;&gt;;
    };

    template &lt;class _Ty, class _First, class _Second&gt;
    concept _Pair_like_convertible_from = !range&lt;_Ty&gt; &amp;&amp; _Pair_like&lt;_Ty&gt;
        &amp;&amp; constructible_from&lt;_Ty, _First, _Second&gt;
        &amp;&amp; _Convertible_to_non_slicing&lt;_First, tuple_element_t&lt;0, _Ty&gt;&gt;
        &amp;&amp; convertible_to&lt;_Second, tuple_element_t&lt;1, _Ty&gt;&gt;;
    // clang-format on

    template &lt;class _It, class _Se, subrange_kind _Ki,
        bool _Store = _Ki == subrange_kind::sized &amp;&amp; !sized_sentinel_for&lt;_Se, _It&gt;&gt;
    class _Subrange_base : public view_interface&lt;subrange&lt;_It, _Se, _Ki&gt;&gt; { // TRANSITION, [[no_unique_address]]
    protected:
        using _Size_type                  = _Make_unsigned_like_t&lt;iter_difference_t&lt;_It&gt;&gt;;
        static constexpr bool _Store_size = true;

        _Size_type _Size = 0;

    public:
        _Subrange_base() = default;
        constexpr explicit _Subrange_base(const _Size_type&amp; _Size_) noexcept : _Size(_Size_) {}
    };

    template &lt;class _It, class _Se, subrange_kind _Ki&gt;
    class _Subrange_base&lt;_It, _Se, _Ki, false&gt; : public view_interface&lt;subrange&lt;_It, _Se, _Ki&gt;&gt; {
    protected:
        using _Size_type                  = _Make_unsigned_like_t&lt;iter_difference_t&lt;_It&gt;&gt;;
        static constexpr bool _Store_size = false;

    public:
        _Subrange_base() = default;
        constexpr explicit _Subrange_base(const _Size_type&amp;) noexcept {}
    };

#if 1 // TRANSITION, VSO-1695918 - Warning C4324 incorrectly firing in the presence of `pragma pack`
#pragma warning(push)
#pragma warning(disable : 4324) // structure was padded due to alignment specifier
#endif // TRANSITION, VSO-1695918 - Warning C4324 incorrectly firing in the presence of `pragma pack`
    _EXPORT_STD template &lt;input_or_output_iterator _It, sentinel_for&lt;_It&gt; _Se, subrange_kind _Ki&gt;
        requires (_Ki == subrange_kind::sized || !sized_sentinel_for&lt;_Se, _It&gt;)
    class subrange : public _Subrange_base&lt;_It, _Se, _Ki&gt; {
    private:
        using _Mybase = _Subrange_base&lt;_It, _Se, _Ki&gt;;
        using _Mybase::_Store_size;
        using typename _Mybase::_Size_type;

        // TRANSITION, [[no_unique_address]]:
        /* [[no_unique_address]] */ _It _First{};
        /* [[no_unique_address]] */ _Se _Last{};
        // [[no_unique_address]] conditional_t&lt;_Store_size, _Size_type, _Nil&gt; _Size{};

        template &lt;class _Rng&gt;
        constexpr subrange(true_type, _Rng&amp;&amp; _Val)
            : subrange(_STD forward&lt;_Rng&gt;(_Val), static_cast&lt;_Size_type&gt;(_RANGES size(_Val))) {
            // delegation target for subrange(_Rng&amp;&amp;) when we must store the range size
            _STL_INTERNAL_STATIC_ASSERT(_Store_size);
        }

        template &lt;class _Rng&gt;
        constexpr subrange(false_type, _Rng&amp;&amp; _Val) : subrange(_RANGES begin(_Val), _RANGES end(_Val)) {
            // delegation target for subrange(_Rng&amp;&amp;) when we need not store the range size
            _STL_INTERNAL_STATIC_ASSERT(!_Store_size);
        }

    public:
        // clang-format off
        subrange() requires default_initializable&lt;_It&gt; = default;

        template &lt;_Convertible_to_non_slicing&lt;_It&gt; _It2&gt;
        constexpr subrange(_It2 _First_, _Se _Last_) requires (!_Store_size)
            : _First(_STD move(_First_)), _Last(_STD move(_Last_)) {}

        template &lt;_Convertible_to_non_slicing&lt;_It&gt; _It2&gt;
        constexpr subrange(_It2 _First_, _Se _Last_, const _Size_type _Size_) requires (_Ki == subrange_kind::sized)
            : _Mybase(_Size_), _First(_STD move(_First_)), _Last(_STD move(_Last_)) {
            if constexpr (sized_sentinel_for&lt;_Se, _It&gt;) {
                _STL_ASSERT(_Size_ == static_cast&lt;_Size_type&gt;(_Last - _First),
                    "This constructor's third argument should be equal to the distance "
                    "between the first and second arguments (N4849 [range.subrange.ctor]/3).");
            }
        }

        template &lt;_Different_from&lt;subrange&gt; _Rng&gt;
            requires borrowed_range&lt;_Rng&gt;
                &amp;&amp; _Convertible_to_non_slicing&lt;iterator_t&lt;_Rng&gt;, _It&gt;
                &amp;&amp; convertible_to&lt;sentinel_t&lt;_Rng&gt;, _Se&gt;
        constexpr subrange(_Rng&amp;&amp; _Val) requires (!_Store_size || sized_range&lt;_Rng&gt;)
            : subrange{bool_constant&lt;_Store_size&gt;{}, _STD forward&lt;_Rng&gt;(_Val)} {}

        template &lt;borrowed_range _Rng&gt;
            requires _Convertible_to_non_slicing&lt;iterator_t&lt;_Rng&gt;, _It&gt; &amp;&amp; convertible_to&lt;sentinel_t&lt;_Rng&gt;, _Se&gt;
        constexpr subrange(_Rng&amp;&amp; _Val, const _Size_type _Count) requires (_Ki == subrange_kind::sized)
            : subrange{_RANGES begin(_Val), _RANGES end(_Val), _Count} {}
        // clang-format on

        template &lt;_Different_from&lt;subrange&gt; _Pair_like&gt;
            requires _Pair_like_convertible_from&lt;_Pair_like, const _It&amp;, const _Se&amp;&gt;
        constexpr operator _Pair_like() const {
            return _Pair_like(_First, _Last);
        }

        _NODISCARD constexpr _It begin() const
            requires copyable&lt;_It&gt;
        {
            return _First;
        }
        // clang-format off
        _NODISCARD constexpr _It begin() requires (!copyable&lt;_It&gt;) {
            // clang-format on
            return _STD move(_First);
        }

        _NODISCARD constexpr _Se end() const {
            return _Last;
        }

        _NODISCARD constexpr bool empty() const {
            return _First == _Last;
        }

        // clang-format off
        _NODISCARD constexpr _Size_type size() const requires (_Ki == subrange_kind::sized) {
            // clang-format on
            if constexpr (_Store_size) {
                return this-&gt;_Size;
            } else {
                return static_cast&lt;_Size_type&gt;(_Last - _First);
            }
        }

        _NODISCARD constexpr subrange next() const&amp;
            requires forward_iterator&lt;_It&gt;
        {
            auto _Tmp = *this;
            if (_Tmp._First != _Tmp._Last) {
                ++_Tmp._First;
                if constexpr (_Store_size) {
                    --_Tmp._Size;
                }
            }
            return _Tmp;
        }
        _NODISCARD constexpr subrange next(const iter_difference_t&lt;_It&gt; _Count) const&amp;
            requires forward_iterator&lt;_It&gt;
        {
            auto _Tmp = *this;
            _Tmp.advance(_Count);
            return _Tmp;
        }

        _NODISCARD constexpr subrange next() &amp;&amp; {
            if (_First != _Last) {
                ++_First;
                if constexpr (_Store_size) {
                    --this-&gt;_Size;
                }
            }
            return _STD move(*this);
        }
        _NODISCARD constexpr subrange next(const iter_difference_t&lt;_It&gt; _Count) &amp;&amp; {
            advance(_Count);
            return _STD move(*this);
        }

        _NODISCARD constexpr subrange prev() const
            requires bidirectional_iterator&lt;_It&gt;
        {
            auto _Tmp = *this;
            --_Tmp._First;
            if constexpr (_Store_size) {
                ++_Tmp._Size;
            }
            return _Tmp;
        }
        _NODISCARD constexpr subrange prev(const iter_difference_t&lt;_It&gt; _Count) const
            requires bidirectional_iterator&lt;_It&gt;
        {
            auto _Tmp = *this;
            _Tmp.advance(-_Count);
            return _Tmp;
        }

        constexpr subrange&amp; advance(const iter_difference_t&lt;_It&gt; _Count) {
            if constexpr (bidirectional_iterator&lt;_It&gt;) {
                if (_Count &lt; 0) {
                    _RANGES advance(_First, _Count);
                    if constexpr (_Store_size) {
                        this-&gt;_Size += static_cast&lt;_Size_type&gt;(-_Count);
                    }
                    return *this;
                }
            }

            const auto _Remainder = _RANGES advance(_First, _Count, _Last);
            if constexpr (_Store_size) {
                this-&gt;_Size -= static_cast&lt;_Size_type&gt;(_Count - _Remainder);
            }
            return *this;
        }
    };
#if 1 // TRANSITION, VSO-1695918 - Warning C4324 incorrectly firing in the presence of `pragma pack`
#pragma warning(pop)
#endif // TRANSITION, VSO-1695918 - Warning C4324 incorrectly firing in the presence of `pragma pack`

    template &lt;input_or_output_iterator _It, sentinel_for&lt;_It&gt; _Se&gt;
    subrange(_It, _Se) -&gt; subrange&lt;_It, _Se&gt;;

    template &lt;input_or_output_iterator _It, sentinel_for&lt;_It&gt; _Se&gt;
    subrange(_It, _Se, _Make_unsigned_like_t&lt;iter_difference_t&lt;_It&gt;&gt;) -&gt; subrange&lt;_It, _Se, subrange_kind::sized&gt;;

    template &lt;borrowed_range _Rng&gt;
    subrange(_Rng&amp;&amp;) -&gt; subrange&lt;iterator_t&lt;_Rng&gt;, sentinel_t&lt;_Rng&gt;,
        (sized_range&lt;_Rng&gt; || sized_sentinel_for&lt;sentinel_t&lt;_Rng&gt;, iterator_t&lt;_Rng&gt;&gt;) ? subrange_kind::sized
                                                                                      : subrange_kind::unsized&gt;;

    template &lt;borrowed_range _Rng&gt;
    subrange(_Rng&amp;&amp;, _Make_unsigned_like_t&lt;range_difference_t&lt;_Rng&gt;&gt;)
        -&gt; subrange&lt;iterator_t&lt;_Rng&gt;, sentinel_t&lt;_Rng&gt;, subrange_kind::sized&gt;;

    template &lt;class _It, class _Se, subrange_kind _Ki&gt;
    inline constexpr bool enable_borrowed_range&lt;subrange&lt;_It, _Se, _Ki&gt;&gt; = true;

    _EXPORT_STD template &lt;size_t _Idx, class _It, class _Se, subrange_kind _Ki&gt;
        requires ((_Idx == 0 &amp;&amp; copyable&lt;_It&gt;) || _Idx == 1)
    _NODISCARD constexpr auto get(const subrange&lt;_It, _Se, _Ki&gt;&amp; _Val) {
        if constexpr (_Idx == 0) {
            return _Val.begin();
        } else {
            return _Val.end();
        }
    }

    _EXPORT_STD template &lt;size_t _Idx, class _It, class _Se, subrange_kind _Ki&gt;
        requires (_Idx &lt; 2)
    _NODISCARD constexpr auto get(subrange&lt;_It, _Se, _Ki&gt;&amp;&amp; _Val) {
        if constexpr (_Idx == 0) {
            return _Val.begin();
        } else {
            return _Val.end();
        }
    }

    _EXPORT_STD struct dangling {
        constexpr dangling() noexcept = default;
        template &lt;class... _Args&gt;
        constexpr dangling(_Args&amp;&amp;...) noexcept {}
    };

    _EXPORT_STD template &lt;range _Rng&gt;
    using borrowed_iterator_t = conditional_t&lt;borrowed_range&lt;_Rng&gt;, iterator_t&lt;_Rng&gt;, dangling&gt;;

    _EXPORT_STD template &lt;range _Rng&gt;
    using borrowed_subrange_t = conditional_t&lt;borrowed_range&lt;_Rng&gt;, subrange&lt;iterator_t&lt;_Rng&gt;&gt;, dangling&gt;;
} // namespace ranges
#endif // __cpp_lib_concepts

struct _Container_proxy;
struct _Iterator_base12;

struct _Default_sentinel {}; // empty struct to serve as the end of a range

#ifdef __cpp_lib_concepts
_EXPORT_STD template &lt;semiregular&gt;
class move_sentinel;

template &lt;class&gt;
struct _Move_iterator_category {};

// clang-format off
template &lt;class _Iter&gt;
    requires requires { typename _Iter_cat_t&lt;_Iter&gt;; }
struct _Move_iterator_category&lt;_Iter&gt; {
    using iterator_category = conditional_t&lt;derived_from&lt;_Iter_cat_t&lt;_Iter&gt;, random_access_iterator_tag&gt;,
        random_access_iterator_tag, _Iter_cat_t&lt;_Iter&gt;&gt;;
};
// clang-format on
#else // ^^^ Ranges / no Ranges vvv
template &lt;class _Iter&gt;
struct _Move_iterator_category {
    using iterator_category = _Iter_cat_t&lt;_Iter&gt;;
};
#endif // __cpp_lib_concepts

_EXPORT_STD template &lt;class _Iter&gt;
class move_iterator : public _Move_iterator_category&lt;_Iter&gt; {
public:
    using iterator_type   = _Iter;
    using value_type      = _Iter_value_t&lt;_Iter&gt;;
    using difference_type = _Iter_diff_t&lt;_Iter&gt;;
    using pointer         = _Iter;

#ifdef __cpp_lib_concepts
private:
    static constexpr auto _Get_iter_concept() {
        if constexpr (random_access_iterator&lt;_Iter&gt;) {
            return random_access_iterator_tag{};
        } else if constexpr (bidirectional_iterator&lt;_Iter&gt;) {
            return bidirectional_iterator_tag{};
        } else if constexpr (forward_iterator&lt;_Iter&gt;) {
            return forward_iterator_tag{};
        } else {
            return input_iterator_tag{};
        }
    }

public:
    using iterator_concept = decltype(_Get_iter_concept());

    using reference = iter_rvalue_reference_t&lt;_Iter&gt;;
#else // ^^^ __cpp_lib_concepts / !__cpp_lib_concepts vvv
    using reference =
        conditional_t&lt;is_reference_v&lt;_Iter_ref_t&lt;_Iter&gt;&gt;, remove_reference_t&lt;_Iter_ref_t&lt;_Iter&gt;&gt;&amp;&amp;, _Iter_ref_t&lt;_Iter&gt;&gt;;
#endif // __cpp_lib_concepts

    _CONSTEXPR17 move_iterator() = default;

    _CONSTEXPR17 explicit move_iterator(_Iter _Right) noexcept(is_nothrow_move_constructible_v&lt;_Iter&gt;) // strengthened
        : _Current(_STD move(_Right)) {}

    // clang-format off
    template &lt;class _Other&gt;
#ifdef __cpp_lib_concepts
        requires (!is_same_v&lt;_Other, _Iter&gt;) &amp;&amp; convertible_to&lt;const _Other&amp;, _Iter&gt;
#endif // __cpp_lib_concepts
    _CONSTEXPR17 move_iterator(const move_iterator&lt;_Other&gt;&amp; _Right) noexcept(
        is_nothrow_constructible_v&lt;_Iter, const _Other&amp;&gt;) // strengthened
        : _Current(_Right.base()) {}

    template &lt;class _Other&gt;
#ifdef __cpp_lib_concepts
        requires (!is_same_v&lt;_Other, _Iter&gt;) &amp;&amp; convertible_to&lt;const _Other&amp;, _Iter&gt;
            &amp;&amp; assignable_from&lt;_Iter&amp;, const _Other&amp;&gt;
#endif // __cpp_lib_concepts
    _CONSTEXPR17 move_iterator&amp; operator=(const move_iterator&lt;_Other&gt;&amp; _Right) noexcept(
        is_nothrow_assignable_v&lt;_Iter&amp;, const _Other&amp;&gt;) /* strengthened */ {
        _Current = _Right.base();
        return *this;
    }
    // clang-format on

#ifdef __cpp_lib_concepts
    _NODISCARD constexpr const iterator_type&amp; base() const&amp; noexcept {
        return _Current;
    }
    _NODISCARD constexpr iterator_type base() &amp;&amp; noexcept(is_nothrow_move_constructible_v&lt;_Iter&gt;) /* strengthened */ {
        return _STD move(_Current);
    }
#else // ^^^ __cpp_lib_concepts / !__cpp_lib_concepts vvv
    _NODISCARD _CONSTEXPR17 iterator_type base() const
        noexcept(is_nothrow_copy_constructible_v&lt;_Iter&gt;) /* strengthened */ {
        return _Current;
    }
#endif // __cpp_lib_concepts

    _NODISCARD _CONSTEXPR17 reference operator*() const
#ifdef __cpp_lib_concepts
        noexcept(noexcept(_RANGES iter_move(_Current))) /* strengthened */ {
        return _RANGES iter_move(_Current);
    }
#else // ^^^ __cpp_lib_concepts / !__cpp_lib_concepts vvv
        noexcept(noexcept(static_cast&lt;reference&gt;(*_Current))) /* strengthened */ {
        return static_cast&lt;reference&gt;(*_Current);
    }
#endif // __cpp_lib_concepts

    _CXX20_DEPRECATE_MOVE_ITERATOR_ARROW _NODISCARD _CONSTEXPR17 pointer operator-&gt;() const
        noexcept(is_nothrow_copy_constructible_v&lt;_Iter&gt;) /* strengthened */ {
        return _Current;
    }

    _CONSTEXPR17 move_iterator&amp; operator++() noexcept(noexcept(++_Current)) /* strengthened */ {
        ++_Current;
        return *this;
    }

    _CONSTEXPR17 auto operator++(int) noexcept(
        is_nothrow_copy_constructible_v&lt;_Iter&gt;&amp;&amp; noexcept(++_Current)) /* strengthened */ {
#ifdef __cpp_lib_concepts
        if constexpr (forward_iterator&lt;_Iter&gt;) {
#endif // __cpp_lib_concepts
            move_iterator _Tmp = *this;
            ++_Current;
            return _Tmp;
#ifdef __cpp_lib_concepts
        } else {
            ++_Current;
        }
#endif // __cpp_lib_concepts
    }

    _CONSTEXPR17 move_iterator&amp; operator--() noexcept(noexcept(--_Current)) /* strengthened */ {
        --_Current;
        return *this;
    }

    _CONSTEXPR17 move_iterator operator--(int) noexcept(
        is_nothrow_copy_constructible_v&lt;_Iter&gt;&amp;&amp; noexcept(--_Current)) /* strengthened */ {
        move_iterator _Tmp = *this;
        --_Current;
        return _Tmp;
    }

    template &lt;class _Iter2 = _Iter&gt;
    _NODISCARD auto operator==(_Default_sentinel _Sentinel) const noexcept
        -&gt; decltype(_STD declval&lt;const _Iter2&amp;&gt;() == _Sentinel) {
        return _Current == _Sentinel;
    }

    template &lt;class _Iter2 = _Iter&gt;
    _NODISCARD auto operator!=(_Default_sentinel _Sentinel) const noexcept
        -&gt; decltype(_STD declval&lt;const _Iter2&amp;&gt;() != _Sentinel) {
        return _Current != _Sentinel;
    }

    _NODISCARD _CONSTEXPR17 move_iterator operator+(const difference_type _Off) const
        noexcept(noexcept(move_iterator(_Current + _Off))) /* strengthened */ {
        return move_iterator(_Current + _Off);
    }

    _CONSTEXPR17 move_iterator&amp; operator+=(const difference_type _Off) noexcept(
        noexcept(_Current += _Off)) /* strengthened */ {
        _Current += _Off;
        return *this;
    }

    _NODISCARD _CONSTEXPR17 move_iterator operator-(const difference_type _Off) const
        noexcept(noexcept(move_iterator(_Current - _Off))) /* strengthened */ {
        return move_iterator(_Current - _Off);
    }

    _CONSTEXPR17 move_iterator&amp; operator-=(const difference_type _Off) noexcept(
        noexcept(_Current -= _Off)) /* strengthened */ {
        _Current -= _Off;
        return *this;
    }

    _NODISCARD _CONSTEXPR17 reference operator[](const difference_type _Off) const
#ifdef __cpp_lib_concepts
        noexcept(noexcept(_RANGES iter_move(_Current + _Off))) /* strengthened */ {
        return _RANGES iter_move(_Current + _Off);
#else // ^^^ __cpp_lib_concepts / !__cpp_lib_concepts vvv
        noexcept(noexcept(_STD move(_Current[_Off]))) /* strengthened */ {
        return _STD move(_Current[_Off]);
#endif // __cpp_lib_concepts
    }

#ifdef __cpp_lib_concepts
    template &lt;sentinel_for&lt;_Iter&gt; _Sent&gt;
    _NODISCARD_FRIEND constexpr bool
        operator==(const move_iterator&amp; _Left, const move_sentinel&lt;_Sent&gt;&amp; _Right) noexcept(
            noexcept(_Fake_copy_init&lt;bool&gt;(_Left._Current == _Right._Get_last()))) /* strengthened */ {
        return _Left._Current == _Right._Get_last();
    }

    template &lt;sized_sentinel_for&lt;_Iter&gt; _Sent&gt;
    _NODISCARD_FRIEND constexpr difference_type operator-(const move_sentinel&lt;_Sent&gt;&amp; _Left,
        const move_iterator&amp; _Right) noexcept(noexcept(_Left._Get_last() - _Right._Current)) /* strengthened */ {
        return _Left._Get_last() - _Right._Current;
    }

    template &lt;sized_sentinel_for&lt;_Iter&gt; _Sent&gt;
    _NODISCARD_FRIEND constexpr difference_type operator-(const move_iterator&amp; _Left,
        const move_sentinel&lt;_Sent&gt;&amp; _Right) noexcept(noexcept(_Left._Current - _Right._Get_last())) /* strengthened */ {
        return _Left._Current - _Right._Get_last();
    }

    _NODISCARD_FRIEND constexpr reference iter_move(const move_iterator&amp; _It)
#ifdef __EDG__ // TRANSITION, VSO-1222776
        noexcept(noexcept(_RANGES iter_move(_STD declval&lt;const _Iter&amp;&gt;())))
#else // ^^^ workaround / no workaround vvv
        noexcept(noexcept(_RANGES iter_move(_It._Current)))
#endif // TRANSITION, VSO-1222776
    {
        return _RANGES iter_move(_It._Current);
    }

    template &lt;indirectly_swappable&lt;_Iter&gt; _Iter2&gt;
    friend constexpr void iter_swap(const move_iterator&amp; _Left, const move_iterator&lt;_Iter2&gt;&amp; _Right)
#ifdef __EDG__ // TRANSITION, VSO-1222776
        noexcept(noexcept(_RANGES iter_swap(_STD declval&lt;const _Iter&amp;&gt;(), _STD declval&lt;const _Iter2&amp;&gt;())))
#else // ^^^ workaround / no workaround vvv
        noexcept(noexcept(_RANGES iter_swap(_Left._Current, _Right.base())))
#endif // TRANSITION, VSO-1222776
    {
        _RANGES iter_swap(_Left._Current, _Right.base());
    }
#endif // __cpp_lib_concepts

    template &lt;class _Iter2, enable_if_t&lt;_Range_verifiable_v&lt;_Iter, _Iter2&gt;, int&gt; = 0&gt;
    friend constexpr void _Verify_range(const move_iterator&amp; _First, const move_iterator&lt;_Iter2&gt;&amp; _Last) noexcept {
        _Verify_range(_First._Current, _Last._Get_current());
    }
#ifdef __cpp_lib_concepts
    template &lt;sentinel_for&lt;_Iter&gt; _Sent, enable_if_t&lt;_Range_verifiable_v&lt;_Iter, _Sent&gt;, int&gt; = 0&gt;
    friend constexpr void _Verify_range(const move_iterator&amp; _First, const move_sentinel&lt;_Sent&gt;&amp; _Last) noexcept {
        _Verify_range(_First._Current, _Last._Get_last());
    }
#endif // __cpp_lib_concepts

    using _Prevent_inheriting_unwrap = move_iterator;

    template &lt;class _Iter2 = iterator_type, enable_if_t&lt;_Offset_verifiable_v&lt;_Iter2&gt;, int&gt; = 0&gt;
    constexpr void _Verify_offset(const difference_type _Off) const noexcept {
        _Current._Verify_offset(_Off);
    }

    template &lt;class _Iter2 = iterator_type, enable_if_t&lt;_Unwrappable_v&lt;const _Iter2&amp;&gt;, int&gt; = 0&gt;
    _NODISCARD constexpr move_iterator&lt;_Unwrapped_t&lt;const _Iter2&amp;&gt;&gt; _Unwrapped() const&amp; noexcept(
        noexcept(static_cast&lt;move_iterator&lt;_Unwrapped_t&lt;const _Iter2&amp;&gt;&gt;&gt;(_Current._Unwrapped()))) {
        return static_cast&lt;move_iterator&lt;_Unwrapped_t&lt;const _Iter2&amp;&gt;&gt;&gt;(_Current._Unwrapped());
    }
    template &lt;class _Iter2 = iterator_type, enable_if_t&lt;_Unwrappable_v&lt;_Iter2&gt;, int&gt; = 0&gt;
    _NODISCARD constexpr move_iterator&lt;_Unwrapped_t&lt;_Iter2&gt;&gt; _Unwrapped() &amp;&amp; noexcept(
        noexcept(static_cast&lt;move_iterator&lt;_Unwrapped_t&lt;_Iter2&gt;&gt;&gt;(_STD move(_Current)._Unwrapped()))) {
        return static_cast&lt;move_iterator&lt;_Unwrapped_t&lt;_Iter2&gt;&gt;&gt;(_STD move(_Current)._Unwrapped());
    }

    static constexpr bool _Unwrap_when_unverified = _Do_unwrap_when_unverified_v&lt;iterator_type&gt;;

    template &lt;class _Src, enable_if_t&lt;_Wrapped_seekable_v&lt;iterator_type, const _Src&amp;&gt;, int&gt; = 0&gt;
    constexpr void _Seek_to(const move_iterator&lt;_Src&gt;&amp; _It) noexcept(noexcept(_Current._Seek_to(_It._Get_current()))) {
        _Current._Seek_to(_It._Get_current());
    }
    template &lt;class _Src, enable_if_t&lt;_Wrapped_seekable_v&lt;iterator_type, _Src&gt;, int&gt; = 0&gt;
    constexpr void _Seek_to(move_iterator&lt;_Src&gt;&amp;&amp; _It) noexcept(
        noexcept(_Current._Seek_to(_STD move(_It)._Get_current()))) {
        _Current._Seek_to(_STD move(_It)._Get_current());
    }

    _NODISCARD constexpr const iterator_type&amp; _Get_current() const&amp; noexcept {
        return _Current;
    }
    _NODISCARD constexpr iterator_type&amp;&amp; _Get_current() &amp;&amp; noexcept {
        return _STD move(_Current);
    }

private:
    iterator_type _Current{};
};

_EXPORT_STD template &lt;class _Iter1, class _Iter2&gt;
_NODISCARD _CONSTEXPR17 bool
    operator==(const move_iterator&lt;_Iter1&gt;&amp; _Left, const move_iterator&lt;_Iter2&gt;&amp; _Right) noexcept(
        noexcept(_Fake_copy_init&lt;bool&gt;(_Left.base() == _Right.base()))) /* strengthened */
#ifdef __cpp_lib_concepts
    // clang-format off
    requires requires {
        { _Left.base() == _Right.base() } -&gt; _Implicitly_convertible_to&lt;bool&gt;;
    }
// clang-format on
#endif // __cpp_lib_concepts
{
    return _Left.base() == _Right.base();
}

#if !_HAS_CXX20
template &lt;class _Iter1, class _Iter2&gt;
_NODISCARD _CONSTEXPR17 bool operator!=(const move_iterator&lt;_Iter1&gt;&amp; _Left,
    const move_iterator&lt;_Iter2&gt;&amp; _Right) noexcept(noexcept(_Left == _Right)) /* strengthened */ {
    return !(_Left == _Right);
}
#endif // !_HAS_CXX20

_EXPORT_STD template &lt;class _Iter1, class _Iter2&gt;
_NODISCARD _CONSTEXPR17 bool
    operator&lt;(const move_iterator&lt;_Iter1&gt;&amp; _Left, const move_iterator&lt;_Iter2&gt;&amp; _Right) noexcept(
        noexcept(_Fake_copy_init&lt;bool&gt;(_Left.base() &lt; _Right.base()))) /* strengthened */
#ifdef __cpp_lib_concepts
    // clang-format off
    requires requires {
        { _Left.base() &lt; _Right.base() } -&gt; _Implicitly_convertible_to&lt;bool&gt;;
    }
// clang-format on
#endif // __cpp_lib_concepts
{
    return _Left.base() &lt; _Right.base();
}

_EXPORT_STD template &lt;class _Iter1, class _Iter2&gt;
_NODISCARD _CONSTEXPR17 bool operator&gt;(const move_iterator&lt;_Iter1&gt;&amp; _Left,
    const move_iterator&lt;_Iter2&gt;&amp; _Right) noexcept(noexcept(_Right &lt; _Left)) /* strengthened */
#ifdef __cpp_lib_concepts
    requires requires { _Right &lt; _Left; }
#endif // __cpp_lib_concepts
{
    return _Right &lt; _Left;
}

_EXPORT_STD template &lt;class _Iter1, class _Iter2&gt;
_NODISCARD _CONSTEXPR17 bool operator&lt;=(const move_iterator&lt;_Iter1&gt;&amp; _Left,
    const move_iterator&lt;_Iter2&gt;&amp; _Right) noexcept(noexcept(_Right &lt; _Left)) /* strengthened */
#ifdef __cpp_lib_concepts
    requires requires { _Right &lt; _Left; }
#endif // __cpp_lib_concepts
{
    return !(_Right &lt; _Left);
}

_EXPORT_STD template &lt;class _Iter1, class _Iter2&gt;
_NODISCARD _CONSTEXPR17 bool operator&gt;=(const move_iterator&lt;_Iter1&gt;&amp; _Left,
    const move_iterator&lt;_Iter2&gt;&amp; _Right) noexcept(noexcept(_Left &lt; _Right)) /* strengthened */
#ifdef __cpp_lib_concepts
    requires requires { _Left &lt; _Right; }
#endif // __cpp_lib_concepts
{
    return !(_Left &lt; _Right);
}

#ifdef __cpp_lib_concepts
_EXPORT_STD template &lt;class _Iter1, three_way_comparable_with&lt;_Iter1&gt; _Iter2&gt;
_NODISCARD constexpr compare_three_way_result_t&lt;_Iter1, _Iter2&gt; operator&lt;=&gt;(const move_iterator&lt;_Iter1&gt;&amp; _Left,
    const move_iterator&lt;_Iter2&gt;&amp; _Right) noexcept(noexcept(_Left.base() &lt;=&gt; _Right.base())) /* strengthened */ {
    return _Left.base() &lt;=&gt; _Right.base();
}
#endif // __cpp_lib_concepts

_EXPORT_STD template &lt;class _Iter1, class _Iter2&gt;
_NODISCARD _CONSTEXPR17 auto operator-(const move_iterator&lt;_Iter1&gt;&amp; _Left,
    const move_iterator&lt;_Iter2&gt;&amp; _Right) noexcept(noexcept(_Left.base() - _Right.base())) /* strengthened */
    -&gt; decltype(_Left.base() - _Right.base()) {
    return _Left.base() - _Right.base();
}

_EXPORT_STD template &lt;class _Iter&gt;
_NODISCARD _CONSTEXPR17 move_iterator&lt;_Iter&gt;
    operator+(typename move_iterator&lt;_Iter&gt;::difference_type _Off, const move_iterator&lt;_Iter&gt;&amp; _Right) noexcept(
        noexcept(move_iterator&lt;_Iter&gt;(_Right.base() + _Off))) /* strengthened */
#ifdef __cpp_lib_concepts
    // clang-format off
    requires requires {
        { _Right.base() + _Off } -&gt; same_as&lt;_Iter&gt;;
    }
// clang-format on
#endif // __cpp_lib_concepts
{
    return move_iterator&lt;_Iter&gt;(_Right.base() + _Off);
}

_EXPORT_STD template &lt;class _Iter&gt;
_NODISCARD _CONSTEXPR17 move_iterator&lt;_Iter&gt; make_move_iterator(_Iter _It) noexcept(
    is_nothrow_move_constructible_v&lt;_Iter&gt;) /* strengthened */ {
    return move_iterator&lt;_Iter&gt;(_STD move(_It));
}

#ifdef __cpp_lib_concepts
template &lt;class _Iter1, class _Iter2&gt;
    requires (!sized_sentinel_for&lt;_Iter1, _Iter2&gt;)
inline constexpr bool disable_sized_sentinel_for&lt;move_iterator&lt;_Iter1&gt;, move_iterator&lt;_Iter2&gt;&gt; = true;

_EXPORT_STD struct default_sentinel_t {};

_EXPORT_STD inline constexpr default_sentinel_t default_sentinel{};

_EXPORT_STD struct unreachable_sentinel_t;
namespace _Unreachable_sentinel_detail {
    struct _Base {
        template &lt;weakly_incrementable _Winc&gt;
        _NODISCARD_FRIEND constexpr bool operator==(const unreachable_sentinel_t&amp;, const _Winc&amp;) noexcept {
            return false;
        }
    };
} // namespace _Unreachable_sentinel_detail
_EXPORT_STD struct unreachable_sentinel_t : _Unreachable_sentinel_detail::_Base {}; // TRANSITION, /permissive-

_EXPORT_STD inline constexpr unreachable_sentinel_t unreachable_sentinel{};
#endif // __cpp_lib_concepts

// _Iterator_is_contiguous&lt;_Iter&gt; reports whether an iterator is known to be contiguous.
// (Without concepts, this detection is limited, which will limit when we can activate optimizations.)

#ifdef __cpp_lib_concepts
// When concepts are available, we can detect arbitrary contiguous iterators.
template &lt;class _Iter&gt;
inline constexpr bool _Iterator_is_contiguous = contiguous_iterator&lt;_Iter&gt;;

template &lt;class _Iter&gt;
_NODISCARD constexpr auto _To_address(const _Iter&amp; _Val) noexcept {
    _STL_INTERNAL_STATIC_ASSERT(contiguous_iterator&lt;_Iter&gt;);
    return _STD to_address(_Val);
}
#else // ^^^ defined(__cpp_lib_concepts) / !defined(__cpp_lib_concepts) vvv
// When concepts aren't available, we can detect pointers. (Iterators should be unwrapped before using this.)
template &lt;class _Iter&gt;
_INLINE_VAR constexpr bool _Iterator_is_contiguous = is_pointer_v&lt;_Iter&gt;;

template &lt;class _Iter&gt;
_NODISCARD constexpr auto _To_address(const _Iter&amp; _Val) noexcept {
    _STL_INTERNAL_STATIC_ASSERT(is_pointer_v&lt;_Iter&gt;);
    return _Val;
}
#endif // ^^^ !defined(__cpp_lib_concepts) ^^^

template &lt;class _Iter&gt;
_NODISCARD constexpr auto _To_address(const move_iterator&lt;_Iter&gt;&amp; _Val) noexcept {
    return _To_address(_Val.base());
}

// _Iterators_are_contiguous&lt;_Iter1, _Iter2&gt; reports whether both iterators are known to be contiguous.

template &lt;class _Iter1, class _Iter2&gt;
_INLINE_VAR constexpr bool _Iterators_are_contiguous =
    _Iterator_is_contiguous&lt;_Iter1&gt; &amp;&amp; _Iterator_is_contiguous&lt;_Iter2&gt;;

template &lt;class _Iter&gt;
_INLINE_VAR constexpr bool _Iterator_is_volatile = is_volatile_v&lt;remove_reference_t&lt;_Iter_ref_t&lt;_Iter&gt;&gt;&gt;;

template &lt;class _Source, class _Dest&gt;
_INLINE_VAR constexpr bool _Is_pointer_address_convertible = is_void_v&lt;_Source&gt;
                                                          || is_void_v&lt;_Dest&gt;
                                                          // NOTE: is_same_v is required for function pointers to work
                                                          || is_same_v&lt;remove_cv_t&lt;_Source&gt;, remove_cv_t&lt;_Dest&gt;&gt;
#ifdef __cpp_lib_is_pointer_interconvertible
                                                          || is_pointer_interconvertible_base_of_v&lt;_Dest, _Source&gt;
#endif // __cpp_lib_is_pointer_interconvertible
    ;

template &lt;class _Source, class _Dest, class _SourceRef, class _DestRef&gt;
struct _Trivial_cat {
    using _USource = _Unwrap_enum_t&lt;_Source&gt;;
    using _UDest   = _Unwrap_enum_t&lt;_Dest&gt;;

    static constexpr bool _Same_size_and_compatible =
        sizeof(_Source) == sizeof(_Dest)
        // If _UDest is bool, _USource also needs to be bool
        // Conversion from non-bool =&gt; non-bool | bool =&gt; bool | bool =&gt; non-bool is fine.
        // Conversion from non-bool =&gt; bool is not fine.
        &amp;&amp; is_same_v&lt;bool, _USource&gt; &gt;= is_same_v&lt;bool, _UDest&gt;
        &amp;&amp; (is_same_v&lt;_USource, _UDest&gt; || (is_integral_v&lt;_USource&gt; &amp;&amp; is_integral_v&lt;_UDest&gt;)
            || (is_floating_point_v&lt;_USource&gt; &amp;&amp; is_floating_point_v&lt;_UDest&gt;) );

    static constexpr bool _Bitcopy_constructible =
        _Same_size_and_compatible &amp;&amp; is_trivially_constructible_v&lt;_Dest, _SourceRef&gt;;

    static constexpr bool _Bitcopy_assignable =
        _Same_size_and_compatible &amp;&amp; is_trivially_assignable_v&lt;_DestRef, _SourceRef&gt;;
};

template &lt;class _Source, class _Dest, class _SourceRef, class _DestRef&gt;
struct _Trivial_cat&lt;_Source*, _Dest*, _SourceRef, _DestRef&gt; {
    static constexpr bool _Bitcopy_constructible =
        _Is_pointer_address_convertible&lt;_Source, _Dest&gt; &amp;&amp; is_trivially_constructible_v&lt;_Dest*, _SourceRef&gt;;

    static constexpr bool _Bitcopy_assignable =
        _Is_pointer_address_convertible&lt;_Source, _Dest&gt; &amp;&amp; is_trivially_assignable_v&lt;_DestRef, _SourceRef&gt;;
};

struct _False_trivial_cat {
    static constexpr bool _Bitcopy_constructible = false;
    static constexpr bool _Bitcopy_assignable    = false;
};

template &lt;class _SourceIt, class _DestIt,
    bool _Are_contiguous = _Iterators_are_contiguous&lt;_SourceIt, _DestIt&gt; //
                        &amp;&amp; !_Iterator_is_volatile&lt;_SourceIt&gt; &amp;&amp; !_Iterator_is_volatile&lt;_DestIt&gt;&gt;
struct _Iter_move_cat : _Trivial_cat&lt;_Iter_value_t&lt;_SourceIt&gt;, _Iter_value_t&lt;_DestIt&gt;,
                            remove_reference_t&lt;_Iter_ref_t&lt;_SourceIt&gt;&gt;&amp;&amp;, _Iter_ref_t&lt;_DestIt&gt;&gt; {};

template &lt;class _SourceIt, class _DestIt&gt;
struct _Iter_move_cat&lt;_SourceIt, _DestIt, false&gt; : _False_trivial_cat {};

template &lt;class _SourceIt, class _DestIt&gt;
struct _Iter_move_cat&lt;move_iterator&lt;_SourceIt&gt;, _DestIt, false&gt; : _Iter_move_cat&lt;_SourceIt, _DestIt&gt; {};

template &lt;class _SourceIt, class _DestIt,
    bool _Are_contiguous = _Iterators_are_contiguous&lt;_SourceIt, _DestIt&gt; //
                        &amp;&amp; !_Iterator_is_volatile&lt;_SourceIt&gt; &amp;&amp; !_Iterator_is_volatile&lt;_DestIt&gt;&gt;
struct _Iter_copy_cat
    : _Trivial_cat&lt;_Iter_value_t&lt;_SourceIt&gt;, _Iter_value_t&lt;_DestIt&gt;, _Iter_ref_t&lt;_SourceIt&gt;, _Iter_ref_t&lt;_DestIt&gt;&gt; {};

template &lt;class _SourceIt, class _DestIt&gt;
struct _Iter_copy_cat&lt;_SourceIt, _DestIt, false&gt; : _False_trivial_cat {};

template &lt;class _SourceIt, class _DestIt&gt;
struct _Iter_copy_cat&lt;move_iterator&lt;_SourceIt&gt;, _DestIt, false&gt; : _Iter_move_cat&lt;_SourceIt, _DestIt&gt; {};

template &lt;class _Iter1, class _Sent1, class _Iter2&gt;
_CONSTEXPR20 void _Verify_ranges_do_not_overlap(const _Iter1&amp; _First1, const _Sent1&amp; _Last1, const _Iter2&amp; _First2) {
#if _ITERATOR_DEBUG_LEVEL == 2
    if constexpr (_Iterators_are_contiguous&lt;_Iter1, _Iter2&gt;
#ifdef __cpp_lib_concepts
                  &amp;&amp; sized_sentinel_for&lt;_Sent1, _Iter1&gt;
#endif // __cpp_lib_concepts
    ) {
#if _HAS_CXX20
        if (_STD is_constant_evaluated()) {
            return;
        }
#endif // _HAS_CXX20

        const auto _Offset     = _Last1 - _First1;
        const auto _Ptr1Offset = _Offset * sizeof(*_To_address(_First1));
        const auto _Ptr2Offset = _Offset * sizeof(*_To_address(_First2));
        // This cast to `cv char*` allows us to compare pointers to distinct types,
        // in case one range provides storage for the other.
        const auto _PtrFirst1 = reinterpret_cast&lt;const volatile char*&gt;(_To_address(_First1));
        const auto _PtrLast1  = _PtrFirst1 + _Ptr1Offset;
        const auto _PtrFirst2 = reinterpret_cast&lt;const volatile char*&gt;(_To_address(_First2));
        const auto _PtrLast2  = _PtrFirst2 + _Ptr2Offset;
        _STL_VERIFY(_PtrLast1 &lt;= _PtrFirst2 || _PtrLast2 &lt;= _PtrFirst1, "ranges should not overlap each other");
    }
#else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 / _ITERATOR_DEBUG_LEVEL != 2 vvv
    (void) _First1;
    (void) _Last1;
    (void) _First2;
#endif // _ITERATOR_DEBUG_LEVEL != 2 ^^^
}

template &lt;class _CtgIt, class _OutCtgIt&gt;
_OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {
    auto _FirstPtr              = _To_address(_First);
    auto _LastPtr               = _To_address(_Last);
    auto _DestPtr               = _To_address(_Dest);
    const char* const _First_ch = const_cast&lt;const char*&gt;(reinterpret_cast&lt;const volatile char*&gt;(_FirstPtr));
    const char* const _Last_ch  = const_cast&lt;const char*&gt;(reinterpret_cast&lt;const volatile char*&gt;(_LastPtr));
    char* const _Dest_ch        = const_cast&lt;char*&gt;(reinterpret_cast&lt;const volatile char*&gt;(_DestPtr));
    const auto _Count           = static_cast&lt;size_t&gt;(_Last_ch - _First_ch);
    _CSTD memmove(_Dest_ch, _First_ch, _Count);
    if constexpr (is_pointer_v&lt;_OutCtgIt&gt;) {
        return reinterpret_cast&lt;_OutCtgIt&gt;(_Dest_ch + _Count);
    } else {
        return _Dest + (_LastPtr - _FirstPtr);
    }
}

template &lt;class _CtgIt, class _OutCtgIt&gt;
_OutCtgIt _Copy_memmove_n(_CtgIt _First, const size_t _Count, _OutCtgIt _Dest) {
    const auto _Result = _Copy_memmove(_First, _First + _Count, _Dest);
    if constexpr (is_pointer_v&lt;_OutCtgIt&gt;) {
        return _Result;
    } else { // _Result is unused so the compiler can optimize it away
        return _Dest + static_cast&lt;_Iter_diff_t&lt;_OutCtgIt&gt;&gt;(_Count);
    }
}

template &lt;class _It, bool _RequiresMutable = false&gt;
_INLINE_VAR constexpr bool _Is_vb_iterator = false;

template &lt;class _InIt, class _SizeTy, class _OutIt&gt;
_CONSTEXPR20 _OutIt _Copy_n_unchecked4(_InIt _First, _SizeTy _Count, _OutIt _Dest) {
    // copy _First + [0, _Count) to _Dest + [0, _Count), returning _Dest + _Count
    // note: has callers outside the copy family
#ifdef __cpp_lib_concepts
    _STL_INTERNAL_STATIC_ASSERT(_Integer_like&lt;_SizeTy&gt;);
#endif // __cpp_lib_concepts

    if constexpr (_Iter_copy_cat&lt;_InIt, _OutIt&gt;::_Bitcopy_assignable) {
#if _HAS_CXX20
        if (!_STD is_constant_evaluated())
#endif // _HAS_CXX20
        {
            return _Copy_memmove_n(_First, static_cast&lt;size_t&gt;(_Count), _Dest);
        }
    }

    for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {
        *_Dest = *_First;
    }

    return _Dest;
}

template &lt;class _InIt, class _Sent, class _OutIt&gt;
using _Sent_copy_cat = conditional_t&lt;
#ifdef __cpp_lib_concepts
    is_same_v&lt;_Sent, _InIt&gt; || sized_sentinel_for&lt;_Sent, _InIt&gt;,
#else // ^^^ Concepts support / no Concepts vvv
    is_same_v&lt;_Sent, _InIt&gt;,
#endif // ^^^ no Concepts ^^^
    _Iter_copy_cat&lt;_InIt, _OutIt&gt;, _False_trivial_cat&gt;;

template &lt;class _InIt, class _Sent, class _OutIt&gt;
_CONSTEXPR20 _OutIt _Copy_unchecked(_InIt _First, _Sent _Last, _OutIt _Dest) {
    // copy [_First, _Last) to [_Dest, ...)
    // note: _Copy_unchecked has callers other than the copy family
    if constexpr (_Sent_copy_cat&lt;_InIt, _Sent, _OutIt&gt;::_Bitcopy_assignable) {
#if _HAS_CXX20
        if (!_STD is_constant_evaluated())
#endif // _HAS_CXX20
        {
#ifdef __cpp_lib_concepts
            if constexpr (is_same_v&lt;_InIt, _Sent&gt;)
#endif // __cpp_lib_concepts
            {
                return _Copy_memmove(_First, _Last, _Dest);
            }
#ifdef __cpp_lib_concepts
            else {
                return _Copy_memmove_n(_First, static_cast&lt;size_t&gt;(_Last - _First), _Dest);
            }
#endif // __cpp_lib_concepts
        }
    }

    for (; _First != _Last; ++_Dest, (void) ++_First) {
        *_Dest = *_First;
    }

    return _Dest;
}

_EXPORT_STD template &lt;class _InIt, class _OutIt&gt;
_CONSTEXPR20 _OutIt copy(_InIt _First, _InIt _Last, _OutIt _Dest) { // copy [_First, _Last) to [_Dest, ...)
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);
    const auto _UDest  = _Get_unwrapped_n(_Dest, _Idl_distance&lt;_InIt&gt;(_UFirst, _ULast));
    _Seek_wrapped(_Dest, _STD _Copy_unchecked(_UFirst, _ULast, _UDest));
    return _Dest;
}

#if _HAS_CXX17
_EXPORT_STD template &lt;class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t&lt;_ExPo&gt; = 0&gt;
_FwdIt2 copy(_ExPo&amp;&amp;, _FwdIt1 _First, _FwdIt1 _Last, _FwdIt2 _Dest) noexcept /* terminates */ {
    // copy [_First, _Last) to [_Dest, ...)
    // not parallelized as benchmarks show it isn't worth it
    _REQUIRE_PARALLEL_ITERATOR(_FwdIt1);
    _REQUIRE_CPP17_MUTABLE_ITERATOR(_FwdIt2);
    return _STD copy(_First, _Last, _Dest);
}
#endif // _HAS_CXX17

#ifdef __cpp_lib_concepts
namespace ranges {
    template &lt;class _To, class _From&gt;
    concept _Convertible_from = convertible_to&lt;_From, _To&gt;;

    _EXPORT_STD template &lt;class _In, class _Out&gt;
    struct in_out_result {
        /* [[no_unique_address]] */ _In in;
        /* [[no_unique_address]] */ _Out out;

        template &lt;_Convertible_from&lt;const _In&amp;&gt; _IIn, _Convertible_from&lt;const _Out&amp;&gt; _OOut&gt;
        constexpr operator in_out_result&lt;_IIn, _OOut&gt;() const&amp; {
            return {in, out};
        }

        template &lt;_Convertible_from&lt;_In&gt; _IIn, _Convertible_from&lt;_Out&gt; _OOut&gt;
        constexpr operator in_out_result&lt;_IIn, _OOut&gt;() &amp;&amp; {
            return {_STD move(in), _STD move(out)};
        }
    };

    template &lt;forward_iterator _It, class _Se&gt;
        requires sentinel_for&lt;remove_cvref_t&lt;_Se&gt;, _It&gt;
    _NODISCARD constexpr _Unwrap_iter_t&lt;_It, _Se&gt; _Get_final_iterator_unwrapped(
        const _Unwrap_iter_t&lt;_It, _Se&gt;&amp; _UFirst, _Se&amp;&amp; _Last) {
        // find the iterator in [_UFirst, _Unwrap_sent&lt;_It&gt;(_Last)) which equals _Unwrap_sent&lt;_It&gt;(_Last)
        // [possibly O(N)]
        if constexpr (is_same_v&lt;_Unwrap_iter_t&lt;_It, _Se&gt;, _Unwrap_sent_t&lt;_Se, _It&gt;&gt;) {
            return _Unwrap_sent&lt;_It&gt;(_STD forward&lt;_Se&gt;(_Last));
        } else {
            return _RANGES next(_UFirst, _Unwrap_sent&lt;_It&gt;(_STD forward&lt;_Se&gt;(_Last)));
        }
    }

    template &lt;forward_range _Rng&gt;
    _NODISCARD constexpr auto _Get_final_iterator_unwrapped(_Rng&amp; _Range) {
        // find the (unwrapped) iterator in _Range which equals _Uend(_Range) [possibly O(N)]
        if constexpr (common_range&lt;_Rng&gt;) {
            if constexpr (same_as&lt;decltype(_Uend(_Range)), _Unwrapped_iterator_t&lt;_Rng&gt;&gt;) {
                return _Uend(_Range);
            } else {
                return _Unwrap_range_sent&lt;_Rng&gt;(_RANGES end(_Range));
            }
        } else if constexpr (sized_range&lt;_Rng&gt;) {
            return _RANGES next(_Ubegin(_Range), _RANGES distance(_Range));
        } else {
            return _RANGES next(_Ubegin(_Range), _Uend(_Range));
        }
    }

    template &lt;forward_range _Rng&gt;
    _NODISCARD constexpr auto _Get_final_iterator_unwrapped(_Rng&amp; _Range, const _Unwrapped_iterator_t&lt;_Rng&gt;&amp; _Mid) {
        // find the (unwrapped) iterator in _Range which equals _Uend(_Range) [possibly O(N)]
        // Pre: [ranges::begin(_Range), _Mid) and [_Mid, ranges::end(_Range)) denote ranges
        if constexpr (common_range&lt;_Rng&gt;) {
            if constexpr (same_as&lt;decltype(_Uend(_Range)), _Unwrapped_iterator_t&lt;_Rng&gt;&gt;) {
                return _Uend(_Range);
            } else {
                return _Unwrap_range_sent&lt;_Rng&gt;(_RANGES end(_Range));
            }
        } else if constexpr (sized_range&lt;_Rng&gt;) {
            const auto _Dist = _RANGES distance(_Range);
            if constexpr (sized_sentinel_for&lt;_Unwrapped_iterator_t&lt;_Rng&gt;, _Unwrapped_iterator_t&lt;_Rng&gt;&gt;) {
                return _RANGES next(_Mid, _Dist - (_Mid - _Ubegin(_Range)));
            } else {
                return _RANGES next(_Ubegin(_Range), _Dist);
            }
        } else {
            return _RANGES next(_Mid, _Uend(_Range));
        }
    }

#if _HAS_CXX23
    _EXPORT_STD template &lt;class _Out, class _Ty&gt;
    struct out_value_result {
        /* [[no_unique_address]] */ _Out out;
        /* [[no_unique_address]] */ _Ty value;

        template &lt;_Convertible_from&lt;const _Out&amp;&gt; _OOut, _Convertible_from&lt;const _Ty&amp;&gt; _TTy&gt;
        constexpr operator out_value_result&lt;_OOut, _TTy&gt;() const&amp; {
            return {out, value};
        }

        template &lt;_Convertible_from&lt;_Out&gt; _OOut, _Convertible_from&lt;_Ty&gt; _TTy&gt;
        constexpr operator out_value_result&lt;_OOut, _TTy&gt;() &amp;&amp; {
            return {_STD move(out), _STD move(value)};
        }
    };
#endif // _HAS_CXX23

    _EXPORT_STD template &lt;class _In, class _Out&gt;
    using copy_result = in_out_result&lt;_In, _Out&gt;;

    template &lt;input_iterator _It, sentinel_for&lt;_It&gt; _Se, weakly_incrementable _Out&gt;
        requires indirectly_copyable&lt;_It, _Out&gt;
    _NODISCARD constexpr copy_result&lt;_It, _Out&gt; _Copy_unchecked(_It _First, _Se _Last, _Out _Result) {
        if constexpr (_Sent_copy_cat&lt;_It, _Se, _Out&gt;::_Bitcopy_assignable) {
            if (!_STD is_constant_evaluated()) {
                if constexpr (is_same_v&lt;_It, _Se&gt;) {
                    _Result = _Copy_memmove(_STD move(_First), _Last, _STD move(_Result));
                    return {_STD move(_Last), _STD move(_Result)};
                } else {
                    const auto _Count = static_cast&lt;size_t&gt;(_Last - _First);
                    _Result           = _Copy_memmove_n(_First, _Count, _STD move(_Result));
                    _First += _Count;
                    return {_STD move(_First), _STD move(_Result)};
                }
            }
        }

        for (; _First != _Last; ++_First, (void) ++_Result) {
            *_Result = *_First;
        }

        return {_STD move(_First), _STD move(_Result)};
    }

    class _Copy_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template &lt;input_iterator _It, sentinel_for&lt;_It&gt; _Se, weakly_incrementable _Out&gt;
            requires indirectly_copyable&lt;_It, _Out&gt;
        constexpr copy_result&lt;_It, _Out&gt; operator()(_It _First, _Se _Last, _Out _Result) const {
            _Adl_verify_range(_First, _Last);
            auto _UResult = _RANGES _Copy_unchecked(
                _Unwrap_iter&lt;_Se&gt;(_STD move(_First)), _Unwrap_sent&lt;_It&gt;(_STD move(_Last)), _STD move(_Result));
            _Seek_wrapped(_First, _STD move(_UResult.in));
            return {_STD move(_First), _STD move(_UResult.out)};
        }

        template &lt;input_range _Rng, weakly_incrementable _Out&gt;
            requires indirectly_copyable&lt;iterator_t&lt;_Rng&gt;, _Out&gt;
        constexpr copy_result&lt;borrowed_iterator_t&lt;_Rng&gt;, _Out&gt; operator()(_Rng&amp;&amp; _Range, _Out _Result) const {
            auto _First = _RANGES begin(_Range);
            auto _UResult =
                _RANGES _Copy_unchecked(_Unwrap_range_iter&lt;_Rng&gt;(_STD move(_First)), _Uend(_Range), _STD move(_Result));
            _Seek_wrapped(_First, _STD move(_UResult.in));
            return {_STD move(_First), _STD move(_UResult.out)};
        }
    };

    _EXPORT_STD inline constexpr _Copy_fn copy{_Not_quite_object::_Construct_tag {}};
} // namespace ranges
#endif // __cpp_lib_concepts

_EXPORT_STD template &lt;class _InIt, class _Diff, class _OutIt&gt;
_CONSTEXPR20 _OutIt copy_n(_InIt _First, _Diff _Count_raw, _OutIt _Dest) {
    // copy [_First, _First + _Count) to [_Dest, ...)
    _Algorithm_int_t&lt;_Diff&gt; _Count = _Count_raw;
    if (0 &lt; _Count) {
        auto _UFirst = _Get_unwrapped_n(_First, _Count);
        auto _UDest  = _Get_unwrapped_n(_Dest, _Count);
        if constexpr (_Iter_copy_cat&lt;decltype(_UFirst), decltype(_UDest)&gt;::_Bitcopy_assignable) {
#if _HAS_CXX20
            if (!_STD is_constant_evaluated())
#endif // _HAS_CXX20
            {
                _UDest = _Copy_memmove_n(_UFirst, static_cast&lt;size_t&gt;(_Count), _UDest);
                _Seek_wrapped(_Dest, _UDest);
                return _Dest;
            }
        }

        for (;;) {
            *_UDest = *_UFirst;
            ++_UDest;
            --_Count;
            if (_Count == 0) { // note that we avoid an extra ++_First here to allow istream_iterator to work,
                               // see LWG-2471
                break;
            }

            ++_UFirst;
        }

        _Seek_wrapped(_Dest, _UDest);
    }

    return _Dest;
}

#if _HAS_CXX17
_EXPORT_STD template &lt;class _ExPo, class _FwdIt1, class _Diff, class _FwdIt2, _Enable_if_execution_policy_t&lt;_ExPo&gt; = 0&gt;
_FwdIt2 copy_n(_ExPo&amp;&amp;, _FwdIt1 _First, _Diff _Count_raw, _FwdIt2 _Dest) noexcept /* terminates */ {
    // copy [_First, _First + _Count) to [_Dest, ...)
    // not parallelized as benchmarks show it isn't worth it
    _REQUIRE_PARALLEL_ITERATOR(_FwdIt1);
    _REQUIRE_CPP17_MUTABLE_ITERATOR(_FwdIt2);
    return _STD copy_n(_First, _Count_raw, _Dest);
}
#endif // _HAS_CXX17

template &lt;class _CtgIt1, class _CtgIt2&gt;
_CtgIt2 _Copy_backward_memmove(_CtgIt1 _First, _CtgIt1 _Last, _CtgIt2 _Dest) {
    // implement copy_backward-like function as memmove
    auto _FirstPtr              = _To_address(_First);
    auto _LastPtr               = _To_address(_Last);
    auto _DestPtr               = _To_address(_Dest);
    const char* const _First_ch = const_cast&lt;const char*&gt;(reinterpret_cast&lt;const volatile char*&gt;(_FirstPtr));
    const char* const _Last_ch  = const_cast&lt;const char*&gt;(reinterpret_cast&lt;const volatile char*&gt;(_LastPtr));
    char* const _Dest_ch        = const_cast&lt;char*&gt;(reinterpret_cast&lt;const volatile char*&gt;(_DestPtr));
    const auto _Count           = static_cast&lt;size_t&gt;(_Last_ch - _First_ch);
    auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);
    if constexpr (is_pointer_v&lt;_CtgIt2&gt;) {
        return static_cast&lt;_CtgIt2&gt;(_Result);
    } else {
        return _Dest - (_LastPtr - _FirstPtr);
    }
}

template &lt;class _BidIt1, class _BidIt2&gt;
_BidIt2 _Copy_backward_memmove(move_iterator&lt;_BidIt1&gt; _First, move_iterator&lt;_BidIt1&gt; _Last, _BidIt2 _Dest) {
    return _Copy_backward_memmove(_First.base(), _Last.base(), _Dest);
}

template &lt;class _BidIt1, class _BidIt2&gt;
_NODISCARD _CONSTEXPR20 _BidIt2 _Copy_backward_unchecked(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {
    // copy [_First, _Last) backwards to [..., _Dest)
    if constexpr (_Iter_copy_cat&lt;_BidIt1, _BidIt2&gt;::_Bitcopy_assignable) {
#if _HAS_CXX20
        if (!_STD is_constant_evaluated())
#endif // _HAS_CXX20
        {
            return _Copy_backward_memmove(_First, _Last, _Dest);
        }
    }

    while (_First != _Last) {
        *--_Dest = *--_Last;
    }

    return _Dest;
}

_EXPORT_STD template &lt;class _BidIt1, class _BidIt2&gt;
_CONSTEXPR20 _BidIt2 copy_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {
    // copy [_First, _Last) backwards to [..., _Dest)
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);
    const auto _UDest  = _Get_unwrapped_n(_Dest, -_Idl_distance&lt;_BidIt1&gt;(_UFirst, _ULast));
    _Seek_wrapped(_Dest, _Copy_backward_unchecked(_UFirst, _ULast, _UDest));
    return _Dest;
}

template &lt;class _InIt, class _OutIt&gt;
_CONSTEXPR20 _OutIt _Move_unchecked(_InIt _First, _InIt _Last, _OutIt _Dest) {
    // move [_First, _Last) to [_Dest, ...)
    // note: _Move_unchecked has callers other than the move family
    if constexpr (_Iter_move_cat&lt;_InIt, _OutIt&gt;::_Bitcopy_assignable) {
#if _HAS_CXX20
        if (!_STD is_constant_evaluated())
#endif // _HAS_CXX20
        {
            return _Copy_memmove(_First, _Last, _Dest);
        }
    }

    for (; _First != _Last; ++_Dest, (void) ++_First) {
        *_Dest = _STD move(*_First);
    }

    return _Dest;
}

_EXPORT_STD template &lt;class _InIt, class _OutIt&gt;
_CONSTEXPR20 _OutIt move(_InIt _First, _InIt _Last, _OutIt _Dest) {
    // move [_First, _Last) to [_Dest, ...)
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);
    const auto _UDest  = _Get_unwrapped_n(_Dest, _Idl_distance&lt;_InIt&gt;(_UFirst, _ULast));
    _Seek_wrapped(_Dest, _STD _Move_unchecked(_UFirst, _ULast, _UDest));
    return _Dest;
}

#if _HAS_CXX17
_EXPORT_STD template &lt;class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t&lt;_ExPo&gt; = 0&gt;
_FwdIt2 move(_ExPo&amp;&amp;, _FwdIt1 _First, _FwdIt1 _Last, _FwdIt2 _Dest) noexcept /* terminates */ {
    // move [_First, _Last) to [_Dest, ...)
    // not parallelized as benchmarks show it isn't worth it
    _REQUIRE_CPP17_MUTABLE_ITERATOR(_FwdIt1);
    _REQUIRE_CPP17_MUTABLE_ITERATOR(_FwdIt2);
    return _STD move(_First, _Last, _Dest);
}
#endif // _HAS_CXX17

template &lt;class _BidIt1, class _BidIt2&gt;
_CONSTEXPR20 _BidIt2 _Move_backward_unchecked(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {
    // move [_First, _Last) backwards to [..., _Dest)
    // note: _Move_backward_unchecked has callers other than the move_backward family
    if constexpr (_Iter_move_cat&lt;_BidIt1, _BidIt2&gt;::_Bitcopy_assignable) {
#if _HAS_CXX20
        if (!_STD is_constant_evaluated())
#endif // _HAS_CXX20
        {
            return _Copy_backward_memmove(_First, _Last, _Dest);
        }
    }

    while (_First != _Last) {
        *--_Dest = _STD move(*--_Last);
    }

    return _Dest;
}

_EXPORT_STD template &lt;class _BidIt1, class _BidIt2&gt;
_CONSTEXPR20 _BidIt2 move_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {
    // move [_First, _Last) backwards to [..., _Dest)
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);
    const auto _UDest  = _Get_unwrapped_n(_Dest, -_Idl_distance&lt;_BidIt1&gt;(_UFirst, _ULast));
    _Seek_wrapped(_Dest, _Move_backward_unchecked(_UFirst, _ULast, _UDest));
    return _Dest;
}


template &lt;class _Ty&gt;
struct _Is_character : false_type {}; // by default, not a character type

template &lt;&gt;
struct _Is_character&lt;char&gt; : true_type {}; // chars are characters

template &lt;&gt;
struct _Is_character&lt;signed char&gt; : true_type {}; // signed chars are also characters

template &lt;&gt;
struct _Is_character&lt;unsigned char&gt; : true_type {}; // unsigned chars are also characters

#ifdef __cpp_char8_t
template &lt;&gt;
struct _Is_character&lt;char8_t&gt; : true_type {}; // UTF-8 code units are sort-of characters
#endif // __cpp_char8_t

template &lt;class _Ty&gt;
struct _Is_character_or_bool : _Is_character&lt;_Ty&gt;::type {};

template &lt;&gt;
struct _Is_character_or_bool&lt;bool&gt; : true_type {};

template &lt;class _Ty&gt;
struct _Is_character_or_byte_or_bool : _Is_character_or_bool&lt;_Ty&gt;::type {};

#ifdef __cpp_lib_byte
template &lt;&gt;
struct _Is_character_or_byte_or_bool&lt;byte&gt; : true_type {};
#endif // __cpp_lib_byte

// _Fill_memset_is_safe determines if _FwdIt and _Ty are eligible for memset optimization in fill.
// Need to explicitly test for volatile because _Unwrap_enum_t discards qualifiers.
template &lt;class _FwdIt, class _Ty, bool = _Iterator_is_contiguous&lt;_FwdIt&gt;&gt;
_INLINE_VAR constexpr bool _Fill_memset_is_safe = conjunction_v&lt;is_scalar&lt;_Ty&gt;,
    _Is_character_or_byte_or_bool&lt;_Unwrap_enum_t&lt;remove_reference_t&lt;_Iter_ref_t&lt;_FwdIt&gt;&gt;&gt;&gt;,
    negation&lt;is_volatile&lt;remove_reference_t&lt;_Iter_ref_t&lt;_FwdIt&gt;&gt;&gt;&gt;, is_assignable&lt;_Iter_ref_t&lt;_FwdIt&gt;, const _Ty&amp;&gt;&gt;;

template &lt;class _FwdIt, class _Ty&gt;
_INLINE_VAR constexpr bool _Fill_memset_is_safe&lt;_FwdIt, _Ty, false&gt; = false;

template &lt;class _FwdIt, class _Ty, bool = _Iterator_is_contiguous&lt;_FwdIt&gt;&gt;
_INLINE_VAR constexpr bool _Fill_zero_memset_is_safe =
    conjunction_v&lt;is_scalar&lt;_Ty&gt;, is_scalar&lt;_Iter_value_t&lt;_FwdIt&gt;&gt;, negation&lt;is_member_pointer&lt;_Iter_value_t&lt;_FwdIt&gt;&gt;&gt;,
        negation&lt;is_volatile&lt;remove_reference_t&lt;_Iter_ref_t&lt;_FwdIt&gt;&gt;&gt;&gt;, is_assignable&lt;_Iter_ref_t&lt;_FwdIt&gt;, const _Ty&amp;&gt;&gt;;

template &lt;class _FwdIt, class _Ty&gt;
_INLINE_VAR constexpr bool _Fill_zero_memset_is_safe&lt;_FwdIt, _Ty, false&gt; = false;

template &lt;class _CtgIt, class _Ty&gt;
void _Fill_memset(_CtgIt _Dest, const _Ty _Val, const size_t _Count) {
    // implicitly convert (a cast would suppress warnings); also handles _Iter_value_t&lt;_CtgIt&gt; being bool
    _Iter_value_t&lt;_CtgIt&gt; _Dest_val = _Val;
    _CSTD memset(_To_address(_Dest), static_cast&lt;unsigned char&gt;(_Dest_val), _Count);
}

template &lt;class _CtgIt&gt;
void _Fill_zero_memset(_CtgIt _Dest, const size_t _Count) {
    _CSTD memset(_To_address(_Dest), 0, _Count * sizeof(_Iter_value_t&lt;_CtgIt&gt;));
}

template &lt;class _Ty&gt;
_NODISCARD bool _Is_all_bits_zero(const _Ty&amp; _Val) {
    // checks if scalar type has all bits set to zero
    _STL_INTERNAL_STATIC_ASSERT(is_scalar_v&lt;_Ty&gt; &amp;&amp; !is_member_pointer_v&lt;_Ty&gt;);
    if constexpr (is_same_v&lt;_Ty, nullptr_t&gt;) {
        return true;
    } else {
        constexpr _Ty _Zero{};
        return _CSTD memcmp(&amp;_Val, &amp;_Zero, sizeof(_Ty)) == 0;
    }
}

_EXPORT_STD template &lt;class _FwdIt, class _Ty&gt;
_CONSTEXPR20 void fill(const _FwdIt _First, const _FwdIt _Last, const _Ty&amp; _Val) {
    // copy _Val through [_First, _Last)
    _Adl_verify_range(_First, _Last);
    if constexpr (_Is_vb_iterator&lt;_FwdIt, true&gt;) {
        _Fill_vbool(_First, _Last, _Val);
    } else {
        auto _UFirst      = _Get_unwrapped(_First);
        const auto _ULast = _Get_unwrapped(_Last);
#if _HAS_CXX20
        if (!_STD is_constant_evaluated())
#endif // _HAS_CXX20
        {
            if constexpr (_Fill_memset_is_safe&lt;decltype(_UFirst), _Ty&gt;) {
                _Fill_memset(_UFirst, _Val, static_cast&lt;size_t&gt;(_ULast - _UFirst));
                return;
            } else if constexpr (_Fill_zero_memset_is_safe&lt;decltype(_UFirst), _Ty&gt;) {
                if (_Is_all_bits_zero(_Val)) {
                    _Fill_zero_memset(_UFirst, static_cast&lt;size_t&gt;(_ULast - _UFirst));
                    return;
                }
            }
        }

        for (; _UFirst != _ULast; ++_UFirst) {
            *_UFirst = _Val;
        }
    }
}

#if _HAS_CXX17
_EXPORT_STD template &lt;class _ExPo, class _FwdIt, class _Ty, _Enable_if_execution_policy_t&lt;_ExPo&gt; = 0&gt;
void fill(_ExPo&amp;&amp;, _FwdIt _First, _FwdIt _Last, const _Ty&amp; _Val) noexcept /* terminates */ {
    // copy _Val through [_First, _Last)
    // not parallelized as benchmarks show it isn't worth it
    _REQUIRE_CPP17_MUTABLE_ITERATOR(_FwdIt);
    return _STD fill(_First, _Last, _Val);
}
#endif // _HAS_CXX17

_EXPORT_STD template &lt;class _OutIt, class _Diff, class _Ty&gt;
_CONSTEXPR20 _OutIt fill_n(_OutIt _Dest, const _Diff _Count_raw, const _Ty&amp; _Val) {
    // copy _Val _Count times through [_Dest, ...)
    _Algorithm_int_t&lt;_Diff&gt; _Count = _Count_raw;
    if (0 &lt; _Count) {
        if constexpr (_Is_vb_iterator&lt;_OutIt, true&gt;) {
            const auto _Last = _Dest + static_cast&lt;typename _OutIt::difference_type&gt;(_Count);
            _Fill_vbool(_Dest, _Last, _Val);
            return _Last;
        } else {
            auto _UDest = _Get_unwrapped_n(_Dest, _Count);
#if _HAS_CXX20
            if (!_STD is_constant_evaluated())
#endif // _HAS_CXX20
            {
                if constexpr (_Fill_memset_is_safe&lt;decltype(_UDest), _Ty&gt;) {
                    _Fill_memset(_UDest, _Val, static_cast&lt;size_t&gt;(_Count));
                    _Seek_wrapped(_Dest, _UDest + _Count);
                    return _Dest;
                } else if constexpr (_Fill_zero_memset_is_safe&lt;decltype(_UDest), _Ty&gt;) {
                    if (_Is_all_bits_zero(_Val)) {
                        _Fill_zero_memset(_UDest, static_cast&lt;size_t&gt;(_Count));
                        _Seek_wrapped(_Dest, _UDest + _Count);
                        return _Dest;
                    }
                }
            }

            for (; 0 &lt; _Count; --_Count, (void) ++_UDest) {
                *_UDest = _Val;
            }

            _Seek_wrapped(_Dest, _UDest);
        }
    }
    return _Dest;
}

#if _HAS_CXX17
_EXPORT_STD template &lt;class _ExPo, class _FwdIt, class _Diff, class _Ty, _Enable_if_execution_policy_t&lt;_ExPo&gt; = 0&gt;
_FwdIt fill_n(_ExPo&amp;&amp;, _FwdIt _Dest, _Diff _Count_raw, const _Ty&amp; _Val) noexcept /* terminates */ {
    // copy _Val _Count times through [_Dest, ...)
    // not parallelized as benchmarks show it isn't worth it
    _REQUIRE_CPP17_MUTABLE_ITERATOR(_FwdIt);
    return _STD fill_n(_Dest, _Count_raw, _Val);
}
#endif // _HAS_CXX17

#ifdef __cpp_lib_concepts
namespace ranges {
    class _Fill_n_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template &lt;class _Ty, output_iterator&lt;const _Ty&amp;&gt; _It&gt;
        constexpr _It operator()(_It _First, iter_difference_t&lt;_It&gt; _Count, const _Ty&amp; _Value) const {
            if (_Count &gt; 0) {
                auto _UFirst = _Get_unwrapped_n(_STD move(_First), _Count);
                if (!_STD is_constant_evaluated()) {
                    if constexpr (_Fill_memset_is_safe&lt;decltype(_UFirst), _Ty&gt;) {
                        _Fill_memset(_UFirst, _Value, static_cast&lt;size_t&gt;(_Count));
                        _Seek_wrapped(_First, _UFirst + _Count); // no need to move since _UFirst is a pointer
                        return _First;
                    } else if constexpr (_Fill_zero_memset_is_safe&lt;decltype(_UFirst), _Ty&gt;) {
                        if (_Is_all_bits_zero(_Value)) {
                            _Fill_zero_memset(_UFirst, static_cast&lt;size_t&gt;(_Count));
                            _Seek_wrapped(_First, _UFirst + _Count); // no need to move since _UFirst is a pointer
                            return _First;
                        }
                    }
                }

                for (; _Count &gt; 0; ++_UFirst, (void) --_Count) {
                    *_UFirst = _Value;
                }

                _Seek_wrapped(_First, _STD move(_UFirst));
            }

            return _First;
        }
    };

    _EXPORT_STD inline constexpr _Fill_n_fn fill_n{_Not_quite_object::_Construct_tag {}};
} // namespace ranges
#endif // __cpp_lib_concepts

template &lt;class _Ty1, class _Ty2, class = void&gt;
_INLINE_VAR constexpr bool _Can_compare_with_operator_equal = false;

template &lt;class _Ty1, class _Ty2&gt;
_INLINE_VAR constexpr bool
    _Can_compare_with_operator_equal&lt;_Ty1, _Ty2, void_t&lt;decltype(_STD declval&lt;_Ty1&amp;&gt;() == _STD declval&lt;_Ty2&amp;&gt;())&gt;&gt; =
        true;

template &lt;class _Ty1, class _Ty2&gt;
_INLINE_VAR constexpr bool _Is_pointer_address_comparable =
    _Can_compare_with_operator_equal&lt;_Ty1*, _Ty2*&gt;
    &amp;&amp; (_Is_pointer_address_convertible&lt;_Ty1, _Ty2&gt; || _Is_pointer_address_convertible&lt;_Ty2, _Ty1&gt;);

// _Can_memcmp_elements&lt;_Elem1, _Elem2&gt; reports whether `_Elem1 == _Elem2` can be optimized to memcmp.
// Here, _Elem1 and _Elem2 aren't top-level const, because we remove_const_t before using _Can_memcmp_elements.

// Integral types are eligible for memcmp in very specific cases.
// * They must be the same size. (`int == long` is eligible; `int == long long` isn't.)
// * The usual arithmetic conversions must preserve bit patterns. (This is true for `int == unsigned int`,
//   but false for `short == unsigned short`.)
#pragma warning(push)
#pragma warning(disable : 4806) // no value of type 'bool' promoted to type 'char' can equal the given constant
template &lt;class _Elem1, class _Elem2,
    bool = sizeof(_Elem1) == sizeof(_Elem2) &amp;&amp; is_integral_v&lt;_Elem1&gt;&amp;&amp; is_integral_v&lt;_Elem2&gt;&gt;
_INLINE_VAR constexpr bool _Can_memcmp_elements =
    is_same_v&lt;_Elem1, bool&gt; || is_same_v&lt;_Elem2, bool&gt; || static_cast&lt;_Elem1&gt;(-1) == static_cast&lt;_Elem2&gt;(-1);
#pragma warning(pop)

#ifdef __cpp_lib_byte
// Allow memcmping std::byte.
// inline is required here as explicit specializations of variable templates are problematic in C++14.
// However, std::byte is C++17 and above so we are safe.
template &lt;&gt;
inline constexpr bool _Can_memcmp_elements&lt;byte, byte, false&gt; = true;
#endif // __cpp_lib_byte

// Pointer elements are eligible for memcmp when they point to the same type, ignoring cv-qualification.
// This handles pointers to object types, pointers to void, and pointers to function types.
template &lt;class _Ty1, class _Ty2&gt;
_INLINE_VAR constexpr bool _Can_memcmp_elements&lt;_Ty1*, _Ty2*, false&gt; = _Is_pointer_address_comparable&lt;_Ty1, _Ty2&gt;;

template &lt;class _Elem1, class _Elem2&gt;
_INLINE_VAR constexpr bool _Can_memcmp_elements&lt;_Elem1, _Elem2, false&gt; = false;

// _Can_memcmp_elements_with_pred&lt;_Elem1, _Elem2, _Pr&gt; reports whether the memcmp optimization is applicable,
// given contiguously stored elements. (This avoids having to repeat the metaprogramming that finds the element types.)
// _Elem1 and _Elem2 aren't top-level const here.
template &lt;class _Elem1, class _Elem2, class _Pr&gt;
_INLINE_VAR constexpr bool _Can_memcmp_elements_with_pred = false;

// With equal_to&lt;_Elem3&gt; we need to make sure that both _Elem1 and _Elem2 are convertible to _Elem3 without changing
// object representation (we use _Iter_copy_cat for this task) and _Elem3 can be safely memcmp'ed with itself
template &lt;class _Elem1, class _Elem2, class _Elem3&gt;
_INLINE_VAR constexpr bool _Can_memcmp_elements_with_pred&lt;_Elem1, _Elem2, equal_to&lt;_Elem3&gt;&gt; =
    _Iter_copy_cat&lt;_Elem1*, _Elem3*&gt;::_Bitcopy_constructible &amp;&amp; _Iter_copy_cat&lt;_Elem2*, _Elem3*&gt;::_Bitcopy_constructible
    &amp;&amp; _Can_memcmp_elements&lt;remove_cv_t&lt;_Elem3&gt;, remove_cv_t&lt;_Elem3&gt;&gt;;

// equal_to&lt;&gt; is transparent.
template &lt;class _Elem1, class _Elem2&gt;
_INLINE_VAR constexpr bool _Can_memcmp_elements_with_pred&lt;_Elem1, _Elem2, equal_to&lt;&gt;&gt; =
    _Can_memcmp_elements&lt;_Elem1, _Elem2&gt;;

#ifdef __cpp_lib_concepts
// ranges::equal_to is also transparent.
template &lt;class _Elem1, class _Elem2&gt;
_INLINE_VAR constexpr bool _Can_memcmp_elements_with_pred&lt;_Elem1, _Elem2, _RANGES equal_to&gt; =
    _Can_memcmp_elements&lt;_Elem1, _Elem2&gt;;
#endif // __cpp_lib_concepts

// _Equal_memcmp_is_safe&lt;_Iter1, _Iter2, _Pr&gt; reports whether we can activate the memcmp optimization
// for arbitrary iterators and predicates.
// It ignores top-level constness on the iterators and on the elements.
template &lt;class _Iter1, class _Iter2, class _Pr&gt;
_INLINE_VAR constexpr bool _Equal_memcmp_is_safe_helper =
    _Iterators_are_contiguous&lt;_Iter1, _Iter2&gt; //
    &amp;&amp; !_Iterator_is_volatile&lt;_Iter1&gt; &amp;&amp; !_Iterator_is_volatile&lt;_Iter2&gt; //
    &amp;&amp; _Can_memcmp_elements_with_pred&lt;_Iter_value_t&lt;_Iter1&gt;, _Iter_value_t&lt;_Iter2&gt;, _Pr&gt;;

template &lt;class _Iter1, class _Iter2, class _Pr&gt;
_INLINE_VAR constexpr bool _Equal_memcmp_is_safe =
    _Equal_memcmp_is_safe_helper&lt;remove_const_t&lt;_Iter1&gt;, remove_const_t&lt;_Iter2&gt;, _Pr&gt;;

template &lt;class _CtgIt1, class _CtgIt2&gt;
_NODISCARD int _Memcmp_ranges(_CtgIt1 _First1, _CtgIt1 _Last1, _CtgIt2 _First2) {
    _STL_INTERNAL_STATIC_ASSERT(sizeof(_Iter_value_t&lt;_CtgIt1&gt;) == sizeof(_Iter_value_t&lt;_CtgIt2&gt;));
    const auto _First1_ch = reinterpret_cast&lt;const char*&gt;(_To_address(_First1));
    const auto _Last1_ch  = reinterpret_cast&lt;const char*&gt;(_To_address(_Last1));
    const auto _First2_ch = reinterpret_cast&lt;const char*&gt;(_To_address(_First2));
    return _CSTD memcmp(_First1_ch, _First2_ch, static_cast&lt;size_t&gt;(_Last1_ch - _First1_ch));
}

template &lt;class _CtgIt1, class _CtgIt2&gt;
_NODISCARD int _Memcmp_count(_CtgIt1 _First1, _CtgIt2 _First2, const size_t _Count) {
    _STL_INTERNAL_STATIC_ASSERT(sizeof(_Iter_value_t&lt;_CtgIt1&gt;) == sizeof(_Iter_value_t&lt;_CtgIt2&gt;));
    const auto _First1_ch = reinterpret_cast&lt;const char*&gt;(_To_address(_First1));
    const auto _First2_ch = reinterpret_cast&lt;const char*&gt;(_To_address(_First2));
    return _CSTD memcmp(_First1_ch, _First2_ch, _Count * sizeof(_Iter_value_t&lt;_CtgIt1&gt;));
}

_EXPORT_STD template &lt;class _InIt1, class _InIt2, class _Pr&gt;
_NODISCARD _CONSTEXPR20 bool equal(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, _Pr _Pred) {
    // compare [_First1, _Last1) to [_First2, ...)
    _Adl_verify_range(_First1, _Last1);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped_n(_First2, _Idl_distance&lt;_InIt1&gt;(_UFirst1, _ULast1));
    if constexpr (_Equal_memcmp_is_safe&lt;decltype(_UFirst1), decltype(_UFirst2), _Pr&gt;) {
#if _HAS_CXX20
        if (!_STD is_constant_evaluated())
#endif // _HAS_CXX20
        {
            return _Memcmp_ranges(_UFirst1, _ULast1, _UFirst2) == 0;
        }
    }

    for (; _UFirst1 != _ULast1; ++_UFirst1, (void) ++_UFirst2) {
        if (!_Pred(*_UFirst1, *_UFirst2)) {
            return false;
        }
    }

    return true;
}

#if _HAS_CXX17
_EXPORT_STD template &lt;class _ExPo, class _FwdIt1, class _FwdIt2, class _Pr, _Enable_if_execution_policy_t&lt;_ExPo&gt; = 0&gt;
_NODISCARD bool equal(_ExPo&amp;&amp; _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2,
    _Pr _Pred) noexcept; // terminates
#endif // _HAS_CXX17

_EXPORT_STD template &lt;class _InIt1, class _InIt2&gt;
_NODISCARD _CONSTEXPR20 bool equal(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2) {
    // compare [_First1, _Last1) to [_First2, ...)
    return _STD equal(_First1, _Last1, _First2, equal_to&lt;&gt;{});
}

#if _HAS_CXX17
_EXPORT_STD template &lt;class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t&lt;_ExPo&gt; = 0&gt;
_NODISCARD bool equal(_ExPo&amp;&amp; _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2) noexcept
/* terminates */ {
    // compare [_First1, _Last1) to [_First2, ...)
    return _STD equal(_STD forward&lt;_ExPo&gt;(_Exec), _First1, _Last1, _First2, equal_to{});
}
#endif // _HAS_CXX17

_EXPORT_STD template &lt;class _InIt1, class _InIt2, class _Pr&gt;
_NODISCARD _CONSTEXPR20 bool equal(
    const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2, _Pr _Pred) {
    // compare [_First1, _Last1) to [_First2, _Last2)
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped(_First2);
    const auto _ULast2 = _Get_unwrapped(_Last2);
    if constexpr (_Is_ranges_random_iter_v&lt;_InIt1&gt; &amp;&amp; _Is_ranges_random_iter_v&lt;_InIt2&gt;) {
        if (_ULast1 - _UFirst1 != _ULast2 - _UFirst2) {
            return false;
        }

        return _STD equal(_UFirst1, _ULast1, _UFirst2, _Pass_fn(_Pred));
    } else {
        for (;;) {
            if (_UFirst1 == _ULast1) {
                return _UFirst2 == _ULast2;
            }

            if (_UFirst2 == _ULast2) {
                return false;
            }

            if (!_Pred(*_UFirst1, *_UFirst2)) {
                return false;
            }

            ++_UFirst1;
            ++_UFirst2;
        }
    }
}

#if _HAS_CXX17
_EXPORT_STD template &lt;class _ExPo, class _FwdIt1, class _FwdIt2, class _Pr, _Enable_if_execution_policy_t&lt;_ExPo&gt; = 0&gt;
_NODISCARD bool equal(_ExPo&amp;&amp; _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2,
    const _FwdIt2 _Last2, _Pr _Pred) noexcept; // terminates
#endif // _HAS_CXX17

_EXPORT_STD template &lt;class _InIt1, class _InIt2&gt;
_NODISCARD _CONSTEXPR20 bool equal(
    const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2) {
    // compare [_First1, _Last1) to [_First2, _Last2)
    return _STD equal(_First1, _Last1, _First2, _Last2, equal_to&lt;&gt;{});
}

#if _HAS_CXX17
_EXPORT_STD template &lt;class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t&lt;_ExPo&gt; = 0&gt;
_NODISCARD bool equal(_ExPo&amp;&amp; _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2,
    const _FwdIt2 _Last2) noexcept /* terminates */ {
    // compare [_First1, _Last1) to [_First2, _Last2)
    return _STD equal(_STD forward&lt;_ExPo&gt;(_Exec), _First1, _Last1, _First2, _Last2, equal_to{});
}
#endif // _HAS_CXX17

#ifdef __cpp_lib_concepts
namespace ranges {
    template &lt;forward_range _Rng, class _It&gt;
    _NODISCARD constexpr iterator_t&lt;_Rng&gt; _Rewrap_iterator(_Rng&amp;&amp; _Range, _It&amp;&amp; _Val) {
        _STL_INTERNAL_STATIC_ASSERT(is_same_v&lt;remove_cvref_t&lt;_It&gt;, _Unwrapped_iterator_t&lt;_Rng&gt;&gt;);

        if constexpr (is_same_v&lt;remove_cvref_t&lt;_It&gt;, iterator_t&lt;_Rng&gt;&gt;) {
            return _STD forward&lt;_It&gt;(_Val);
        } else {
            auto _Result = _RANGES begin(_Range);
            _Result._Seek_to(_STD forward&lt;_It&gt;(_Val));
            return _Result;
        }
    }

    _EXPORT_STD template &lt;class _In1, class _In2&gt;
    struct in_in_result {
        /* [[no_unique_address]] */ _In1 in1;
        /* [[no_unique_address]] */ _In2 in2;

        template &lt;_Convertible_from&lt;const _In1&amp;&gt; _IIn1, _Convertible_from&lt;const _In2&amp;&gt; _IIn2&gt;
        constexpr operator in_in_result&lt;_IIn1, _IIn2&gt;() const&amp; {
            return {in1, in2};
        }

        template &lt;_Convertible_from&lt;_In1&gt; _IIn1, _Convertible_from&lt;_In2&gt; _IIn2&gt;
        constexpr operator in_in_result&lt;_IIn1, _IIn2&gt;() &amp;&amp; {
            return {_STD move(in1), _STD move(in2)};
        }
    };

    _EXPORT_STD template &lt;class _In1, class _In2&gt;
    using mismatch_result = in_in_result&lt;_In1, _In2&gt;;

    // clang-format off
    template &lt;input_iterator _It1, input_iterator _It2, class _Pr, class _Pj1, class _Pj2&gt;
        requires indirectly_comparable&lt;_It1, _It2, _Pr, _Pj1, _Pj2&gt;
    _NODISCARD constexpr mismatch_result&lt;_It1, _It2&gt; _Mismatch_n(
        _It1 _First1, _It2 _First2, iter_difference_t&lt;_It1&gt; _Count, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
        // clang-format on
        _STL_INTERNAL_CHECK(_Count &gt;= 0);
        for (; _Count != 0; ++_First1, (void) ++_First2, --_Count) {
            if (!_STD invoke(_Pred, _STD invoke(_Proj1, *_First1), _STD invoke(_Proj2, *_First2))) {
                break;
            }
        }

        return {_STD move(_First1), _STD move(_First2)};
    }

    template &lt;input_iterator _It1, sentinel_for&lt;_It1&gt; _Se1, input_iterator _It2, sentinel_for&lt;_It2&gt; _Se2, class _Pr,
        class _Pj1, class _Pj2&gt;
        requires indirectly_comparable&lt;_It1, _It2, _Pr, _Pj1, _Pj2&gt;
    _NODISCARD constexpr mismatch_result&lt;_It1, _It2&gt; _Mismatch_4(
        _It1 _First1, _Se1 _Last1, _It2 _First2, _Se2 _Last2, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {

        for (; _First1 != _Last1 &amp;&amp; _First2 != _Last2; ++_First1, (void) ++_First2) {
            if (!_STD invoke(_Pred, _STD invoke(_Proj1, *_First1), _STD invoke(_Proj2, *_First2))) {
                break;
            }
        }

        return {_STD move(_First1), _STD move(_First2)};
    }

    class _Mismatch_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        // clang-format off
        template &lt;input_iterator _It1, sentinel_for&lt;_It1&gt; _Se1, input_iterator _It2, sentinel_for&lt;_It2&gt; _Se2,
            class _Pr = ranges::equal_to, class _Pj1 = identity, class _Pj2 = identity&gt;
            requires indirectly_comparable&lt;_It1, _It2, _Pr, _Pj1, _Pj2&gt;
        _NODISCARD constexpr mismatch_result&lt;_It1, _It2&gt; operator()(_It1 _First1, _Se1 _Last1,
            _It2 _First2, _Se2 _Last2, _Pr _Pred = {}, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
            // clang-format on
            _Adl_verify_range(_First1, _Last1);
            _Adl_verify_range(_First2, _Last2);

            if constexpr (sized_sentinel_for&lt;_Se1, _It1&gt; &amp;&amp; sized_sentinel_for&lt;_Se2, _It2&gt;) {
                iter_difference_t&lt;_It1&gt; _Count1       = _Last1 - _First1;
                const iter_difference_t&lt;_It2&gt; _Count2 = _Last2 - _First2;
                if (_Count1 &gt; _Count2) {
                    _Count1 = static_cast&lt;decltype(_Count1)&gt;(_Count2);
                }

                auto _Result = _RANGES _Mismatch_n(_Get_unwrapped(_STD move(_First1)),
                    _Get_unwrapped(_STD move(_First2)), _Count1, _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
                _Seek_wrapped(_First1, _STD move(_Result.in1));
                _Seek_wrapped(_First2, _STD move(_Result.in2));
                return {_STD move(_First1), _STD move(_First2)};
            } else {
                auto _Result = _RANGES _Mismatch_4(_Unwrap_iter&lt;_Se1&gt;(_STD move(_First1)),
                    _Unwrap_sent&lt;_It1&gt;(_STD move(_Last1)), _Unwrap_iter&lt;_Se2&gt;(_STD move(_First2)),
                    _Unwrap_sent&lt;_It2&gt;(_STD move(_Last2)), _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
                _Seek_wrapped(_First1, _STD move(_Result.in1));
                _Seek_wrapped(_First2, _STD move(_Result.in2));
                return {_STD move(_First1), _STD move(_First2)};
            }
        }

        template &lt;input_range _Rng1, input_range _Rng2, class _Pr = ranges::equal_to, class _Pj1 = identity,
            class _Pj2 = identity&gt;
            requires indirectly_comparable&lt;iterator_t&lt;_Rng1&gt;, iterator_t&lt;_Rng2&gt;, _Pr, _Pj1, _Pj2&gt;
        _NODISCARD constexpr mismatch_result&lt;borrowed_iterator_t&lt;_Rng1&gt;, borrowed_iterator_t&lt;_Rng2&gt;&gt; operator()(
            _Rng1&amp;&amp; _Range1, _Rng2&amp;&amp; _Range2, _Pr _Pred = {}, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
            if constexpr (sized_range&lt;_Rng1&gt; &amp;&amp; sized_range&lt;_Rng2&gt;) {
                range_difference_t&lt;_Rng1&gt; _Count1       = _RANGES distance(_Range1);
                const range_difference_t&lt;_Rng2&gt; _Count2 = _RANGES distance(_Range2);
                if (_Count1 &gt; _Count2) {
                    _Count1 = static_cast&lt;range_difference_t&lt;_Rng1&gt;&gt;(_Count2);
                }

                auto _First1 = _RANGES begin(_Range1);
                auto _First2 = _RANGES begin(_Range2);
                auto _Result = _RANGES _Mismatch_n(_Get_unwrapped(_STD move(_First1)),
                    _Get_unwrapped(_STD move(_First2)), _Count1, _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
                _Seek_wrapped(_First1, _STD move(_Result.in1));
                _Seek_wrapped(_First2, _STD move(_Result.in2));
                return {_STD move(_First1), _STD move(_First2)};
            } else {
                auto _First1 = _RANGES begin(_Range1);
                auto _First2 = _RANGES begin(_Range2);
                auto _Result = _RANGES _Mismatch_4(_Unwrap_range_iter&lt;_Rng1&gt;(_STD move(_First1)), _Uend(_Range1),
                    _Unwrap_range_iter&lt;_Rng2&gt;(_STD move(_First2)), _Uend(_Range2), _Pass_fn(_Pred), _Pass_fn(_Proj1),
                    _Pass_fn(_Proj2));
                _Seek_wrapped(_First1, _STD move(_Result.in1));
                _Seek_wrapped(_First2, _STD move(_Result.in2));
                return {_STD move(_First1), _STD move(_First2)};
            }
        }
    };

    _EXPORT_STD inline constexpr _Mismatch_fn mismatch{_Not_quite_object::_Construct_tag {}};
} // namespace ranges
#endif // __cpp_lib_concepts

template &lt;class _Elem1, class _Elem2&gt;
_INLINE_VAR constexpr bool _Lex_compare_memcmp_classify_elements = conjunction_v&lt;_Is_character_or_bool&lt;_Elem1&gt;,
    _Is_character_or_bool&lt;_Elem2&gt;, is_unsigned&lt;_Elem1&gt;, is_unsigned&lt;_Elem2&gt;&gt;;

#ifdef __cpp_lib_byte
template &lt;&gt;
inline constexpr bool _Lex_compare_memcmp_classify_elements&lt;byte, byte&gt; = true;
#endif // __cpp_lib_byte

template &lt;class _Elem1, class _Elem2, class _Pr&gt;
struct _Lex_compare_memcmp_classify_pred {
    using _Pred = void;
};

template &lt;class _Elem1, class _Elem2, class _Elem3&gt;
struct _Lex_compare_memcmp_classify_pred&lt;_Elem1, _Elem2, less&lt;_Elem3&gt;&gt; {
    using _Pred = conditional_t&lt;_Lex_compare_memcmp_classify_elements&lt;_Elem3, _Elem3&gt;
                                    &amp;&amp; _Iter_copy_cat&lt;_Elem1*, _Elem3*&gt;::_Bitcopy_constructible
                                    &amp;&amp; _Iter_copy_cat&lt;_Elem2*, _Elem3*&gt;::_Bitcopy_constructible,
        less&lt;int&gt;, void&gt;;
};

template &lt;class _Elem1, class _Elem2&gt;
struct _Lex_compare_memcmp_classify_pred&lt;_Elem1, _Elem2, less&lt;&gt;&gt; {
    using _Pred = conditional_t&lt;_Lex_compare_memcmp_classify_elements&lt;_Elem1, _Elem2&gt;, less&lt;int&gt;, void&gt;;
};

template &lt;class _Elem1, class _Elem2, class _Elem3&gt;
struct _Lex_compare_memcmp_classify_pred&lt;_Elem1, _Elem2, greater&lt;_Elem3&gt;&gt; {
    using _Pred = conditional_t&lt;_Lex_compare_memcmp_classify_elements&lt;_Elem3, _Elem3&gt;
                                    &amp;&amp; _Iter_copy_cat&lt;_Elem1*, _Elem3*&gt;::_Bitcopy_constructible
                                    &amp;&amp; _Iter_copy_cat&lt;_Elem2*, _Elem3*&gt;::_Bitcopy_constructible,
        greater&lt;int&gt;, void&gt;;
};

template &lt;class _Elem1, class _Elem2&gt;
struct _Lex_compare_memcmp_classify_pred&lt;_Elem1, _Elem2, greater&lt;&gt;&gt; {
    using _Pred = conditional_t&lt;_Lex_compare_memcmp_classify_elements&lt;_Elem1, _Elem2&gt;, greater&lt;int&gt;, void&gt;;
};

#ifdef __cpp_lib_concepts
template &lt;class _Elem1, class _Elem2&gt;
struct _Lex_compare_memcmp_classify_pred&lt;_Elem1, _Elem2, _RANGES less&gt; {
    using _Pred = conditional_t&lt;_Lex_compare_memcmp_classify_elements&lt;_Elem1, _Elem2&gt;, less&lt;int&gt;, void&gt;;
};

template &lt;class _Elem1, class _Elem2&gt;
struct _Lex_compare_memcmp_classify_pred&lt;_Elem1, _Elem2, _RANGES greater&gt; {
    using _Pred = conditional_t&lt;_Lex_compare_memcmp_classify_elements&lt;_Elem1, _Elem2&gt;, greater&lt;int&gt;, void&gt;;
};
#endif // __cpp_lib_concepts

template &lt;class _It1, class _It2, class _Pr&gt;
using _Lex_compare_memcmp_classify =
    conditional_t&lt;_Iterators_are_contiguous&lt;_It1, _It2&gt; &amp;&amp; !_Iterator_is_volatile&lt;_It1&gt; &amp;&amp; !_Iterator_is_volatile&lt;_It2&gt;,
        typename _Lex_compare_memcmp_classify_pred&lt;_Iter_value_t&lt;_It1&gt;, _Iter_value_t&lt;_It2&gt;, _Pr&gt;::_Pred, void&gt;;

_EXPORT_STD template &lt;class _InIt1, class _InIt2, class _Pr&gt;
_NODISCARD _CONSTEXPR20 bool lexicographical_compare(
    const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2, _Pr _Pred) {
    // order [_First1, _Last1) vs. [_First2, _Last2)
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped(_First2);
    const auto _ULast2 = _Get_unwrapped(_Last2);

    using _Memcmp_pred = _Lex_compare_memcmp_classify&lt;decltype(_UFirst1), decltype(_UFirst2), _Pr&gt;;
    if constexpr (!is_void_v&lt;_Memcmp_pred&gt;) {
#if _HAS_CXX20
        if (!_STD is_constant_evaluated())
#endif // _HAS_CXX20
        {
            const auto _Num1 = static_cast&lt;size_t&gt;(_ULast1 - _UFirst1);
            const auto _Num2 = static_cast&lt;size_t&gt;(_ULast2 - _UFirst2);
            const int _Ans   = _Memcmp_count(_UFirst1, _UFirst2, (_STD min)(_Num1, _Num2));
            return _Memcmp_pred{}(_Ans, 0) || (_Ans == 0 &amp;&amp; _Num1 &lt; _Num2);
        }
    }

    for (; _UFirst1 != _ULast1 &amp;&amp; _UFirst2 != _ULast2; ++_UFirst1, (void) ++_UFirst2) { // something to compare, do it
        if (_DEBUG_LT_PRED(_Pred, *_UFirst1, *_UFirst2)) {
            return true;
        } else if (_Pred(*_UFirst2, *_UFirst1)) {
            return false;
        }
    }

    return _UFirst1 == _ULast1 &amp;&amp; _UFirst2 != _ULast2;
}

_EXPORT_STD template &lt;class _InIt1, class _InIt2&gt;
_NODISCARD _CONSTEXPR20 bool lexicographical_compare(
    const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2) {
    // order [_First1, _Last1) vs. [_First2, _Last2)
    return _STD lexicographical_compare(_First1, _Last1, _First2, _Last2, less&lt;&gt;{});
}

#if _HAS_CXX17
_EXPORT_STD template &lt;class _ExPo, class _FwdIt1, class _FwdIt2, class _Pr, _Enable_if_execution_policy_t&lt;_ExPo&gt; = 0&gt;
_NODISCARD bool lexicographical_compare(_ExPo&amp;&amp;, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2,
    const _FwdIt2 _Last2, _Pr _Pred) noexcept /* terminates */ {
    // order [_First1, _Last1) vs. [_First2, _Last2)
    // not parallelized at present, parallelism expected to be feasible in a future release
    _REQUIRE_PARALLEL_ITERATOR(_FwdIt1);
    _REQUIRE_PARALLEL_ITERATOR(_FwdIt2);
    return _STD lexicographical_compare(_First1, _Last1, _First2, _Last2, _Pass_fn(_Pred));
}

_EXPORT_STD template &lt;class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t&lt;_ExPo&gt; = 0&gt;
_NODISCARD bool lexicographical_compare(_ExPo&amp;&amp;, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2,
    const _FwdIt2 _Last2) noexcept /* terminates */ {
    // order [_First1, _Last1) vs. [_First2, _Last2)
    // not parallelized at present, parallelism expected to be feasible in a future release
    _REQUIRE_PARALLEL_ITERATOR(_FwdIt1);
    _REQUIRE_PARALLEL_ITERATOR(_FwdIt2);
    return _STD lexicographical_compare(_First1, _Last1, _First2, _Last2);
}
#endif // _HAS_CXX17

#ifdef __cpp_lib_concepts
template &lt;class _Elem1, class _Elem2, class _Cmp&gt;
struct _Lex_compare_three_way_memcmp_classify_comp {
    using _Comp = void;
};

template &lt;class _Elem1, class _Elem2&gt;
struct _Lex_compare_three_way_memcmp_classify_comp&lt;_Elem1, _Elem2, compare_three_way&gt; {
    using _Comp = conditional_t&lt;_Lex_compare_memcmp_classify_elements&lt;_Elem1, _Elem2&gt;
                                    &amp;&amp; three_way_comparable_with&lt;const _Elem1&amp;, const _Elem2&amp;&gt;,
        compare_three_way, void&gt;;
};

template &lt;class _Elem1, class _Elem2&gt;
struct _Lex_compare_three_way_memcmp_classify_comp&lt;_Elem1, _Elem2, _Strong_order::_Cpo&gt; {
    using _Comp =
        conditional_t&lt;_Lex_compare_memcmp_classify_elements&lt;_Elem1, _Elem2&gt; &amp;&amp; _Can_strong_order&lt;_Elem1, _Elem2&gt;,
            _Strong_order::_Cpo, void&gt;;
};

template &lt;class _Elem1, class _Elem2&gt;
struct _Lex_compare_three_way_memcmp_classify_comp&lt;_Elem1, _Elem2, _Weak_order::_Cpo&gt; {
    using _Comp =
        conditional_t&lt;_Lex_compare_memcmp_classify_elements&lt;_Elem1, _Elem2&gt; &amp;&amp; _Can_weak_order&lt;_Elem1, _Elem2&gt;,
            _Weak_order::_Cpo, void&gt;;
};

template &lt;class _Elem1, class _Elem2&gt;
struct _Lex_compare_three_way_memcmp_classify_comp&lt;_Elem1, _Elem2, _Partial_order::_Cpo&gt; {
    using _Comp =
        conditional_t&lt;_Lex_compare_memcmp_classify_elements&lt;_Elem1, _Elem2&gt; &amp;&amp; _Can_partial_order&lt;_Elem1, _Elem2&gt;,
            _Partial_order::_Cpo, void&gt;;
};

template &lt;class _It1, class _It2, class _Cmp&gt;
using _Lex_compare_three_way_memcmp_classify =
    conditional_t&lt;_Iterators_are_contiguous&lt;_It1, _It2&gt; &amp;&amp; !_Iterator_is_volatile&lt;_It1&gt; &amp;&amp; !_Iterator_is_volatile&lt;_It2&gt;,
        typename _Lex_compare_three_way_memcmp_classify_comp&lt;_Iter_value_t&lt;_It1&gt;, _Iter_value_t&lt;_It2&gt;, _Cmp&gt;::_Comp,
        void&gt;;

_EXPORT_STD template &lt;class _InIt1, class _InIt2, class _Cmp&gt;
_NODISCARD constexpr auto lexicographical_compare_three_way(const _InIt1 _First1, const _InIt1 _Last1,
    const _InIt2 _First2, const _InIt2 _Last2, _Cmp _Comp) -&gt; decltype(_Comp(*_First1, *_First2)) {
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped(_First2);
    const auto _ULast2 = _Get_unwrapped(_Last2);

    using _Memcmp_pred = _Lex_compare_three_way_memcmp_classify&lt;decltype(_UFirst1), decltype(_UFirst2), _Cmp&gt;;
    if constexpr (!is_void_v&lt;_Memcmp_pred&gt;) {
        if (!_STD is_constant_evaluated()) {
            const auto _Num1 = static_cast&lt;size_t&gt;(_ULast1 - _UFirst1);
            const auto _Num2 = static_cast&lt;size_t&gt;(_ULast2 - _UFirst2);
            const int _Ans   = _Memcmp_count(_UFirst1, _UFirst2, (_STD min)(_Num1, _Num2));
            if (_Ans == 0) {
                return _Num1 &lt;=&gt; _Num2;
            } else {
                return _Memcmp_pred{}(_Ans, 0);
            }
        }
    }

    for (;;) {
        if (_UFirst1 == _ULast1) {
            return _UFirst2 == _ULast2 ? strong_ordering::equal : strong_ordering::less;
        }

        if (_UFirst2 == _ULast2) {
            return strong_ordering::greater;
        }

        if (const auto _CmpResult = _Comp(*_UFirst1, *_UFirst2); _CmpResult != 0) {
            return _CmpResult;
        }

        ++_UFirst1;
        ++_UFirst2;
    }
}

_EXPORT_STD template &lt;class _InIt1, class _InIt2&gt;
_NODISCARD constexpr auto lexicographical_compare_three_way(
    const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2) {
    return _STD lexicographical_compare_three_way(_First1, _Last1, _First2, _Last2, compare_three_way{});
}
#endif // __cpp_lib_concepts

template &lt;class _Ty, class _Elem&gt;
struct _Vector_alg_in_find_is_safe_object_pointers : false_type {};
template &lt;class _Ty1, class _Ty2&gt;
struct _Vector_alg_in_find_is_safe_object_pointers&lt;_Ty1*, _Ty2*&gt;
    : conjunction&lt;
          // _Ty1* is an object pointer type
          disjunction&lt;is_object&lt;_Ty1&gt;, is_void&lt;_Ty1&gt;&gt;,
          // _Ty2* is an object pointer type
          disjunction&lt;is_object&lt;_Ty2&gt;, is_void&lt;_Ty2&gt;&gt;,
          // either _Ty1 is the same as _Ty2 (ignoring cv-qualifiers), or one of the two is void
          disjunction&lt;is_same&lt;remove_cv_t&lt;_Ty1&gt;, remove_cv_t&lt;_Ty2&gt;&gt;, is_void&lt;_Ty1&gt;, is_void&lt;_Ty2&gt;&gt;&gt; {};

// Can we activate the vector algorithms for find/count?
template &lt;class _Iter, class _Ty, class _Elem = _Iter_value_t&lt;_Iter&gt;&gt;
_INLINE_VAR constexpr bool _Vector_alg_in_find_is_safe =
    // The iterator must be contiguous so we can get raw pointers.
    _Iterator_is_contiguous&lt;_Iter&gt;
    // The iterator must not be volatile.
    &amp;&amp; !_Iterator_is_volatile&lt;_Iter&gt;
    // And one of the following conditions must be met:
    &amp;&amp; disjunction_v&lt;
#ifdef __cpp_lib_byte
        // We're finding a std::byte in a range of std::byte.
        conjunction&lt;is_same&lt;_Ty, byte&gt;, is_same&lt;_Elem, byte&gt;&gt;,
#endif // __cpp_lib_byte
       // We're finding an integer in a range of integers.
       // This case is the one that requires careful runtime handling in _Could_compare_equal_to_value_type.
        conjunction&lt;is_integral&lt;_Ty&gt;, is_integral&lt;_Elem&gt;&gt;,
        // We're finding an (object or function) pointer in a range of pointers of the same type.
        conjunction&lt;is_pointer&lt;_Ty&gt;, is_same&lt;_Ty, _Elem&gt;&gt;,
        // We're finding a nullptr in a range of (object or function) pointers.
        conjunction&lt;is_same&lt;_Ty, nullptr_t&gt;, is_pointer&lt;_Elem&gt;&gt;,
        // We're finding an object pointer in a range of object pointers, and:
        // - One of the pointer types is a cv void*.
        // - One of the pointer types is a cv1 U* and the other is a cv2 U*.
        _Vector_alg_in_find_is_safe_object_pointers&lt;_Ty, _Elem&gt;&gt;;

template &lt;class _InIt, class _Ty&gt;
_NODISCARD constexpr bool _Could_compare_equal_to_value_type(const _Ty&amp; _Val) {
    // check whether _Val is within the limits of _Elem
    _STL_INTERNAL_STATIC_ASSERT(_Vector_alg_in_find_is_safe&lt;_InIt, _Ty&gt;);

    if constexpr (disjunction_v&lt;
#ifdef __cpp_lib_byte
                      is_same&lt;_Ty, byte&gt;,
#endif // __cpp_lib_byte
                      is_same&lt;_Ty, bool&gt;, is_pointer&lt;_Ty&gt;, is_same&lt;_Ty, nullptr_t&gt;&gt;) {
        return true;
    } else {
        using _Elem = _Iter_value_t&lt;_InIt&gt;;
        _STL_INTERNAL_STATIC_ASSERT(is_integral_v&lt;_Elem&gt; &amp;&amp; is_integral_v&lt;_Ty&gt;);

        if constexpr (is_same_v&lt;_Elem, bool&gt;) {
            return _Val == true || _Val == false;
        } else if constexpr (is_signed_v&lt;_Elem&gt;) {
            // use instead of numeric_limits::min/max; avoid &lt;limits&gt; dependency
            constexpr _Elem _Min = static_cast&lt;_Elem&gt;(_Elem{1} &lt;&lt; (sizeof(_Elem) * CHAR_BIT - 1));
            constexpr _Elem _Max = static_cast&lt;_Elem&gt;(~_Min);

            if constexpr (is_signed_v&lt;_Ty&gt;) {
                // signed _Elem, signed _Ty
                return _Min &lt;= _Val &amp;&amp; _Val &lt;= _Max;
            } else {
                // signed _Elem, unsigned _Ty
                if constexpr (_Elem{-1} == static_cast&lt;_Ty&gt;(-1)) {
                    // negative values of _Elem can compare equal to values of _Ty
                    return _Val &lt;= _Max || static_cast&lt;_Ty&gt;(_Min) &lt;= _Val;
                } else {
                    // negative values of _Elem cannot compare equal to values of _Ty
                    return _Val &lt;= _Max;
                }
            }
        } else {
            constexpr _Elem _Max = static_cast&lt;_Elem&gt;(~_Elem{0});

            if constexpr (is_unsigned_v&lt;_Ty&gt;) {
                // unsigned _Elem, unsigned _Ty
                return _Val &lt;= _Max;
            } else {
                // unsigned _Elem, signed _Ty
                if constexpr (_Ty{-1} == static_cast&lt;_Elem&gt;(-1)) {
                    // negative values of _Ty can compare equal to values of _Elem
                    return _Val &lt;= _Max;
                } else {
                    // negative values of _Ty cannot compare equal to values of _Elem
                    return 0 &lt;= _Val &amp;&amp; _Val &lt;= _Max;
                }
            }
        }
    }
}

template &lt;class _InIt, class _Ty&gt;
_NODISCARD _CONSTEXPR20 _InIt _Find_unchecked(_InIt _First, const _InIt _Last, const _Ty&amp; _Val) {
    // find first matching _Val; choose optimization
    // activate optimization for contiguous iterators to most scalar types (possibly const-qualified)
    if constexpr (_Vector_alg_in_find_is_safe&lt;_InIt, _Ty&gt;) {
#if _HAS_CXX20
        if (!_STD is_constant_evaluated())
#endif // _HAS_CXX20
        {
            if (!_STD _Could_compare_equal_to_value_type&lt;_InIt&gt;(_Val)) {
                return _Last;
            }
#if _USE_STD_VECTOR_ALGORITHMS
            const auto _First_ptr = _To_address(_First);
            const auto _Result    = __std_find_trivial(_First_ptr, _To_address(_Last), _Val);
            if constexpr (is_pointer_v&lt;_InIt&gt;) {
                return _Result;
            } else {
                return _First + (_Result - _First_ptr);
            }
#else // ^^^ _USE_STD_VECTOR_ALGORITHMS / not _USE_STD_VECTOR_ALGORITHMS vvv
            if constexpr (sizeof(_Iter_value_t&lt;_InIt&gt;) == 1) {
                const auto _First_ptr = _To_address(_First);
                const auto _Result    = static_cast&lt;remove_reference_t&lt;_Iter_ref_t&lt;_InIt&gt;&gt;*&gt;(
                    _CSTD memchr(_First_ptr, static_cast&lt;unsigned char&gt;(_Val), static_cast&lt;size_t&gt;(_Last - _First)));
                if constexpr (is_pointer_v&lt;_InIt&gt;) {
                    return _Result ? _Result : _Last;
                } else {
                    return _Result ? _First + (_Result - _First_ptr) : _Last;
                }
            }
            // TRANSITION, DevCom-1614562: not trying wmemchr
#endif // ^^^ not _USE_STD_VECTOR_ALGORITHMS ^^^
        }
    }

    for (; _First != _Last; ++_First) {
        if (*_First == _Val) {
            break;
        }
    }

    return _First;
}

_EXPORT_STD template &lt;class _InIt, class _Ty&gt;
_NODISCARD _CONSTEXPR20 _InIt find(_InIt _First, const _InIt _Last, const _Ty&amp; _Val) { // find first matching _Val
    _Adl_verify_range(_First, _Last);
    if constexpr (_Is_vb_iterator&lt;_InIt&gt; &amp;&amp; is_same_v&lt;_Ty, bool&gt;) {
        return _Find_vbool(_First, _Last, _Val);
    } else {
        _Seek_wrapped(_First, _STD _Find_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Val));
        return _First;
    }
}

#if _HAS_CXX17
_EXPORT_STD template &lt;class _ExPo, class _FwdIt, class _Ty, _Enable_if_execution_policy_t&lt;_ExPo&gt; = 0&gt;
_NODISCARD _FwdIt find(_ExPo&amp;&amp; _Exec, _FwdIt _First, const _FwdIt _Last, const _Ty&amp; _Val) noexcept; // terminates
#endif // _HAS_CXX17

#ifdef __cpp_lib_concepts
namespace ranges {
    template &lt;class _Se, class _It&gt;
    concept _Sized_or_unreachable_sentinel_for = sized_sentinel_for&lt;_Se, _It&gt; || same_as&lt;_Se, unreachable_sentinel_t&gt;;

    template &lt;class _Rng&gt;
    concept _Sized_or_infinite_range = range&lt;_Rng&gt;
                                    &amp;&amp; (sized_range&lt;_Rng&gt; || same_as&lt;sentinel_t&lt;_Rng&gt;, unreachable_sentinel_t&gt;);

    // concept-constrained for strict enforcement as it is used by several algorithms
    template &lt;input_iterator _It, sentinel_for&lt;_It&gt; _Se, class _Ty, class _Pj = identity&gt;
        requires indirect_binary_predicate&lt;ranges::equal_to, projected&lt;_It, _Pj&gt;, const _Ty*&gt;
    _NODISCARD constexpr _It _Find_unchecked(_It _First, const _Se _Last, const _Ty&amp; _Val, _Pj _Proj = {}) {
        constexpr bool _Is_sized = sized_sentinel_for&lt;_Se, _It&gt;;
        if constexpr (_Vector_alg_in_find_is_safe&lt;_It, _Ty&gt; &amp;&amp; _Sized_or_unreachable_sentinel_for&lt;_Se, _It&gt;
                      &amp;&amp; same_as&lt;_Pj, identity&gt;) {
            if (!_STD is_constant_evaluated()) {
                if (!_STD _Could_compare_equal_to_value_type&lt;_It&gt;(_Val)) {
                    if constexpr (_Is_sized) {
                        return _RANGES next(_STD move(_First), _Last);
                    } else {
                        _STL_ASSERT(false, "Tried to find a value in a range with unreachable sentinel"
                                           " that cannot be represented by the range's value type");
                    }
                }

                using _Ptr_t = remove_reference_t&lt;_Iter_ref_t&lt;_It&gt;&gt;*;
#if _USE_STD_VECTOR_ALGORITHMS
                const auto _First_ptr = _To_address(_First);

                _Ptr_t _Result;

                if constexpr (_Is_sized) {
                    const auto _Last_ptr = _First_ptr + (_Last - _First);

                    _Result = __std_find_trivial(_First_ptr, _Last_ptr, _Val);
                } else {
                    _Result = __std_find_trivial_unsized(_First_ptr, _Val);
                }

                if constexpr (is_pointer_v&lt;_It&gt;) {
                    return _Result;
                } else {
                    return _RANGES next(_STD move(_First), _Result - _First_ptr);
                }
#else // ^^^ _USE_STD_VECTOR_ALGORITHMS / not _USE_STD_VECTOR_ALGORITHMS vvv
                if constexpr (sizeof(_Iter_value_t&lt;_It&gt;) == 1
#if defined(_M_ARM64) || defined(_M_ARM64EC) // TRANSITION, VSO-1538014 : memchr inspects bytes after the match
                              &amp;&amp; _Is_sized
#endif // ^^^ workaround ^^^
                ) {
                    size_t _Count;
                    if constexpr (_Is_sized) {
                        _Count = static_cast&lt;size_t&gt;(_Last - _First);
                    } else {
                        _Count = SIZE_MAX;
                    }

                    const auto _First_ptr = _STD to_address(_First);
                    const auto _Result =
                        static_cast&lt;_Ptr_t&gt;(_CSTD memchr(_First_ptr, static_cast&lt;unsigned char&gt;(_Val), _Count));
                    if (_Result) {
                        if constexpr (is_pointer_v&lt;_It&gt;) {
                            return _Result;
                        } else {
                            return _RANGES next(_STD move(_First), _Result - _First_ptr);
                        }
                    } else {
                        return _RANGES next(_STD move(_First), _Last);
                    }
                }
                // TRANSITION, DevCom-1614562: not trying wmemchr
#endif // ^^^ not _USE_STD_VECTOR_ALGORITHMS ^^^
            }
        }

        for (; _First != _Last; ++_First) {
            if (_STD invoke(_Proj, *_First) == _Val) {
                break;
            }
        }

        return _First;
    }

    class _Find_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        // clang-format off
        template &lt;input_iterator _It, sentinel_for&lt;_It&gt; _Se, class _Ty, class _Pj = identity&gt;
            requires indirect_binary_predicate&lt;ranges::equal_to, projected&lt;_It, _Pj&gt;, const _Ty*&gt;
        _NODISCARD constexpr _It operator()(_It _First, _Se _Last, const _Ty&amp; _Val, _Pj _Proj = {}) const {
            // clang-format on
            _Adl_verify_range(_First, _Last);
            auto _UResult = _RANGES _Find_unchecked(
                _Unwrap_iter&lt;_Se&gt;(_STD move(_First)), _Unwrap_sent&lt;_It&gt;(_STD move(_Last)), _Val, _Pass_fn(_Proj));

            _Seek_wrapped(_First, _STD move(_UResult));
            return _First;
        }

        template &lt;input_range _Rng, class _Ty, class _Pj = identity&gt;
            requires indirect_binary_predicate&lt;ranges::equal_to, projected&lt;iterator_t&lt;_Rng&gt;, _Pj&gt;, const _Ty*&gt;
        _NODISCARD constexpr borrowed_iterator_t&lt;_Rng&gt; operator()(
            _Rng&amp;&amp; _Range, const _Ty&amp; _Val, _Pj _Proj = {}) const {
            auto _First   = _RANGES begin(_Range);
            auto _UResult = _RANGES _Find_unchecked(
                _Unwrap_range_iter&lt;_Rng&gt;(_STD move(_First)), _Uend(_Range), _Val, _Pass_fn(_Proj));

            _Seek_wrapped(_First, _STD move(_UResult));
            return _First;
        }
    };

    _EXPORT_STD inline constexpr _Find_fn find{_Not_quite_object::_Construct_tag {}};
} // namespace ranges
#endif // __cpp_lib_concepts

_EXPORT_STD template &lt;class _InIt, class _Ty&gt;
_NODISCARD _CONSTEXPR20 _Iter_diff_t&lt;_InIt&gt; count(const _InIt _First, const _InIt _Last, const _Ty&amp; _Val) {
    // count elements that match _Val
    _Adl_verify_range(_First, _Last);
    if constexpr (_Is_vb_iterator&lt;_InIt&gt; &amp;&amp; is_same_v&lt;_Ty, bool&gt;) {
        return _Count_vbool(_First, _Last, _Val);
    } else {
        auto _UFirst      = _Get_unwrapped(_First);
        const auto _ULast = _Get_unwrapped(_Last);

#if _USE_STD_VECTOR_ALGORITHMS
        if constexpr (_Vector_alg_in_find_is_safe&lt;decltype(_UFirst), _Ty&gt;) {
#if _HAS_CXX20
            if (!_STD is_constant_evaluated())
#endif // _HAS_CXX20
            {
                if (!_STD _Could_compare_equal_to_value_type&lt;decltype(_UFirst)&gt;(_Val)) {
                    return 0;
                }

                return static_cast&lt;_Iter_diff_t&lt;_InIt&gt;&gt;(
                    __std_count_trivial(_To_address(_UFirst), _To_address(_ULast), _Val));
            }
        }
#endif // _USE_STD_VECTOR_ALGORITHMS

        _Iter_diff_t&lt;_InIt&gt; _Count = 0;

        for (; _UFirst != _ULast; ++_UFirst) {
            if (*_UFirst == _Val) {
                ++_Count;
            }
        }

        return _Count;
    }
}

#if _HAS_CXX17
_EXPORT_STD template &lt;class _ExPo, class _FwdIt, class _Ty, _Enable_if_execution_policy_t&lt;_ExPo&gt; = 0&gt;
_NODISCARD _Iter_diff_t&lt;_FwdIt&gt; count(
    _ExPo&amp;&amp; _Exec, const _FwdIt _First, const _FwdIt _Last, const _Ty&amp; _Val) noexcept; // terminates
#endif // _HAS_CXX17

template &lt;class _InIt, class _Ty, class _Pr&gt;
_NODISCARD constexpr _InIt _Find_pr(_InIt _First, const _InIt _Last, const _Ty&amp; _Val, _Pr _Pred) {
    for (; _First != _Last; ++_First) {
        if (_Pred(*_First, _Val)) {
            break;
        }
    }

    return _First;
}

template &lt;class _InIt, class _Ty, class _Pr&gt;
_NODISCARD constexpr _Iter_diff_t&lt;_InIt&gt; _Count_pr(_InIt _First, const _InIt _Last, const _Ty&amp; _Val, _Pr _Pred) {
    _Iter_diff_t&lt;_InIt&gt; _Count = 0;

    for (; _First != _Last; ++_First) {
        if (_Pred(*_First, _Val)) {
            ++_Count;
        }
    }

    return _Count;
}

enum class _TrimResult : unsigned char { _KeepTrimming, _HaveWorkAfterTrimming, _ReturnFalse, _ReturnTrue };

template &lt;class _BidIt1, class _BidIt2, class _Pr&gt;
_NODISCARD _CONSTEXPR20 _TrimResult _Trim_equal(
    _BidIt1&amp; _First1, _BidIt1&amp; _Back1, _BidIt2&amp; _First2, _BidIt2&amp; _Back2, _Pr _Pred) {
    // advances the iterators, trimming matching prefixes then matching suffixes
    // from [_First1, _Back1] and [_First2, _Back2]
    _STL_INTERNAL_CHECK(_First1 != _Back1);
    _STL_INTERNAL_CHECK(_STD distance(_First1, _Back1) == _STD distance(_First2, _Back2));
    if (_Pred(*_First1, *_First2)) {
        do {
            ++_First1;
            ++_First2;
            if (_First1 == _Back1) {
                // only one element is left
                return _Pred(*_First1, *_First2) ? _TrimResult::_ReturnTrue : _TrimResult::_ReturnFalse;
            }
        } while (_Pred(*_First1, *_First2));
    } else {
        if (!_Pred(*_Back1, *_Back2)) {
            // nothing to trim
            return _TrimResult::_HaveWorkAfterTrimming;
        }
        --_Back1;
        --_Back2;
    }

    for (;;) {
        if (_First1 == _Back1) {
            // only one element is left, it can't match because it wasn't trimmed by the first loop
            return _TrimResult::_ReturnFalse;
        }

        if (!_Pred(*_Back1, *_Back2)) {
            return _TrimResult::_KeepTrimming;
        }
        --_Back1;
        --_Back2;
    }
}

template &lt;class _BidIt1, class _BidIt2, class _Pr&gt;
_NODISCARD _CONSTEXPR20 _TrimResult _Trim_reversed(
    _BidIt1&amp; _First1, _BidIt1&amp; _Back1, _BidIt2&amp; _First2, _BidIt2&amp; _Back2, _Pr _Pred) {
    // advances the iterators, trimming each range's prefix that matches the other range's suffix
    // from [_First1, _Back1] and [_First2, _Back2]
    _STL_INTERNAL_CHECK(_First1 != _Back1);
    _STL_INTERNAL_CHECK(_STD distance(_First1, _Back1) == _STD distance(_First2, _Back2));
    if (_Pred(*_First1, *_Back2)) {
        do {
            ++_First1;
            --_Back2;
            if (_First1 == _Back1) {
                // only one element is left
                return _Pred(*_First1, *_First2) ? _TrimResult::_ReturnTrue : _TrimResult::_ReturnFalse;
            }
        } while (_Pred(*_First1, *_Back2));
    } else {
        if (!_Pred(*_Back1, *_First2)) {
            // nothing to trim
            return _TrimResult::_HaveWorkAfterTrimming;
        }
        --_Back1;
        ++_First2;
    }

    for (;;) {
        if (_First1 == _Back1) {
            // only one element is left, it can't match because it wasn't trimmed by the first loop
            return _TrimResult::_ReturnFalse;
        }

        if (!_Pred(*_Back1, *_First2)) {
            return _TrimResult::_KeepTrimming;
        }
        --_Back1;
        ++_First2;
    }
}

template &lt;class _BidIt1, class _BidIt2, class _Pr&gt;
_NODISCARD _CONSTEXPR20 _TrimResult _Trim_completely(
    _BidIt1&amp; _First1, _BidIt1&amp; _Back1, _BidIt2&amp; _First2, _BidIt2&amp; _Back2, _Pr _Pred) {
    // alternates between calling _Trim_reversed and _Trim_equal until no more trimming is possible
    _TrimResult _Res = _TrimResult::_KeepTrimming;

    for (bool _Check_reversed = true; _Res == _TrimResult::_KeepTrimming; _Check_reversed = !_Check_reversed) {
        if (_Check_reversed) {
            _Res = _Trim_reversed(_First1, _Back1, _First2, _Back2, _Pred);
        } else {
            _Res = _Trim_equal(_First1, _Back1, _First2, _Back2, _Pred);
        }
    }

    return _Res;
}

template &lt;class _FwdIt1, class _FwdIt2, class _Pr&gt;
_NODISCARD _CONSTEXPR20 bool _Check_match_counts(
    _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred) {
    // test if [_First1, _Last1) == permuted [_First2, _Last2), after matching prefix removal
    _STL_INTERNAL_CHECK(!_Pred(*_First1, *_First2));
    _STL_INTERNAL_CHECK(_STD distance(_First1, _Last1) == _STD distance(_First2, _Last2));
    if constexpr (_Is_ranges_bidi_iter_v&lt;_FwdIt1&gt; &amp;&amp; _Is_ranges_bidi_iter_v&lt;_FwdIt2&gt;) {
        do { // find last inequality
            --_Last1;
            --_Last2;
        } while (_Pred(*_Last1, *_Last2));

        if (_First1 == _Last1) {
            return false;
        }

        const _TrimResult _Res = _Trim_completely(_First1, _Last1, _First2, _Last2, _Pred);

        if (_Res != _TrimResult::_HaveWorkAfterTrimming) {
            return _Res == _TrimResult::_ReturnTrue;
        }

        ++_Last1;
        ++_Last2;
    }

    for (_FwdIt1 _Next1 = _First1; _Next1 != _Last1; ++_Next1) {
        if (_Next1 == _Find_pr(_First1, _Next1, *_Next1, _Pred)) { // new value, compare match counts
            _Iter_diff_t&lt;_FwdIt2&gt; _Count2 = _Count_pr(_First2, _Last2, *_Next1, _Pred);
            if (_Count2 == 0) {
                return false; // second range lacks value, not a permutation
            }

            _FwdIt1 _Skip1                = _Next_iter(_Next1);
            _Iter_diff_t&lt;_FwdIt1&gt; _Count1 = _Count_pr(_Skip1, _Last1, *_Next1, _Pred) + 1;
            if (_Count2 != _Count1) {
                return false; // match counts differ, not a permutation
            }
        }
    }

    return true;
}

_EXPORT_STD template &lt;class _BidIt&gt;
_CONSTEXPR20 void reverse(const _BidIt _First, const _BidIt _Last) { // reverse elements in [_First, _Last)
    _Adl_verify_range(_First, _Last);
    auto _UFirst = _Get_unwrapped(_First);
    auto _ULast  = _Get_unwrapped(_Last);
#if _USE_STD_VECTOR_ALGORITHMS
    using _Elem                         = remove_reference_t&lt;_Iter_ref_t&lt;decltype(_UFirst)&gt;&gt;;
    constexpr bool _Allow_vectorization = conjunction_v&lt;bool_constant&lt;_Iterator_is_contiguous&lt;decltype(_UFirst)&gt;&gt;,
        _Is_trivially_swappable&lt;_Elem&gt;, negation&lt;is_volatile&lt;_Elem&gt;&gt;&gt;;
    constexpr size_t _Nx                = sizeof(_Elem);

    if constexpr (_Allow_vectorization &amp;&amp; _Nx &lt;= 8 &amp;&amp; (_Nx &amp; (_Nx - 1)) == 0) {
#if _HAS_CXX20
        if (!_STD is_constant_evaluated())
#endif // _HAS_CXX20
        {
            if constexpr (_Nx == 1) {
                __std_reverse_trivially_swappable_1(_To_address(_UFirst), _To_address(_ULast));
            } else if constexpr (_Nx == 2) {
                __std_reverse_trivially_swappable_2(_To_address(_UFirst), _To_address(_ULast));
            } else if constexpr (_Nx == 4) {
                __std_reverse_trivially_swappable_4(_To_address(_UFirst), _To_address(_ULast));
            } else {
                __std_reverse_trivially_swappable_8(_To_address(_UFirst), _To_address(_ULast));
            }

            return;
        }
    }
#endif // _USE_STD_VECTOR_ALGORITHMS

    for (; _UFirst != _ULast &amp;&amp; _UFirst != --_ULast; ++_UFirst) {
        _STD iter_swap(_UFirst, _ULast);
    }
}

#if _HAS_CXX17
_EXPORT_STD template &lt;class _ExPo, class _BidIt, _Enable_if_execution_policy_t&lt;_ExPo&gt; = 0&gt;
void reverse(_ExPo&amp;&amp;, _BidIt _First, _BidIt _Last) noexcept /* terminates */ {
    // reverse elements in [_First, _Last)
    // not parallelized as benchmarks show it isn't worth it
    return _STD reverse(_First, _Last);
}
#endif // _HAS_CXX17

template &lt;class _BidIt&gt;
constexpr pair&lt;_BidIt, _BidIt&gt; _Reverse_until_sentinel_unchecked(_BidIt _First, _BidIt _Sentinel, _BidIt _Last) {
    // reverse until either _First or _Last hits _Sentinel
    while (_First != _Sentinel &amp;&amp; _Last != _Sentinel) {
        _STD iter_swap(_First, --_Last);
        ++_First;
    }

    return pair&lt;_BidIt, _BidIt&gt;(_First, _Last);
}

_EXPORT_STD template &lt;class _FwdIt&gt;
_CONSTEXPR20 _FwdIt rotate(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last) {
    // exchange the ranges [_First, _Mid) and [_Mid, _Last)
    // that is, rotates [_First, _Last) left by distance(_First, _Mid) positions
    // returns the iterator pointing at *_First's new home
    _Adl_verify_range(_First, _Mid);
    _Adl_verify_range(_Mid, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    auto _UMid        = _Get_unwrapped(_Mid);
    const auto _ULast = _Get_unwrapped(_Last);
    if (_UFirst == _UMid) {
        return _Last;
    }

    if (_UMid == _ULast) {
        return _First;
    }

    if constexpr (_Is_cpp17_random_iter_v&lt;_FwdIt&gt;) {
        _STD reverse(_UFirst, _UMid);
        _STD reverse(_UMid, _ULast);
        _STD reverse(_UFirst, _ULast);
        _Seek_wrapped(_First, _UFirst + (_ULast - _UMid));
    } else if constexpr (_Is_cpp17_bidi_iter_v&lt;_FwdIt&gt;) {
        _STD reverse(_UFirst, _UMid);
        _STD reverse(_UMid, _ULast);
        auto _Tmp = _Reverse_until_sentinel_unchecked(_UFirst, _UMid, _ULast);
        _STD reverse(_Tmp.first, _Tmp.second);
        _Seek_wrapped(_First, _UMid != _Tmp.first ? _Tmp.first : _Tmp.second);
    } else {
        auto _UNext = _UMid;
        do { // rotate the first cycle
            _STD iter_swap(_UFirst, _UNext);
            ++_UFirst;
            ++_UNext;
            if (_UFirst == _UMid) {
                _UMid = _UNext;
            }
        } while (_UNext != _ULast);
        _Seek_wrapped(_First, _UFirst);
        while (_UMid != _ULast) { // rotate subsequent cycles
            _UNext = _UMid;
            do {
                _STD iter_swap(_UFirst, _UNext);
                ++_UFirst;
                ++_UNext;
                if (_UFirst == _UMid) {
                    _UMid = _UNext;
                }
            } while (_UNext != _ULast);
        }
    }

    return _First;
}

#if _HAS_CXX17
_EXPORT_STD template &lt;class _ExPo, class _FwdIt, _Enable_if_execution_policy_t&lt;_ExPo&gt; = 0&gt;
_FwdIt rotate(_ExPo&amp;&amp;, _FwdIt _First, _FwdIt _Mid, _FwdIt _Last) noexcept /* terminates */ {
    // rotate [_First, _Last) left by distance(_First, _Mid) positions
    // not parallelized as benchmarks show it isn't worth it
    return _STD rotate(_First, _Mid, _Last);
}
#endif // _HAS_CXX17

_EXPORT_STD template &lt;class _InIt, class _Pr&gt;
_NODISCARD _CONSTEXPR20 _InIt find_if(_InIt _First, const _InIt _Last, _Pr _Pred) { // find first satisfying _Pred
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    for (; _UFirst != _ULast; ++_UFirst) {
        if (_Pred(*_UFirst)) {
            break;
        }
    }

    _Seek_wrapped(_First, _UFirst);
    return _First;
}

#ifdef __cpp_lib_concepts
namespace ranges {
    template &lt;class _Result, class _Wrapped, class _Unwrapped&gt;
    _NODISCARD constexpr _Result _Rewrap_subrange(_Wrapped&amp; _Val, subrange&lt;_Unwrapped&gt;&amp;&amp; _UResult) {
        // conditionally computes a wrapped subrange from a wrapped iterator or range and unwrapped subrange
        if constexpr (is_same_v&lt;_Result, dangling&gt;) {
            return dangling{};
        } else if constexpr (is_same_v&lt;_Result, subrange&lt;_Unwrapped&gt;&gt;) {
            return _STD move(_UResult);
        } else if constexpr (range&lt;_Wrapped&gt;) {
            _STL_INTERNAL_STATIC_ASSERT(forward_range&lt;_Wrapped&gt;);
            _STL_INTERNAL_STATIC_ASSERT(is_same_v&lt;_Unwrapped, _Unwrapped_iterator_t&lt;_Wrapped&gt;&gt;);
            _STL_INTERNAL_STATIC_ASSERT(is_same_v&lt;_Result, subrange&lt;iterator_t&lt;_Wrapped&gt;&gt;&gt;);

            auto _First = _RANGES begin(_Val);
            auto _Last  = _First;
            _First._Seek_to(_UResult.begin());
            _Last._Seek_to(_UResult.end());
            return _Result{_STD move(_First), _STD move(_Last)};
        } else {
            _STL_INTERNAL_STATIC_ASSERT(is_same_v&lt;_Unwrapped, _Unwrapped_t&lt;_Wrapped&gt;&gt;);
            _STL_INTERNAL_STATIC_ASSERT(is_same_v&lt;_Result, subrange&lt;_Wrapped&gt;&gt;);

            auto _Last = _Val;
            _Val._Seek_to(_UResult.begin());
            _Last._Seek_to(_UResult.end());
            return _Result{_STD move(_Val), _STD move(_Last)};
        }
    }

    // concept-constrained for strict enforcement as it is used by several algorithms
    template &lt;input_iterator _It, sentinel_for&lt;_It&gt; _Se, class _Pj, indirect_unary_predicate&lt;projected&lt;_It, _Pj&gt;&gt; _Pr&gt;
    _NODISCARD constexpr _It _Find_if_unchecked(_It _First, const _Se _Last, _Pr _Pred, _Pj _Proj) {
        for (; _First != _Last; ++_First) {
            if (_STD invoke(_Pred, _STD invoke(_Proj, *_First))) {
                break;
            }
        }

        return _First;
    }

    class _Find_if_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template &lt;input_iterator _It, sentinel_for&lt;_It&gt; _Se, class _Pj = identity,
            indirect_unary_predicate&lt;projected&lt;_It, _Pj&gt;&gt; _Pr&gt;
        _NODISCARD constexpr _It operator()(_It _First, _Se _Last, _Pr _Pred, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);
            auto _UResult = _RANGES _Find_if_unchecked(_Unwrap_iter&lt;_Se&gt;(_STD move(_First)),
                _Unwrap_sent&lt;_It&gt;(_STD move(_Last)), _Pass_fn(_Pred), _Pass_fn(_Proj));

            _Seek_wrapped(_First, _STD move(_UResult));
            return _First;
        }

        template &lt;input_range _Rng, class _Pj = identity,
            indirect_unary_predicate&lt;projected&lt;iterator_t&lt;_Rng&gt;, _Pj&gt;&gt; _Pr&gt;
        _NODISCARD constexpr borrowed_iterator_t&lt;_Rng&gt; operator()(_Rng&amp;&amp; _Range, _Pr _Pred, _Pj _Proj = {}) const {
            auto _First   = _RANGES begin(_Range);
            auto _UResult = _RANGES _Find_if_unchecked(
                _Unwrap_range_iter&lt;_Rng&gt;(_STD move(_First)), _Uend(_Range), _Pass_fn(_Pred), _Pass_fn(_Proj));

            _Seek_wrapped(_First, _STD move(_UResult));
            return _First;
        }
    };

    _EXPORT_STD inline constexpr _Find_if_fn find_if{_Not_quite_object::_Construct_tag {}};

    class _Find_if_not_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template &lt;input_iterator _It, sentinel_for&lt;_It&gt; _Se, class _Pj = identity,
            indirect_unary_predicate&lt;projected&lt;_It, _Pj&gt;&gt; _Pr&gt;
        _NODISCARD constexpr _It operator()(_It _First, _Se _Last, _Pr _Pred, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);

            auto _UResult = _Find_if_not_unchecked(_Unwrap_iter&lt;_Se&gt;(_STD move(_First)),
                _Unwrap_sent&lt;_It&gt;(_STD move(_Last)), _Pass_fn(_Pred), _Pass_fn(_Proj));

            _Seek_wrapped(_First, _STD move(_UResult));
            return _First;
        }

        template &lt;input_range _Rng, class _Pj = identity,
            indirect_unary_predicate&lt;projected&lt;iterator_t&lt;_Rng&gt;, _Pj&gt;&gt; _Pr&gt;
        _NODISCARD constexpr borrowed_iterator_t&lt;_Rng&gt; operator()(_Rng&amp;&amp; _Range, _Pr _Pred, _Pj _Proj = {}) const {
            auto _First = _RANGES begin(_Range);

            auto _UResult = _Find_if_not_unchecked(
                _Unwrap_range_iter&lt;_Rng&gt;(_STD move(_First)), _Uend(_Range), _Pass_fn(_Pred), _Pass_fn(_Proj));

            _Seek_wrapped(_First, _STD move(_UResult));
            return _First;
        }

    private:
        template &lt;class _It, class _Se, class _Pj, class _Pr&gt;
        _NODISCARD static constexpr _It _Find_if_not_unchecked(_It _First, const _Se _Last, _Pr _Pred, _Pj _Proj) {
            _STL_INTERNAL_STATIC_ASSERT(input_iterator&lt;_It&gt;);
            _STL_INTERNAL_STATIC_ASSERT(sentinel_for&lt;_Se, _It&gt;);
            _STL_INTERNAL_STATIC_ASSERT(indirect_unary_predicate&lt;_Pr, projected&lt;_It, _Pj&gt;&gt;);

            for (; _First != _Last; ++_First) {
                if (!_STD invoke(_Pred, _STD invoke(_Proj, *_First))) {
                    break;
                }
            }

            return _First;
        }
    };

    _EXPORT_STD inline constexpr _Find_if_not_fn find_if_not{_Not_quite_object::_Construct_tag {}};

    class _Adjacent_find_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template &lt;forward_iterator _It, sentinel_for&lt;_It&gt; _Se, class _Pj = identity,
            indirect_binary_predicate&lt;projected&lt;_It, _Pj&gt;, projected&lt;_It, _Pj&gt;&gt; _Pr = ranges::equal_to&gt;
        _NODISCARD constexpr _It operator()(_It _First, _Se _Last, _Pr _Pred = {}, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);

            auto _UResult = _Adjacent_find_unchecked(_Unwrap_iter&lt;_Se&gt;(_STD move(_First)),
                _Unwrap_sent&lt;_It&gt;(_STD move(_Last)), _Pass_fn(_Pred), _Pass_fn(_Proj));

            _Seek_wrapped(_First, _STD move(_UResult));
            return _First;
        }

        template &lt;forward_range _Rng, class _Pj = identity,
            indirect_binary_predicate&lt;projected&lt;iterator_t&lt;_Rng&gt;, _Pj&gt;, projected&lt;iterator_t&lt;_Rng&gt;, _Pj&gt;&gt; _Pr =
                ranges::equal_to&gt;
        _NODISCARD constexpr borrowed_iterator_t&lt;_Rng&gt; operator()(_Rng&amp;&amp; _Range, _Pr _Pred = {}, _Pj _Proj = {}) const {
            auto _UResult = _Adjacent_find_unchecked(_Ubegin(_Range), _Uend(_Range), _Pass_fn(_Pred), _Pass_fn(_Proj));

            return _Rewrap_iterator(_Range, _STD move(_UResult));
        }

    private:
        template &lt;class _It, class _Se, class _Pj, class _Pr&gt;
        _NODISCARD static constexpr _It _Adjacent_find_unchecked(_It _First, const _Se _Last, _Pr _Pred, _Pj _Proj) {
            // find first satisfying _Pred with successor
            _STL_INTERNAL_STATIC_ASSERT(forward_iterator&lt;_It&gt;);
            _STL_INTERNAL_STATIC_ASSERT(sentinel_for&lt;_Se, _It&gt;);
            _STL_INTERNAL_STATIC_ASSERT(indirect_binary_predicate&lt;_Pr, projected&lt;_It, _Pj&gt;, projected&lt;_It, _Pj&gt;&gt;);

            if (_First == _Last) {
                return _First;
            }

            for (auto _Next = _First;; ++_First) {
                if (++_Next == _Last) {
                    return _Next;
                }

                if (_STD invoke(_Pred, _STD invoke(_Proj, *_First), _STD invoke(_Proj, *_Next))) {
                    return _First;
                }
            }
        }
    };

    _EXPORT_STD inline constexpr _Adjacent_find_fn adjacent_find{_Not_quite_object::_Construct_tag {}};

    // clang-format off
    template &lt;class _It1, class _It2, class _Se2, class _Pr, class _Pj1, class _Pj2&gt;
    concept _Equal_rev_pred_can_memcmp = is_same_v&lt;_Pj1, identity&gt; &amp;&amp; is_same_v&lt;_Pj2, identity&gt;
        &amp;&amp; sized_sentinel_for&lt;_Se2, _It2&gt; &amp;&amp; _Equal_memcmp_is_safe&lt;_It1, _It2, _Pr&gt;;

    template &lt;input_iterator _It1, input_iterator _It2, sentinel_for&lt;_It2&gt; _Se2, class _Pr, class _Pj1, class _Pj2&gt;
        requires indirectly_comparable&lt;_It1, _It2, _Pr, _Pj1, _Pj2&gt;
    _NODISCARD constexpr pair&lt;bool, _It1&gt; _Equal_rev_pred(
        _It1 _First1, _It2 _First2, const _Se2 _Last2, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
        // clang-format on
        // Returns {true, _First1 + (_Last2 - _First2)} if [_First1, ...) equals [_First2, _Last2), and {false, {}}
        // otherwise.
        constexpr bool _Optimize = _Equal_rev_pred_can_memcmp&lt;_It1, _It2, _Se2, _Pr, _Pj1, _Pj2&gt;;
        if constexpr (_Optimize) {
            if (!_STD is_constant_evaluated()) {
                bool _Ans;
                if constexpr (same_as&lt;_It2, _Se2&gt;) {
                    _Ans = _Memcmp_ranges(_First2, _Last2, _First1) == 0;
                } else {
                    _Ans = _Memcmp_count(_First1, _First2, static_cast&lt;size_t&gt;(_Last2 - _First2)) == 0;
                }

                if (_Ans) {
                    _First1 += (_Last2 - _First2);
                    return {true, _STD move(_First1)};
                } else {
                    return {false, _It1 {}};
                }
            }
        }

        for (; _First2 != _Last2; ++_First1, (void) ++_First2) {
            if (!_STD invoke(_Pred, _STD invoke(_Proj1, *_First1), _STD invoke(_Proj2, *_First2))) {
                return {false, _It1 {}};
            }
        }

        return {true, _STD move(_First1)};
    }

    class _Search_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template &lt;forward_iterator _It1, sentinel_for&lt;_It1&gt; _Se1, forward_iterator _It2, sentinel_for&lt;_It2&gt; _Se2,
            class _Pr = ranges::equal_to, class _Pj1 = identity, class _Pj2 = identity&gt;
            requires indirectly_comparable&lt;_It1, _It2, _Pr, _Pj1, _Pj2&gt;
        _NODISCARD constexpr subrange&lt;_It1&gt; operator()(_It1 _First1, _Se1 _Last1, _It2 _First2, _Se2 _Last2,
            _Pr _Pred = {}, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
            _Adl_verify_range(_First1, _Last1);
            _Adl_verify_range(_First2, _Last2);
            auto _UFirst1 = _Unwrap_iter&lt;_Se1&gt;(_STD move(_First1));
            auto _ULast1  = _Unwrap_sent&lt;_It1&gt;(_STD move(_Last1));
            auto _UFirst2 = _Unwrap_iter&lt;_Se2&gt;(_STD move(_First2));
            auto _ULast2  = _Unwrap_sent&lt;_It2&gt;(_STD move(_Last2));

            if constexpr (sized_sentinel_for&lt;_Se1, _It1&gt; &amp;&amp; sized_sentinel_for&lt;_Se2, _It2&gt;) {
                const auto _Count1 = _ULast1 - _UFirst1;
                const auto _Count2 = _ULast2 - _UFirst2;
                auto _UResult = _Search_sized(_STD move(_UFirst1), _STD move(_ULast1), _Count1, _STD move(_UFirst2),
                    _STD move(_ULast2), _Count2, _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
                return _Rewrap_subrange&lt;subrange&lt;_It1&gt;&gt;(_First1, _STD move(_UResult));
            } else {
                auto _UResult = _Search_unsized(_STD move(_UFirst1), _STD move(_ULast1), _STD move(_UFirst2),
                    _STD move(_ULast2), _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
                return _Rewrap_subrange&lt;subrange&lt;_It1&gt;&gt;(_First1, _STD move(_UResult));
            }
        }

        template &lt;forward_range _Rng1, forward_range _Rng2, class _Pr = ranges::equal_to, class _Pj1 = identity,
            class _Pj2 = identity&gt;
            requires indirectly_comparable&lt;iterator_t&lt;_Rng1&gt;, iterator_t&lt;_Rng2&gt;, _Pr, _Pj1, _Pj2&gt;
        _NODISCARD constexpr borrowed_subrange_t&lt;_Rng1&gt; operator()(
            _Rng1&amp;&amp; _Range1, _Rng2&amp;&amp; _Range2, _Pr _Pred = {}, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
            if constexpr (sized_range&lt;_Rng1&gt; &amp;&amp; sized_range&lt;_Rng2&gt;) {
                const auto _Count1 = _RANGES distance(_Range1);
                const auto _Count2 = _RANGES distance(_Range2);
                auto _UResult      = _Search_sized(_Ubegin(_Range1), _Uend(_Range1), _Count1, _Ubegin(_Range2),
                         _Uend(_Range2), _Count2, _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
                return _Rewrap_subrange&lt;borrowed_subrange_t&lt;_Rng1&gt;&gt;(_Range1, _STD move(_UResult));
            } else {
                auto _UResult = _Search_unsized(_Ubegin(_Range1), _Uend(_Range1), _Ubegin(_Range2), _Uend(_Range2),
                    _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
                return _Rewrap_subrange&lt;borrowed_subrange_t&lt;_Rng1&gt;&gt;(_Range1, _STD move(_UResult));
            }
        }

    private:
        template &lt;class _It1, class _Se1, class _It2, class _Se2, class _Pr, class _Pj1, class _Pj2&gt;
        _NODISCARD static constexpr subrange&lt;_It1&gt; _Search_sized(_It1 _First1, const _Se1 _Last1,
            iter_difference_t&lt;_It1&gt; _Count1, _It2 _First2, const _Se2 _Last2, const iter_difference_t&lt;_It2&gt; _Count2,
            _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
            _STL_INTERNAL_STATIC_ASSERT(forward_iterator&lt;_It1&gt;);
            _STL_INTERNAL_STATIC_ASSERT(sentinel_for&lt;_Se1, _It1&gt;);
            _STL_INTERNAL_STATIC_ASSERT(forward_iterator&lt;_It2&gt;);
            _STL_INTERNAL_STATIC_ASSERT(sentinel_for&lt;_Se2, _It2&gt;);
            _STL_INTERNAL_STATIC_ASSERT(indirectly_comparable&lt;_It1, _It2, _Pr, _Pj1, _Pj2&gt;);
            _STL_INTERNAL_CHECK(_RANGES distance(_First1, _Last1) == _Count1);
            _STL_INTERNAL_CHECK(_RANGES distance(_First2, _Last2) == _Count2);

            for (; _Count1 &gt;= _Count2; ++_First1, (void) --_Count1) {
                auto [_Match, _Mid1] = _RANGES _Equal_rev_pred(_First1, _First2, _Last2, _Pred, _Proj1, _Proj2);
                if (_Match) {
                    return {_STD move(_First1), _STD move(_Mid1)};
                }
            }

            _First1 = _Find_last_iterator(_First1, _Last1, _Count1);
            return {_First1, _First1};
        }

        template &lt;class _It1, class _Se1, class _It2, class _Se2, class _Pr, class _Pj1, class _Pj2&gt;
        _NODISCARD static constexpr subrange&lt;_It1&gt; _Search_unsized(
            _It1 _First1, const _Se1 _Last1, _It2 _First2, const _Se2 _Last2, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
            _STL_INTERNAL_STATIC_ASSERT(forward_iterator&lt;_It1&gt;);
            _STL_INTERNAL_STATIC_ASSERT(sentinel_for&lt;_Se1, _It1&gt;);
            _STL_INTERNAL_STATIC_ASSERT(forward_iterator&lt;_It2&gt;);
            _STL_INTERNAL_STATIC_ASSERT(sentinel_for&lt;_Se2, _It2&gt;);
            _STL_INTERNAL_STATIC_ASSERT(indirectly_comparable&lt;_It1, _It2, _Pr, _Pj1, _Pj2&gt;);

            for (;; ++_First1) {
                auto _Mid1 = _First1;
                for (auto _Mid2 = _First2;; ++_Mid1, (void) ++_Mid2) {
                    if (_Mid2 == _Last2) { // match
                        return {_STD move(_First1), _STD move(_Mid1)};
                    }

                    if (_Mid1 == _Last1) { // not enough haystack left to find a match
                        return {_Mid1, _Mid1};
                    }

                    if (!_STD invoke(_Pred, _STD invoke(_Proj1, *_Mid1), _STD invoke(_Proj2, *_Mid2))) { // mismatch
                        break;
                    }
                }
            }
        }
    };

    _EXPORT_STD inline constexpr _Search_fn search{_Not_quite_object::_Construct_tag {}};
} // namespace ranges
#endif // __cpp_lib_concepts

template &lt;class _Iter, class _Pr, class _Elem = _Iter_value_t&lt;_Iter&gt;&gt;
_INLINE_VAR constexpr bool _Is_min_max_optimization_safe = // Activate the vector algorithms for min_/max_element?
    _Iterator_is_contiguous&lt;_Iter&gt; // The iterator must be contiguous so we can get raw pointers.
    &amp;&amp; !_Iterator_is_volatile&lt;_Iter&gt; // The iterator must not be volatile.
    &amp;&amp; conjunction_v&lt;disjunction&lt;is_integral&lt;_Elem&gt;, is_pointer&lt;_Elem&gt;&gt;, // Element is of integral or pointer type.
        disjunction&lt; // And either of the following:
#ifdef __cpp_lib_concepts
            is_same&lt;_Pr, _RANGES less&gt;, // predicate is ranges::less
#endif // __cpp_lib_concepts
            is_same&lt;_Pr, less&lt;&gt;&gt;, is_same&lt;_Pr, less&lt;_Elem&gt;&gt;&gt;&gt;; // predicate is less

template &lt;class _FwdIt, class _Pr&gt;
constexpr _FwdIt _Max_element_unchecked(_FwdIt _First, _FwdIt _Last, _Pr _Pred) { // find largest element
#if _USE_STD_VECTOR_ALGORITHMS
    if constexpr (_Is_min_max_optimization_safe&lt;_FwdIt, _Pr&gt;) {
        if (!_Is_constant_evaluated()) {
            const auto _First_ptr = _To_address(_First);
            const auto _Result    = __std_max_element(_First_ptr, _To_address(_Last));
            if constexpr (is_pointer_v&lt;_FwdIt&gt;) {
                return _Result;
            } else {
                return _First + (_Result - _First_ptr);
            }
        }
    }
#endif // _USE_STD_VECTOR_ALGORITHMS

    _FwdIt _Found = _First;
    if (_First != _Last) {
        while (++_First != _Last) {
            if (_DEBUG_LT_PRED(_Pred, *_Found, *_First)) {
                _Found = _First;
            }
        }
    }

    return _Found;
}

_EXPORT_STD template &lt;class _FwdIt, class _Pr&gt;
_NODISCARD constexpr _FwdIt max_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred) { // find largest element
    _Adl_verify_range(_First, _Last);
    _Seek_wrapped(_First, _STD _Max_element_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Pass_fn(_Pred)));
    return _First;
}

_EXPORT_STD template &lt;class _FwdIt&gt;
_NODISCARD constexpr _FwdIt max_element(_FwdIt _First, _FwdIt _Last) { // find largest element
    return _STD max_element(_First, _Last, less&lt;&gt;{});
}

#if _HAS_CXX17
_EXPORT_STD template &lt;class _ExPo, class _FwdIt, class _Pr, _Enable_if_execution_policy_t&lt;_ExPo&gt; = 0&gt;
_NODISCARD _FwdIt max_element(_ExPo&amp;&amp;, _FwdIt _First, _FwdIt _Last, _Pr _Pred) noexcept /* terminates */ {
    // find largest element
    // not parallelized at present, parallelism expected to be feasible in a future release
    return _STD max_element(_First, _Last, _Pass_fn(_Pred));
}

_EXPORT_STD template &lt;class _ExPo, class _FwdIt, _Enable_if_execution_policy_t&lt;_ExPo&gt; = 0&gt;
_NODISCARD _FwdIt max_element(_ExPo&amp;&amp;, _FwdIt _First, _FwdIt _Last) noexcept /* terminates */ {
    // find largest element
    // not parallelized at present, parallelism expected to be feasible in a future release
    return _STD max_element(_First, _Last);
}

#ifdef __cpp_lib_concepts
namespace ranges {
    template &lt;class _It, class _Se, class _Pr, class _Pj&gt;
    _NODISCARD constexpr _It _Max_element_unchecked(_It _First, const _Se _Last, _Pr _Pred, _Pj _Proj) {
        _STL_INTERNAL_STATIC_ASSERT(forward_iterator&lt;_It&gt;);
        _STL_INTERNAL_STATIC_ASSERT(sentinel_for&lt;_Se, _It&gt;);
        _STL_INTERNAL_STATIC_ASSERT(indirect_strict_weak_order&lt;_Pr, projected&lt;_It, _Pj&gt;&gt;);

#if _USE_STD_VECTOR_ALGORITHMS
        if constexpr (is_same_v&lt;_Pj, identity&gt; &amp;&amp; _Is_min_max_optimization_safe&lt;_It, _Pr&gt;
                      &amp;&amp; sized_sentinel_for&lt;_Se, _It&gt;) {
            if (!_STD is_constant_evaluated()) {
                const auto _First_ptr = _STD to_address(_First);
                const auto _Last_ptr  = _First_ptr + (_Last - _First);
                const auto _Result    = __std_max_element(_First_ptr, _Last_ptr);
                if constexpr (is_pointer_v&lt;_It&gt;) {
                    return _Result;
                } else {
                    return _First + (_Result - _First_ptr);
                }
            }
        }
#endif // _USE_STD_VECTOR_ALGORITHMS

        auto _Found = _First;
        if (_First == _Last) {
            return _Found;
        }

        while (++_First != _Last) {
            if (_STD invoke(_Pred, _STD invoke(_Proj, *_Found), _STD invoke(_Proj, *_First))) {
                _Found = _First;
            }
        }

        return _Found;
    }

    class _Max_element_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template &lt;forward_iterator _It, sentinel_for&lt;_It&gt; _Se, class _Pj = identity,
            indirect_strict_weak_order&lt;projected&lt;_It, _Pj&gt;&gt; _Pr = ranges::less&gt;
        _NODISCARD constexpr _It operator()(_It _First, _Se _Last, _Pr _Pred = {}, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);
            _Seek_wrapped(_First, _RANGES _Max_element_unchecked(_Unwrap_iter&lt;_Se&gt;(_STD move(_First)),
                                      _Unwrap_sent&lt;_It&gt;(_STD move(_Last)), _Pass_fn(_Pred), _Pass_fn(_Proj)));
            return _First;
        }

        template &lt;forward_range _Rng, class _Pj = identity,
            indirect_strict_weak_order&lt;projected&lt;iterator_t&lt;_Rng&gt;, _Pj&gt;&gt; _Pr = ranges::less&gt;
        _NODISCARD constexpr borrowed_iterator_t&lt;_Rng&gt; operator()(_Rng&amp;&amp; _Range, _Pr _Pred = {}, _Pj _Proj = {}) const {
            auto _First = _RANGES begin(_Range);
            _Seek_wrapped(_First, _RANGES _Max_element_unchecked(_Unwrap_range_iter&lt;_Rng&gt;(_STD move(_First)),
                                      _Uend(_Range), _Pass_fn(_Pred), _Pass_fn(_Proj)));
            return _First;
        }
    };

    _EXPORT_STD inline constexpr _Max_element_fn max_element{_Not_quite_object::_Construct_tag {}};
} // namespace ranges
#endif // __cpp_lib_concepts
#endif // _HAS_CXX17

_EXPORT_STD template &lt;class _Ty, class _Pr&gt;
_NODISCARD constexpr _Ty(max)(initializer_list&lt;_Ty&gt; _Ilist, _Pr _Pred) {
    // return leftmost/largest
    const _Ty* _Res = _STD _Max_element_unchecked(_Ilist.begin(), _Ilist.end(), _Pass_fn(_Pred));
    return *_Res;
}

_EXPORT_STD template &lt;class _Ty&gt;
_NODISCARD constexpr _Ty(max)(initializer_list&lt;_Ty&gt; _Ilist) {
    // return leftmost/largest
    return (_STD max)(_Ilist, less&lt;&gt;{});
}

#ifdef __cpp_lib_concepts
namespace ranges {
    template &lt;class _It&gt;
    concept _Prefer_iterator_copies = // When we have a choice, should we copy iterators or copy elements?
                                      // pre: input_iterator&lt;_It&gt;
        sizeof(_It) &lt;= 2 * sizeof(iter_value_t&lt;_It&gt;)
        &amp;&amp; (is_trivially_copyable_v&lt;_It&gt; || !is_trivially_copyable_v&lt;iter_value_t&lt;_It&gt;&gt;);

    class _Max_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template &lt;class _Ty, class _Pj = identity,
            indirect_strict_weak_order&lt;projected&lt;const _Ty*, _Pj&gt;&gt; _Pr = ranges::less&gt;
        _NODISCARD constexpr const _Ty&amp; operator()(
            const _Ty&amp; _Left, const _Ty&amp; _Right, _Pr _Pred = {}, _Pj _Proj = {}) const {
            if (_STD invoke(_Pred, _STD invoke(_Proj, _Left), _STD invoke(_Proj, _Right))) {
                return _Right;
            } else {
                return _Left;
            }
        }

        template &lt;copyable _Ty, class _Pj = identity,
            indirect_strict_weak_order&lt;projected&lt;const _Ty*, _Pj&gt;&gt; _Pr = ranges::less&gt;
        _NODISCARD constexpr _Ty operator()(initializer_list&lt;_Ty&gt; _Range, _Pr _Pred = {}, _Pj _Proj = {}) const {
            const auto _First = _Range.begin();
            const auto _Last  = _Range.end();
            _STL_ASSERT(_First != _Last,
                "An initializer_list passed to std::ranges::max must not be empty. (N4861 [alg.min.max]/13)");
            return *_RANGES _Max_element_unchecked(_First, _Last, _Pass_fn(_Pred), _Pass_fn(_Proj));
        }

        template &lt;input_range _Rng, class _Pj = identity,
            indirect_strict_weak_order&lt;projected&lt;iterator_t&lt;_Rng&gt;, _Pj&gt;&gt; _Pr = ranges::less&gt;
            requires indirectly_copyable_storable&lt;iterator_t&lt;_Rng&gt;, range_value_t&lt;_Rng&gt;*&gt;
        _NODISCARD constexpr range_value_t&lt;_Rng&gt; operator()(_Rng&amp;&amp; _Range, _Pr _Pred = {}, _Pj _Proj = {}) const {
            auto _UFirst = _Ubegin(_Range);
            auto _ULast  = _Uend(_Range);
            _STL_ASSERT(
                _UFirst != _ULast, "A range passed to std::ranges::max must not be empty. (N4861 [alg.min.max]/13)");
            if constexpr (forward_range&lt;_Rng&gt; &amp;&amp; _Prefer_iterator_copies&lt;iterator_t&lt;_Rng&gt;&gt;) {
                return static_cast&lt;range_value_t&lt;_Rng&gt;&gt;(*_RANGES _Max_element_unchecked(
                    _STD move(_UFirst), _STD move(_ULast), _Pass_fn(_Pred), _Pass_fn(_Proj)));
            } else {
                range_value_t&lt;_Rng&gt; _Found(*_UFirst);
                while (++_UFirst != _ULast) {
                    if (_STD invoke(_Pred, _STD invoke(_Proj, _Found), _STD invoke(_Proj, *_UFirst))) {
                        _Found = *_UFirst;
                    }
                }

                return _Found;
            }
        }
    };

    _EXPORT_STD inline constexpr _Max_fn max{_Not_quite_object::_Construct_tag {}};
} // namespace ranges
#endif // __cpp_lib_concepts

template &lt;class _FwdIt, class _Pr&gt;
constexpr _FwdIt _Min_element_unchecked(_FwdIt _First, _FwdIt _Last, _Pr _Pred) { // find smallest element
#if _USE_STD_VECTOR_ALGORITHMS
    if constexpr (_Is_min_max_optimization_safe&lt;_FwdIt, _Pr&gt;) {
        if (!_Is_constant_evaluated()) {
            const auto _First_ptr = _To_address(_First);
            const auto _Result    = __std_min_element(_First_ptr, _To_address(_Last));
            if constexpr (is_pointer_v&lt;_FwdIt&gt;) {
                return _Result;
            } else {
                return _First + (_Result - _First_ptr);
            }
        }
    }
#endif // _USE_STD_VECTOR_ALGORITHMS

    _FwdIt _Found = _First;
    if (_First != _Last) {
        while (++_First != _Last) {
            if (_DEBUG_LT_PRED(_Pred, *_First, *_Found)) {
                _Found = _First;
            }
        }
    }

    return _Found;
}

_EXPORT_STD template &lt;class _FwdIt, class _Pr&gt;
_NODISCARD constexpr _FwdIt min_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred) { // find smallest element
    _Adl_verify_range(_First, _Last);
    _Seek_wrapped(_First, _STD _Min_element_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Pass_fn(_Pred)));
    return _First;
}

_EXPORT_STD template &lt;class _FwdIt&gt;
_NODISCARD constexpr _FwdIt min_element(_FwdIt _First, _FwdIt _Last) { // find smallest element
    return _STD min_element(_First, _Last, less&lt;&gt;{});
}

#if _HAS_CXX17
_EXPORT_STD template &lt;class _ExPo, class _FwdIt, class _Pr, _Enable_if_execution_policy_t&lt;_ExPo&gt; = 0&gt;
_NODISCARD _FwdIt min_element(_ExPo&amp;&amp;, _FwdIt _First, _FwdIt _Last, _Pr _Pred) noexcept /* terminates */ {
    // find smallest element
    // not parallelized at present, parallelism expected to be feasible in a future release
    return _STD min_element(_First, _Last, _Pass_fn(_Pred));
}

_EXPORT_STD template &lt;class _ExPo, class _FwdIt, _Enable_if_execution_policy_t&lt;_ExPo&gt; = 0&gt;
_NODISCARD _FwdIt min_element(_ExPo&amp;&amp;, _FwdIt _First, _FwdIt _Last) noexcept /* terminates */ {
    // find smallest element
    // not parallelized at present, parallelism expected to be feasible in a future release
    return _STD min_element(_First, _Last);
}

#ifdef __cpp_lib_concepts
namespace ranges {
    template &lt;class _It, class _Se, class _Pr, class _Pj&gt;
    _NODISCARD constexpr _It _Min_element_unchecked(_It _First, const _Se _Last, _Pr _Pred, _Pj _Proj) {
        _STL_INTERNAL_STATIC_ASSERT(forward_iterator&lt;_It&gt;);
        _STL_INTERNAL_STATIC_ASSERT(sentinel_for&lt;_Se, _It&gt;);
        _STL_INTERNAL_STATIC_ASSERT(indirect_strict_weak_order&lt;_Pr, projected&lt;_It, _Pj&gt;&gt;);

#if _USE_STD_VECTOR_ALGORITHMS
        if constexpr (is_same_v&lt;_Pj, identity&gt; &amp;&amp; _Is_min_max_optimization_safe&lt;_It, _Pr&gt;
                      &amp;&amp; sized_sentinel_for&lt;_Se, _It&gt;) {
            if (!_STD is_constant_evaluated()) {
                const auto _First_ptr = _STD to_address(_First);
                const auto _Last_ptr  = _First_ptr + (_Last - _First);
                const auto _Result    = __std_min_element(_First_ptr, _Last_ptr);
                if constexpr (is_pointer_v&lt;_It&gt;) {
                    return _Result;
                } else {
                    return _First + (_Result - _First_ptr);
                }
            }
        }
#endif // _USE_STD_VECTOR_ALGORITHMS

        auto _Found = _First;
        if (_First == _Last) {
            return _Found;
        }

        while (++_First != _Last) {
            if (_STD invoke(_Pred, _STD invoke(_Proj, *_First), _STD invoke(_Proj, *_Found))) {
                _Found = _First;
            }
        }

        return _Found;
    }

    class _Min_element_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template &lt;forward_iterator _It, sentinel_for&lt;_It&gt; _Se, class _Pj = identity,
            indirect_strict_weak_order&lt;projected&lt;_It, _Pj&gt;&gt; _Pr = ranges::less&gt;
        _NODISCARD constexpr _It operator()(_It _First, _Se _Last, _Pr _Pred = {}, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);
            _Seek_wrapped(_First, _RANGES _Min_element_unchecked(_Unwrap_iter&lt;_Se&gt;(_STD move(_First)),
                                      _Unwrap_sent&lt;_It&gt;(_STD move(_Last)), _Pass_fn(_Pred), _Pass_fn(_Proj)));
            return _First;
        }

        template &lt;forward_range _Rng, class _Pj = identity,
            indirect_strict_weak_order&lt;projected&lt;iterator_t&lt;_Rng&gt;, _Pj&gt;&gt; _Pr = ranges::less&gt;
        _NODISCARD constexpr borrowed_iterator_t&lt;_Rng&gt; operator()(_Rng&amp;&amp; _Range, _Pr _Pred = {}, _Pj _Proj = {}) const {
            auto _First = _RANGES begin(_Range);
            _Seek_wrapped(_First, _RANGES _Min_element_unchecked(_Unwrap_range_iter&lt;_Rng&gt;(_STD move(_First)),
                                      _Uend(_Range), _Pass_fn(_Pred), _Pass_fn(_Proj)));
            return _First;
        }
    };

    _EXPORT_STD inline constexpr _Min_element_fn min_element{_Not_quite_object::_Construct_tag {}};
} // namespace ranges
#endif // __cpp_lib_concepts
#endif // _HAS_CXX17

_EXPORT_STD template &lt;class _Ty, class _Pr&gt;
_NODISCARD constexpr _Ty(min)(initializer_list&lt;_Ty&gt; _Ilist, _Pr _Pred) {
    // return leftmost/smallest
    const _Ty* _Res = _STD _Min_element_unchecked(_Ilist.begin(), _Ilist.end(), _Pass_fn(_Pred));
    return *_Res;
}

_EXPORT_STD template &lt;class _Ty&gt;
_NODISCARD constexpr _Ty(min)(initializer_list&lt;_Ty&gt; _Ilist) {
    // return leftmost/smallest
    return (_STD min)(_Ilist, less&lt;&gt;{});
}

#ifdef __cpp_lib_concepts
namespace ranges {
    class _Min_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template &lt;class _Ty, class _Pj = identity,
            indirect_strict_weak_order&lt;projected&lt;const _Ty*, _Pj&gt;&gt; _Pr = ranges::less&gt;
        _NODISCARD constexpr const _Ty&amp; operator()(
            const _Ty&amp; _Left, const _Ty&amp; _Right, _Pr _Pred = {}, _Pj _Proj = {}) const {
            if (_STD invoke(_Pred, _STD invoke(_Proj, _Right), _STD invoke(_Proj, _Left))) {
                return _Right;
            } else {
                return _Left;
            }
        }

        template &lt;copyable _Ty, class _Pj = identity,
            indirect_strict_weak_order&lt;projected&lt;const _Ty*, _Pj&gt;&gt; _Pr = ranges::less&gt;
        _NODISCARD constexpr _Ty operator()(initializer_list&lt;_Ty&gt; _Range, _Pr _Pred = {}, _Pj _Proj = {}) const {
            const auto _First = _Range.begin();
            const auto _Last  = _Range.end();
            _STL_ASSERT(_First != _Last,
                "An initializer_list passed to std::ranges::min must not be empty. (N4861 [alg.min.max]/5)");
            return *_RANGES _Min_element_unchecked(_First, _Last, _Pass_fn(_Pred), _Pass_fn(_Proj));
        }

        template &lt;input_range _Rng, class _Pj = identity,
            indirect_strict_weak_order&lt;projected&lt;iterator_t&lt;_Rng&gt;, _Pj&gt;&gt; _Pr = ranges::less&gt;
            requires indirectly_copyable_storable&lt;iterator_t&lt;_Rng&gt;, range_value_t&lt;_Rng&gt;*&gt;
        _NODISCARD constexpr range_value_t&lt;_Rng&gt; operator()(_Rng&amp;&amp; _Range, _Pr _Pred = {}, _Pj _Proj = {}) const {
            auto _UFirst = _Ubegin(_Range);
            auto _ULast  = _Uend(_Range);
            _STL_ASSERT(
                _UFirst != _ULast, "A range passed to std::ranges::min must not be empty. (N4861 [alg.min.max]/5)");
            if constexpr (forward_range&lt;_Rng&gt; &amp;&amp; _Prefer_iterator_copies&lt;iterator_t&lt;_Rng&gt;&gt;) {
                return static_cast&lt;range_value_t&lt;_Rng&gt;&gt;(*_RANGES _Min_element_unchecked(
                    _STD move(_UFirst), _STD move(_ULast), _Pass_fn(_Pred), _Pass_fn(_Proj)));
            } else {
                range_value_t&lt;_Rng&gt; _Found(*_UFirst);
                while (++_UFirst != _ULast) {
                    if (_STD invoke(_Pred, _STD invoke(_Proj, *_UFirst), _STD invoke(_Proj, _Found))) {
                        _Found = *_UFirst;
                    }
                }

                return _Found;
            }
        }
    };

    _EXPORT_STD inline constexpr _Min_fn min{_Not_quite_object::_Construct_tag {}};
} // namespace ranges
#endif // __cpp_lib_concepts

_EXPORT_STD template &lt;class _FwdIt, class _Ty, class _Pr&gt;
_NODISCARD _CONSTEXPR20 _FwdIt lower_bound(_FwdIt _First, const _FwdIt _Last, const _Ty&amp; _Val, _Pr _Pred) {
    // find first element not before _Val
    _Adl_verify_range(_First, _Last);
    auto _UFirst                = _Get_unwrapped(_First);
    _Iter_diff_t&lt;_FwdIt&gt; _Count = _STD distance(_UFirst, _Get_unwrapped(_Last));

    while (0 &lt; _Count) { // divide and conquer, find half that contains answer
        const _Iter_diff_t&lt;_FwdIt&gt; _Count2 = _Count / 2;
        const auto _UMid                   = _STD next(_UFirst, _Count2);
        if (_Pred(*_UMid, _Val)) { // try top half
            _UFirst = _Next_iter(_UMid);
            _Count -= _Count2 + 1;
        } else {
            _Count = _Count2;
        }
    }

    _Seek_wrapped(_First, _UFirst);
    return _First;
}

_EXPORT_STD template &lt;class _FwdIt, class _Ty&gt;
_NODISCARD _CONSTEXPR20 _FwdIt lower_bound(_FwdIt _First, _FwdIt _Last, const _Ty&amp; _Val) {
    // find first element not before _Val
    return _STD lower_bound(_First, _Last, _Val, less&lt;&gt;{});
}

_EXPORT_STD template &lt;class _FwdIt, class _Ty, class _Pr&gt;
_NODISCARD _CONSTEXPR20 _FwdIt upper_bound(_FwdIt _First, _FwdIt _Last, const _Ty&amp; _Val, _Pr _Pred) {
    // find first element that _Val is before
    _Adl_verify_range(_First, _Last);
    auto _UFirst                = _Get_unwrapped(_First);
    _Iter_diff_t&lt;_FwdIt&gt; _Count = _STD distance(_UFirst, _Get_unwrapped(_Last));

    while (0 &lt; _Count) { // divide and conquer, find half that contains answer
        _Iter_diff_t&lt;_FwdIt&gt; _Count2 = _Count / 2;
        const auto _UMid             = _STD next(_UFirst, _Count2);
        if (_Pred(_Val, *_UMid)) {
            _Count = _Count2;
        } else { // try top half
            _UFirst = _Next_iter(_UMid);
            _Count -= _Count2 + 1;
        }
    }

    _Seek_wrapped(_First, _UFirst);
    return _First;
}

_EXPORT_STD template &lt;class _FwdIt, class _Ty&gt;
_NODISCARD _CONSTEXPR20 _FwdIt upper_bound(_FwdIt _First, _FwdIt _Last, const _Ty&amp; _Val) {
    // find first element that _Val is before
    return _STD upper_bound(_First, _Last, _Val, less&lt;&gt;{});
}

template &lt;class _FwdIt1, class _FwdIt2&gt;
_CONSTEXPR20 _FwdIt2 _Swap_ranges_unchecked(_FwdIt1 _First1, const _FwdIt1 _Last1, _FwdIt2 _First2) {
    // swap [_First1, _Last1) with [_First2, ...)

#if _USE_STD_VECTOR_ALGORITHMS
    using _Elem1 = remove_reference_t&lt;_Iter_ref_t&lt;_FwdIt1&gt;&gt;;
    using _Elem2 = remove_reference_t&lt;_Iter_ref_t&lt;_FwdIt2&gt;&gt;;
    if constexpr (is_same_v&lt;_Elem1, _Elem2&gt; &amp;&amp; _Is_trivially_swappable_v&lt;_Elem1&gt;
                  &amp;&amp; _Iterators_are_contiguous&lt;_FwdIt1, _FwdIt2&gt;) {
#if _HAS_CXX20
        if (!_STD is_constant_evaluated())
#endif // _HAS_CXX20
        {
            __std_swap_ranges_trivially_swappable_noalias(
                _To_address(_First1), _To_address(_Last1), _To_address(_First2));
            return _First2 + (_Last1 - _First1);
        }
    }
#endif // _USE_STD_VECTOR_ALGORITHMS

    for (; _First1 != _Last1; ++_First1, (void) ++_First2) {
        _STD iter_swap(_First1, _First2);
    }

    return _First2;
}

extern "C++" [[noreturn]] _CRTIMP2_PURE void __CLRCALL_PURE_OR_CDECL _Xbad_alloc();
extern "C++" [[noreturn]] _CRTIMP2_PURE void __CLRCALL_PURE_OR_CDECL _Xinvalid_argument(_In_z_ const char*);
extern "C++" [[noreturn]] _CRTIMP2_PURE void __CLRCALL_PURE_OR_CDECL _Xlength_error(_In_z_ const char*);
extern "C++" [[noreturn]] _CRTIMP2_PURE void __CLRCALL_PURE_OR_CDECL _Xout_of_range(_In_z_ const char*);
extern "C++" [[noreturn]] _CRTIMP2_PURE void __CLRCALL_PURE_OR_CDECL _Xoverflow_error(_In_z_ const char*);
extern "C++" [[noreturn]] _CRTIMP2_PURE void __CLRCALL_PURE_OR_CDECL _Xruntime_error(_In_z_ const char*);
extern "C++" [[noreturn]] _CRTIMP2_PURE void __CLRCALL_PURE_OR_CDECL _XGetLastError();

_EXPORT_STD template &lt;class _Category, class _Ty, class _Diff = ptrdiff_t, class _Pointer = _Ty*,
    class _Reference = _Ty&amp;&gt;
struct _CXX17_DEPRECATE_ITERATOR_BASE_CLASS iterator { // base type for iterator classes
    using iterator_category = _Category;
    using value_type        = _Ty;
    using difference_type   = _Diff;
    using pointer           = _Pointer;
    using reference         = _Reference;
};

template &lt;class _Ty, enable_if_t&lt;is_floating_point_v&lt;_Ty&gt;, int&gt; = 0&gt;
_NODISCARD constexpr auto _Float_abs_bits(const _Ty&amp; _Xx) {
    using _Traits    = _Floating_type_traits&lt;_Ty&gt;;
    using _Uint_type = typename _Traits::_Uint_type;
    const auto _Bits = _Bit_cast&lt;_Uint_type&gt;(_Xx);
    return _Bits &amp; ~_Traits::_Shifted_sign_mask;
}

template &lt;class _Ty, enable_if_t&lt;is_floating_point_v&lt;_Ty&gt;, int&gt; = 0&gt;
_NODISCARD constexpr _Ty _Float_abs(const _Ty _Xx) { // constexpr floating-point abs()
    return _Bit_cast&lt;_Ty&gt;(_Float_abs_bits(_Xx));
}

template &lt;class _Ty, enable_if_t&lt;is_floating_point_v&lt;_Ty&gt;, int&gt; = 0&gt;
_NODISCARD constexpr _Ty _Float_copysign(const _Ty _Magnitude, const _Ty _Sign) { // constexpr copysign()
    using _Traits       = _Floating_type_traits&lt;_Ty&gt;;
    using _Uint_type    = typename _Traits::_Uint_type;
    const auto _Signbit = _Bit_cast&lt;_Uint_type&gt;(_Sign) &amp; _Traits::_Shifted_sign_mask;
    return _Bit_cast&lt;_Ty&gt;(_Float_abs_bits(_Magnitude) | _Signbit);
}

template &lt;class _Ty, enable_if_t&lt;is_floating_point_v&lt;_Ty&gt;, int&gt; = 0&gt;
_NODISCARD constexpr bool _Is_nan(const _Ty _Xx) { // constexpr isnan()
    using _Traits = _Floating_type_traits&lt;_Ty&gt;;
    return _Float_abs_bits(_Xx) &gt; _Traits::_Shifted_exponent_mask;
}

// TRANSITION, workaround x86 ABI
// On x86 ABI, floating-point by-value arguments and return values are passed in 80-bit x87 registers.
// When the value is a 32-bit or 64-bit signaling NaN, the conversion to/from 80-bit raises FE_INVALID
// and turns it into a quiet NaN. This behavior is undesirable if we want to test for signaling NaNs.
template &lt;class _Ty, enable_if_t&lt;is_floating_point_v&lt;_Ty&gt;, int&gt; = 0&gt;
_NODISCARD constexpr bool _Is_signaling_nan(const _Ty&amp; _Xx) { // returns true if input is a signaling NaN
    using _Traits        = _Floating_type_traits&lt;_Ty&gt;;
    const auto _Abs_bits = _Float_abs_bits(_Xx);
    return _Abs_bits &gt; _Traits::_Shifted_exponent_mask &amp;&amp; ((_Abs_bits &amp; _Traits::_Special_nan_mantissa_mask) == 0);
}

template &lt;class _Ty, enable_if_t&lt;is_floating_point_v&lt;_Ty&gt;, int&gt; = 0&gt;
_NODISCARD constexpr bool _Is_inf(const _Ty _Xx) { // constexpr isinf()
    using _Traits = _Floating_type_traits&lt;_Ty&gt;;
    return _Float_abs_bits(_Xx) == _Traits::_Shifted_exponent_mask;
}

template &lt;class _Ty, enable_if_t&lt;is_floating_point_v&lt;_Ty&gt;, int&gt; = 0&gt;
_NODISCARD constexpr bool _Is_finite(const _Ty _Xx) { // constexpr isfinite()
    using _Traits = _Floating_type_traits&lt;_Ty&gt;;
    return _Float_abs_bits(_Xx) &lt; _Traits::_Shifted_exponent_mask;
}

#if _HAS_CXX17
_EXPORT_STD struct monostate {};
#endif // _HAS_CXX17

_STD_END
#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _XUTILITY_</pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>