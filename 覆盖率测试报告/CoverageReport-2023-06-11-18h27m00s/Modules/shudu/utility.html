<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>utility</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
// utility standard header (core)

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#pragma once
#ifndef _UTILITY_
#define _UTILITY_
#include &lt;yvals_core.h&gt;
#if _STL_COMPILER_PREPROCESSOR
#include &lt;type_traits&gt;
#include &lt;xstddef&gt;

#ifdef __cpp_lib_concepts
#include &lt;concepts&gt;
#endif // __cpp_lib_concepts

#if _HAS_CXX20
#include &lt;compare&gt;
#endif // _HAS_CXX20

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN
_EXPORT_STD template &lt;class _Ty, class _Pr&gt;
_NODISCARD constexpr const _Ty&amp;(max) (const _Ty&amp; _Left, const _Ty&amp; _Right, _Pr _Pred) noexcept(
    noexcept(_Pred(_Left, _Right))) /* strengthened */ {
    // return larger of _Left and _Right
    return _Pred(_Left, _Right) ? _Right : _Left;
}

#pragma warning(push)
#pragma warning(disable : 28285) // (syntax error in SAL annotation, occurs when _Ty is not an integral type)
_EXPORT_STD template &lt;class _Ty&gt;
_NODISCARD _Post_equal_to_(_Left &lt; _Right ? _Right : _Left) constexpr const _Ty&amp; //
<span style = "background-color:#fdd">    (max) (const _Ty&amp; _Left, const _Ty&amp; _Right) noexcept(noexcept(_Left &lt; _Right)) /* strengthened */ {</span>
    // return larger of _Left and _Right
<span style = "background-color:#fdd">    return _Left &lt; _Right ? _Right : _Left;
}</span>
#pragma warning(pop)

_EXPORT_STD template &lt;class _Ty, class _Pr&gt;
_NODISCARD constexpr _Ty(max)(initializer_list&lt;_Ty&gt;, _Pr); // implemented in &lt;algorithm&gt;

_EXPORT_STD template &lt;class _Ty&gt;
_NODISCARD constexpr _Ty(max)(initializer_list&lt;_Ty&gt;); // implemented in &lt;algorithm&gt;

_EXPORT_STD template &lt;class _Ty, class _Pr&gt;
_NODISCARD constexpr const _Ty&amp;(min) (const _Ty&amp; _Left, const _Ty&amp; _Right, _Pr _Pred) noexcept(
    noexcept(_Pred(_Right, _Left))) /* strengthened */ {
    // return smaller of _Left and _Right
    return _Pred(_Right, _Left) ? _Right : _Left;
}

#pragma warning(push)
#pragma warning(disable : 28285) // (syntax error in SAL annotation, occurs when _Ty is not an integral type)
_EXPORT_STD template &lt;class _Ty&gt;
_NODISCARD _Post_equal_to_(_Right &lt; _Left ? _Right : _Left) constexpr const _Ty&amp; //
<span style = "background-color:#fdd">    (min) (const _Ty&amp; _Left, const _Ty&amp; _Right) noexcept(noexcept(_Right &lt; _Left)) /* strengthened */ {</span>
    // return smaller of _Left and _Right
<span style = "background-color:#fdd">    return _Right &lt; _Left ? _Right : _Left;
}</span>
#pragma warning(pop)

_EXPORT_STD template &lt;class _Ty, class _Pr&gt;
_NODISCARD constexpr _Ty(min)(initializer_list&lt;_Ty&gt;, _Pr); // implemented in &lt;algorithm&gt;

_EXPORT_STD template &lt;class _Ty&gt;
_NODISCARD constexpr _Ty(min)(initializer_list&lt;_Ty&gt;); // implemented in &lt;algorithm&gt;

_EXPORT_STD template &lt;class _FwdIt1, class _FwdIt2&gt;
_CONSTEXPR20 void iter_swap(_FwdIt1 _Left, _FwdIt2 _Right) { // swap *_Left and *_Right
    swap(*_Left, *_Right);
}

_EXPORT_STD template &lt;class _Ty, size_t _Size, enable_if_t&lt;_Is_swappable&lt;_Ty&gt;::value, int&gt; _Enabled&gt;
_CONSTEXPR20 void swap(_Ty (&amp;_Left)[_Size], _Ty (&amp;_Right)[_Size]) noexcept(_Is_nothrow_swappable&lt;_Ty&gt;::value) {
    if (&amp;_Left != &amp;_Right) {
        _Ty* _First1 = _Left;
        _Ty* _Last1  = _First1 + _Size;
        _Ty* _First2 = _Right;
        for (; _First1 != _Last1; ++_First1, ++_First2) {
            _STD iter_swap(_First1, _First2);
        }
    }
}

#if _HAS_CXX17
_EXPORT_STD template &lt;class _Ty, enable_if_t&lt;is_move_constructible_v&lt;_Ty&gt; &amp;&amp; is_move_assignable_v&lt;_Ty&gt;, int&gt; _Enabled&gt;
#else // ^^^ _HAS_CXX17 / !_HAS_CXX17 vvv
template &lt;class _Ty, int _Enabled&gt;
#endif // _HAS_CXX17
_CONSTEXPR20 void swap(_Ty&amp; _Left, _Ty&amp; _Right) noexcept(
    is_nothrow_move_constructible_v&lt;_Ty&gt;&amp;&amp; is_nothrow_move_assignable_v&lt;_Ty&gt;) {
    _Ty _Tmp = _STD move(_Left);
    _Left    = _STD move(_Right);
    _Right   = _STD move(_Tmp);
}

template &lt;class _Ty&gt;
_CONSTEXPR20 void _Swap_adl(_Ty&amp; _Left, _Ty&amp; _Right) noexcept(_Is_nothrow_swappable&lt;_Ty&gt;::value) {
    swap(_Left, _Right);
}

_EXPORT_STD struct piecewise_construct_t { // tag type for pair tuple arguments
    explicit piecewise_construct_t() = default;
};

_EXPORT_STD _INLINE_VAR constexpr piecewise_construct_t piecewise_construct{};

template &lt;class _Ty, class _Alloc, class = void&gt;
struct _Has_allocator_type : false_type {}; // tests for suitable _Ty::allocator_type

template &lt;class _Ty, class _Alloc&gt;
struct _Has_allocator_type&lt;_Ty, _Alloc, void_t&lt;typename _Ty::allocator_type&gt;&gt;
    : is_convertible&lt;_Alloc, typename _Ty::allocator_type&gt;::type {}; // tests for suitable _Ty::allocator_type

_EXPORT_STD struct allocator_arg_t { // tag type for added allocator argument
    explicit allocator_arg_t() = default;
};

_EXPORT_STD _INLINE_VAR constexpr allocator_arg_t allocator_arg{};

_EXPORT_STD template &lt;class _Ty, class _Alloc&gt;
struct uses_allocator : _Has_allocator_type&lt;_Ty, _Alloc&gt;::type {
    // determine whether _Ty has an allocator_type member type
};

_EXPORT_STD template &lt;class _Ty, class _Alloc&gt;
_INLINE_VAR constexpr bool uses_allocator_v = uses_allocator&lt;_Ty, _Alloc&gt;::value;

_EXPORT_STD template &lt;class... _Types&gt;
class tuple;

_EXPORT_STD template &lt;class _Ty1, class _Ty2&gt;
struct pair;

_EXPORT_STD template &lt;class _Ty, size_t _Size&gt;
class array;

_EXPORT_STD template &lt;class _Tuple&gt;
struct tuple_size;

_EXPORT_STD template &lt;class _Ty&gt;
_INLINE_VAR constexpr size_t tuple_size_v = tuple_size&lt;_Ty&gt;::value;

_EXPORT_STD template &lt;size_t _Index, class _Tuple&gt;
struct tuple_element;

_EXPORT_STD template &lt;size_t _Index, class _Tuple&gt;
using tuple_element_t = typename tuple_element&lt;_Index, _Tuple&gt;::type;

_EXPORT_STD /* TRANSITION, VSO-1538698 */ template &lt;size_t _Index, class... _Types&gt;
_NODISCARD constexpr auto&amp;&amp; _Tuple_get(tuple&lt;_Types...&gt;&amp;&amp; _Tuple) noexcept;

_EXPORT_STD template &lt;size_t _Index, class... _Types&gt;
_NODISCARD constexpr tuple_element_t&lt;_Index, tuple&lt;_Types...&gt;&gt;&amp; get(tuple&lt;_Types...&gt;&amp; _Tuple) noexcept;

_EXPORT_STD template &lt;size_t _Index, class... _Types&gt;
_NODISCARD constexpr const tuple_element_t&lt;_Index, tuple&lt;_Types...&gt;&gt;&amp; get(const tuple&lt;_Types...&gt;&amp; _Tuple) noexcept;

_EXPORT_STD template &lt;size_t _Index, class... _Types&gt;
_NODISCARD constexpr tuple_element_t&lt;_Index, tuple&lt;_Types...&gt;&gt;&amp;&amp; get(tuple&lt;_Types...&gt;&amp;&amp; _Tuple) noexcept;

_EXPORT_STD template &lt;size_t _Index, class... _Types&gt;
_NODISCARD constexpr const tuple_element_t&lt;_Index, tuple&lt;_Types...&gt;&gt;&amp;&amp; get(const tuple&lt;_Types...&gt;&amp;&amp; _Tuple) noexcept;

_EXPORT_STD template &lt;size_t _Idx, class _Ty, size_t _Size&gt;
_NODISCARD constexpr _Ty&amp; get(array&lt;_Ty, _Size&gt;&amp; _Arr) noexcept;

_EXPORT_STD template &lt;size_t _Idx, class _Ty, size_t _Size&gt;
_NODISCARD constexpr const _Ty&amp; get(const array&lt;_Ty, _Size&gt;&amp; _Arr) noexcept;

_EXPORT_STD template &lt;size_t _Idx, class _Ty, size_t _Size&gt;
_NODISCARD constexpr _Ty&amp;&amp; get(array&lt;_Ty, _Size&gt;&amp;&amp; _Arr) noexcept;

_EXPORT_STD template &lt;size_t _Idx, class _Ty, size_t _Size&gt;
_NODISCARD constexpr const _Ty&amp;&amp; get(const array&lt;_Ty, _Size&gt;&amp;&amp; _Arr) noexcept;

#ifdef __cpp_lib_concepts
template &lt;class _Ty1, class _Ty2&gt;
concept _Different_from = (!same_as&lt;remove_cvref_t&lt;_Ty1&gt;, remove_cvref_t&lt;_Ty2&gt;&gt;);

template &lt;class&gt;
inline constexpr bool _Is_std_array_v = false;

template &lt;class _Ty, size_t _Size&gt;
inline constexpr bool _Is_std_array_v&lt;array&lt;_Ty, _Size&gt;&gt; = true;

template &lt;class&gt;
inline constexpr bool _Is_subrange_v = false;

#if _HAS_CXX23
template &lt;class _Ty&gt;
inline constexpr bool _Tuple_like_impl =
    _Is_specialization_v&lt;_Ty, tuple&gt; || _Is_specialization_v&lt;_Ty, pair&gt; || _Is_std_array_v&lt;_Ty&gt; || _Is_subrange_v&lt;_Ty&gt;;

template &lt;class _Ty&gt;
concept _Tuple_like = _Tuple_like_impl&lt;remove_cvref_t&lt;_Ty&gt;&gt;;

template &lt;class _Ty&gt;
concept _Pair_like = _Tuple_like&lt;_Ty&gt; &amp;&amp; tuple_size_v&lt;remove_cvref_t&lt;_Ty&gt;&gt; == 2;

#ifdef __clang__ // TRANSITION, LLVM-59827
template &lt;class _PairLike, class _Ty1, class _Ty2&gt;
concept _Can_construct_from_pair_like =
    _Pair_like&lt;_PairLike&gt; &amp;&amp; is_constructible_v&lt;_Ty1, decltype(_STD get&lt;0&gt;(_STD declval&lt;_PairLike&gt;()))&gt;
    &amp;&amp; is_constructible_v&lt;_Ty2, decltype(_STD get&lt;1&gt;(_STD declval&lt;_PairLike&gt;()))&gt;;
#endif // __clang__
#endif // _HAS_CXX23
#endif // __cpp_lib_concepts

_EXPORT_STD template &lt;class _Ty1, class _Ty2&gt;
struct pair { // store a pair of values
    using first_type  = _Ty1;
    using second_type = _Ty2;

    template &lt;class _Uty1 = _Ty1, class _Uty2 = _Ty2,
        enable_if_t&lt;conjunction_v&lt;is_default_constructible&lt;_Uty1&gt;, is_default_constructible&lt;_Uty2&gt;&gt;, int&gt; = 0&gt;
    constexpr explicit(
        !conjunction_v&lt;_Is_implicitly_default_constructible&lt;_Uty1&gt;, _Is_implicitly_default_constructible&lt;_Uty2&gt;&gt;)
        pair() noexcept(
            is_nothrow_default_constructible_v&lt;_Uty1&gt;&amp;&amp; is_nothrow_default_constructible_v&lt;_Uty2&gt;) // strengthened
        : first(), second() {}

    template &lt;class _Uty1 = _Ty1, class _Uty2 = _Ty2,
        enable_if_t&lt;conjunction_v&lt;is_copy_constructible&lt;_Uty1&gt;, is_copy_constructible&lt;_Uty2&gt;&gt;, int&gt; = 0&gt;
    constexpr explicit(!conjunction_v&lt;is_convertible&lt;const _Uty1&amp;, _Uty1&gt;, is_convertible&lt;const _Uty2&amp;, _Uty2&gt;&gt;)
        pair(const _Ty1&amp; _Val1, const _Ty2&amp; _Val2) noexcept(
            is_nothrow_copy_constructible_v&lt;_Uty1&gt;&amp;&amp; is_nothrow_copy_constructible_v&lt;_Uty2&gt;) // strengthened
        : first(_Val1), second(_Val2) {}

#if _HAS_CXX23
    template &lt;class _Other1 = _Ty1, class _Other2 = _Ty2,
#else // ^^^ _HAS_CXX23 / !_HAS_CXX23 vvv
    template &lt;class _Other1, class _Other2,
#endif // ^^^ !_HAS_CXX23 ^^^
        enable_if_t&lt;conjunction_v&lt;is_constructible&lt;_Ty1, _Other1&gt;, is_constructible&lt;_Ty2, _Other2&gt;&gt;, int&gt; = 0&gt;
    constexpr explicit(!conjunction_v&lt;is_convertible&lt;_Other1, _Ty1&gt;, is_convertible&lt;_Other2, _Ty2&gt;&gt;)
        pair(_Other1&amp;&amp; _Val1, _Other2&amp;&amp; _Val2) noexcept(
            is_nothrow_constructible_v&lt;_Ty1, _Other1&gt;&amp;&amp; is_nothrow_constructible_v&lt;_Ty2, _Other2&gt;) // strengthened
        : first(_STD forward&lt;_Other1&gt;(_Val1)), second(_STD forward&lt;_Other2&gt;(_Val2)) {
    }

    pair(const pair&amp;) = default;
    pair(pair&amp;&amp;)      = default;

#if _HAS_CXX23
    template &lt;class _Other1, class _Other2,
        enable_if_t&lt;conjunction_v&lt;is_constructible&lt;_Ty1, _Other1&amp;&gt;, is_constructible&lt;_Ty2, _Other2&amp;&gt;&gt;, int&gt; = 0&gt;
    constexpr explicit(!conjunction_v&lt;is_convertible&lt;_Other1&amp;, _Ty1&gt;, is_convertible&lt;_Other2&amp;, _Ty2&gt;&gt;)
        pair(pair&lt;_Other1, _Other2&gt;&amp; _Right) noexcept(
            is_nothrow_constructible_v&lt;_Ty1, _Other1&amp;&gt;&amp;&amp; is_nothrow_constructible_v&lt;_Ty2, _Other2&amp;&gt;) // strengthened
        : first(_Right.first), second(_Right.second) {}
#endif // _HAS_CXX23

    template &lt;class _Other1, class _Other2,
        enable_if_t&lt;conjunction_v&lt;is_constructible&lt;_Ty1, const _Other1&amp;&gt;, is_constructible&lt;_Ty2, const _Other2&amp;&gt;&gt;,
            int&gt; = 0&gt;
    constexpr explicit(!conjunction_v&lt;is_convertible&lt;const _Other1&amp;, _Ty1&gt;, is_convertible&lt;const _Other2&amp;, _Ty2&gt;&gt;)
        pair(const pair&lt;_Other1, _Other2&gt;&amp; _Right) noexcept(is_nothrow_constructible_v&lt;_Ty1, const _Other1&amp;&gt;&amp;&amp;
                is_nothrow_constructible_v&lt;_Ty2, const _Other2&amp;&gt;) // strengthened
        : first(_Right.first), second(_Right.second) {}

    template &lt;class _Other1, class _Other2,
        enable_if_t&lt;conjunction_v&lt;is_constructible&lt;_Ty1, _Other1&gt;, is_constructible&lt;_Ty2, _Other2&gt;&gt;, int&gt; = 0&gt;
    constexpr explicit(!conjunction_v&lt;is_convertible&lt;_Other1, _Ty1&gt;, is_convertible&lt;_Other2, _Ty2&gt;&gt;)
        pair(pair&lt;_Other1, _Other2&gt;&amp;&amp; _Right) noexcept(
            is_nothrow_constructible_v&lt;_Ty1, _Other1&gt;&amp;&amp; is_nothrow_constructible_v&lt;_Ty2, _Other2&gt;) // strengthened
        : first(_STD forward&lt;_Other1&gt;(_Right.first)), second(_STD forward&lt;_Other2&gt;(_Right.second)) {}

#if _HAS_CXX23
    template &lt;class _Other1, class _Other2,
        enable_if_t&lt;conjunction_v&lt;is_constructible&lt;_Ty1, const _Other1&gt;, is_constructible&lt;_Ty2, const _Other2&gt;&gt;, int&gt; =
            0&gt;
    constexpr explicit(!conjunction_v&lt;is_convertible&lt;const _Other1, _Ty1&gt;, is_convertible&lt;const _Other2, _Ty2&gt;&gt;)
        pair(const pair&lt;_Other1, _Other2&gt;&amp;&amp; _Right) noexcept(is_nothrow_constructible_v&lt;_Ty1, const _Other1&gt;&amp;&amp;
                is_nothrow_constructible_v&lt;_Ty2, const _Other2&gt;) // strengthened
        : first(_STD forward&lt;const _Other1&gt;(_Right.first)), second(_STD forward&lt;const _Other2&gt;(_Right.second)) {}

#ifdef __cpp_lib_concepts
#ifdef __clang__ // TRANSITION, LLVM-59827
    template &lt;class _Other, enable_if_t&lt;_Can_construct_from_pair_like&lt;_Other, _Ty1, _Ty2&gt;, int&gt; = 0&gt;
#else // ^^^ workaround / no workaround vvv
    template &lt;_Pair_like _Other&gt;
        requires conjunction_v&lt;is_constructible&lt;_Ty1, decltype(_STD get&lt;0&gt;(_STD declval&lt;_Other&gt;()))&gt;,
                     is_constructible&lt;_Ty2, decltype(_STD get&lt;1&gt;(_STD declval&lt;_Other&gt;()))&gt;&gt;
#endif // __clang__
    constexpr explicit(!conjunction_v&lt;is_convertible&lt;decltype(_STD get&lt;0&gt;(_STD declval&lt;_Other&gt;())), _Ty1&gt;,
                       is_convertible&lt;decltype(_STD get&lt;1&gt;(_STD declval&lt;_Other&gt;())), _Ty2&gt;&gt;)
        pair(_Other&amp;&amp; _Right) noexcept(is_nothrow_constructible_v&lt;_Ty1, decltype(_STD get&lt;0&gt;(_STD declval&lt;_Other&gt;()))&gt;&amp;&amp;
                is_nothrow_constructible_v&lt;_Ty2, decltype(_STD get&lt;1&gt;(_STD declval&lt;_Other&gt;()))&gt;) // strengthened
        : first(_STD get&lt;0&gt;(_STD forward&lt;_Other&gt;(_Right))), second(_STD get&lt;1&gt;(_STD forward&lt;_Other&gt;(_Right))) {
    }
#endif // __cpp_lib_concepts
#endif // _HAS_CXX23

    template &lt;class _Tuple1, class _Tuple2, size_t... _Indices1, size_t... _Indices2&gt;
    constexpr pair(_Tuple1&amp; _Val1, _Tuple2&amp; _Val2, index_sequence&lt;_Indices1...&gt;, index_sequence&lt;_Indices2...&gt;)
        : first(_Tuple_get&lt;_Indices1&gt;(_STD move(_Val1))...), second(_Tuple_get&lt;_Indices2&gt;(_STD move(_Val2))...) {}

    template &lt;class... _Types1, class... _Types2&gt;
    _CONSTEXPR20 pair(piecewise_construct_t, tuple&lt;_Types1...&gt; _Val1, tuple&lt;_Types2...&gt; _Val2)
        : pair(_Val1, _Val2, index_sequence_for&lt;_Types1...&gt;{}, index_sequence_for&lt;_Types2...&gt;{}) {}

    pair&amp; operator=(const volatile pair&amp;) = delete;

    template &lt;class _Myself = pair,
        enable_if_t&lt;conjunction_v&lt;_Is_copy_assignable_no_precondition_check&lt;typename _Myself::first_type&gt;,
                        _Is_copy_assignable_no_precondition_check&lt;typename _Myself::second_type&gt;&gt;,
            int&gt;            = 0&gt;
    _CONSTEXPR20 pair&amp; operator=(_Identity_t&lt;const _Myself&amp;&gt; _Right) noexcept(
        conjunction_v&lt;is_nothrow_copy_assignable&lt;_Ty1&gt;, is_nothrow_copy_assignable&lt;_Ty2&gt;&gt;) /* strengthened */ {
        first  = _Right.first;
        second = _Right.second;
        return *this;
    }

#if _HAS_CXX23
    template &lt;class _Myself = pair,
        enable_if_t&lt;conjunction_v&lt;_Is_copy_assignable_no_precondition_check&lt;const typename _Myself::first_type&gt;,
                        _Is_copy_assignable_no_precondition_check&lt;const typename _Myself::second_type&gt;&gt;,
            int&gt;            = 0&gt;
    constexpr const pair&amp; operator=(_Identity_t&lt;const _Myself&amp;&gt; _Right) const
        noexcept(conjunction_v&lt;is_nothrow_copy_assignable&lt;const _Ty1&gt;,
            is_nothrow_copy_assignable&lt;const _Ty2&gt;&gt;) /* strengthened */ {
        first  = _Right.first;
        second = _Right.second;
        return *this;
    }
#endif // _HAS_CXX23

    template &lt;class _Myself = pair,
        enable_if_t&lt;conjunction_v&lt;_Is_move_assignable_no_precondition_check&lt;typename _Myself::first_type&gt;,
                        _Is_move_assignable_no_precondition_check&lt;typename _Myself::second_type&gt;&gt;,
            int&gt;            = 0&gt;
    _CONSTEXPR20 pair&amp; operator=(_Identity_t&lt;_Myself&amp;&amp;&gt; _Right) noexcept(
        conjunction_v&lt;is_nothrow_move_assignable&lt;_Ty1&gt;, is_nothrow_move_assignable&lt;_Ty2&gt;&gt;) /* strengthened */ {
        first  = _STD forward&lt;_Ty1&gt;(_Right.first);
        second = _STD forward&lt;_Ty2&gt;(_Right.second);
        return *this;
    }

#if _HAS_CXX23
    template &lt;class _Myself = pair,
        enable_if_t&lt;conjunction_v&lt;_Is_assignable_no_precondition_check&lt;const typename _Myself::first_type&amp;, _Ty1&gt;,
                        _Is_assignable_no_precondition_check&lt;const typename _Myself::second_type&amp;, _Ty2&gt;&gt;,
            int&gt;            = 0&gt;
    constexpr const pair&amp; operator=(_Identity_t&lt;_Myself&amp;&amp;&gt; _Right) const
        noexcept(conjunction_v&lt;is_nothrow_assignable&lt;const _Ty1&amp;, _Ty1&gt;,
            is_nothrow_assignable&lt;const _Ty2&amp;, _Ty2&gt;&gt;) /* strengthened */ {
        first  = _STD forward&lt;_Ty1&gt;(_Right.first);
        second = _STD forward&lt;_Ty2&gt;(_Right.second);
        return *this;
    }
#endif // _HAS_CXX23

    template &lt;class _Other1, class _Other2,
        enable_if_t&lt;conjunction_v&lt;negation&lt;is_same&lt;pair, pair&lt;_Other1, _Other2&gt;&gt;&gt;, is_assignable&lt;_Ty1&amp;, const _Other1&amp;&gt;,
                        is_assignable&lt;_Ty2&amp;, const _Other2&amp;&gt;&gt;,
            int&gt; = 0&gt;
    _CONSTEXPR20 pair&amp; operator=(const pair&lt;_Other1, _Other2&gt;&amp; _Right) noexcept(
        is_nothrow_assignable_v&lt;_Ty1&amp;, const _Other1&amp;&gt;&amp;&amp;
            is_nothrow_assignable_v&lt;_Ty2&amp;, const _Other2&amp;&gt;) /* strengthened */ {
        first  = _Right.first;
        second = _Right.second;
        return *this;
    }

#if _HAS_CXX23
    template &lt;class _Other1, class _Other2,
        enable_if_t&lt;conjunction_v&lt;negation&lt;is_same&lt;pair, pair&lt;_Other1, _Other2&gt;&gt;&gt;,
                        is_assignable&lt;const _Ty1&amp;, const _Other1&amp;&gt;, is_assignable&lt;const _Ty2&amp;, const _Other2&amp;&gt;&gt;,
            int&gt; = 0&gt;
    constexpr const pair&amp; operator=(const pair&lt;_Other1, _Other2&gt;&amp; _Right) const
        noexcept(is_nothrow_assignable_v&lt;const _Ty1&amp;, const _Other1&amp;&gt;&amp;&amp;
                is_nothrow_assignable_v&lt;const _Ty2&amp;, const _Other2&amp;&gt;) /* strengthened */ {
        first  = _Right.first;
        second = _Right.second;
        return *this;
    }
#endif // _HAS_CXX23

    template &lt;class _Other1, class _Other2,
        enable_if_t&lt;conjunction_v&lt;negation&lt;is_same&lt;pair, pair&lt;_Other1, _Other2&gt;&gt;&gt;, is_assignable&lt;_Ty1&amp;, _Other1&gt;,
                        is_assignable&lt;_Ty2&amp;, _Other2&gt;&gt;,
            int&gt; = 0&gt;
    _CONSTEXPR20 pair&amp; operator=(pair&lt;_Other1, _Other2&gt;&amp;&amp; _Right) noexcept(
        is_nothrow_assignable_v&lt;_Ty1&amp;, _Other1&gt;&amp;&amp; is_nothrow_assignable_v&lt;_Ty2&amp;, _Other2&gt;) /* strengthened */ {
        first  = _STD forward&lt;_Other1&gt;(_Right.first);
        second = _STD forward&lt;_Other2&gt;(_Right.second);
        return *this;
    }

#if _HAS_CXX23
    template &lt;class _Other1, class _Other2,
        enable_if_t&lt;conjunction_v&lt;negation&lt;is_same&lt;pair, pair&lt;_Other1, _Other2&gt;&gt;&gt;, is_assignable&lt;const _Ty1&amp;, _Other1&gt;,
                        is_assignable&lt;const _Ty2&amp;, _Other2&gt;&gt;,
            int&gt; = 0&gt;
    constexpr const pair&amp; operator=(pair&lt;_Other1, _Other2&gt;&amp;&amp; _Right) const
        noexcept(is_nothrow_assignable_v&lt;const _Ty1&amp;, _Other1&gt;&amp;&amp;
                is_nothrow_assignable_v&lt;const _Ty2&amp;, _Other2&gt;) /* strengthened */ {
        first  = _STD forward&lt;_Other1&gt;(_Right.first);
        second = _STD forward&lt;_Other2&gt;(_Right.second);
        return *this;
    }

#ifdef __cpp_lib_concepts
    template &lt;_Pair_like _Other&gt;
        requires _Different_from&lt;_Other, pair&gt; &amp;&amp; (!_Is_subrange_v&lt;remove_cvref_t&lt;_Other&gt;&gt;)
              &amp;&amp; is_assignable_v&lt;_Ty1&amp;, decltype(_STD get&lt;0&gt;(_STD declval&lt;_Other&gt;()))&gt;
              &amp;&amp; is_assignable_v&lt;_Ty2&amp;, decltype(_STD get&lt;1&gt;(_STD declval&lt;_Other&gt;()))&gt;
    constexpr pair&amp; operator=(_Other&amp;&amp; _Right) noexcept(
        is_nothrow_assignable_v&lt;_Ty1&amp;, decltype(_STD get&lt;0&gt;(_STD declval&lt;_Other&gt;()))&gt;&amp;&amp;
            is_nothrow_assignable_v&lt;_Ty2&amp;, decltype(_STD get&lt;1&gt;(_STD declval&lt;_Other&gt;()))&gt;) /* strengthened */ {
        first  = _STD get&lt;0&gt;(_STD forward&lt;_Other&gt;(_Right));
        second = _STD get&lt;1&gt;(_STD forward&lt;_Other&gt;(_Right));
        return *this;
    }

    template &lt;_Pair_like _Other&gt;
        requires _Different_from&lt;_Other, pair&gt; &amp;&amp; (!_Is_subrange_v&lt;remove_cvref_t&lt;_Other&gt;&gt;)
              &amp;&amp; is_assignable_v&lt;const _Ty1&amp;, decltype(_STD get&lt;0&gt;(_STD declval&lt;_Other&gt;()))&gt;
              &amp;&amp; is_assignable_v&lt;const _Ty2&amp;, decltype(_STD get&lt;1&gt;(_STD declval&lt;_Other&gt;()))&gt;
    constexpr const pair&amp; operator=(_Other&amp;&amp; _Right) const noexcept(
        is_nothrow_assignable_v&lt;const _Ty1&amp;, decltype(_STD get&lt;0&gt;(_STD declval&lt;_Other&gt;()))&gt;&amp;&amp;
            is_nothrow_assignable_v&lt;const _Ty2&amp;, decltype(_STD get&lt;1&gt;(_STD declval&lt;_Other&gt;()))&gt;) /* strengthened */ {
        first  = _STD get&lt;0&gt;(_STD forward&lt;_Other&gt;(_Right));
        second = _STD get&lt;1&gt;(_STD forward&lt;_Other&gt;(_Right));
        return *this;
    }
#endif // __cpp_lib_concepts
#endif // _HAS_CXX23

    _CONSTEXPR20 void swap(pair&amp; _Right) noexcept(
        _Is_nothrow_swappable&lt;_Ty1&gt;::value&amp;&amp; _Is_nothrow_swappable&lt;_Ty2&gt;::value) {
        if (this != _STD addressof(_Right)) {
            _Swap_adl(first, _Right.first);
            _Swap_adl(second, _Right.second);
        }
    }

#if _HAS_CXX23
    template &lt;int = 0&gt; // see GH-3013
    constexpr void swap(const pair&amp; _Right) const
        noexcept(is_nothrow_swappable_v&lt;const _Ty1&gt;&amp;&amp; is_nothrow_swappable_v&lt;const _Ty2&gt;) {
        if (this != _STD addressof(_Right)) {
            _Swap_adl(first, _Right.first);
            _Swap_adl(second, _Right.second);
        }
    }
#endif // _HAS_CXX23

    _Ty1 first; // the first stored value
    _Ty2 second; // the second stored value
};

#if _HAS_CXX17
template &lt;class _Ty1, class _Ty2&gt;
pair(_Ty1, _Ty2) -&gt; pair&lt;_Ty1, _Ty2&gt;;
#endif // _HAS_CXX17

_EXPORT_STD template &lt;class _Ty1, class _Ty2,
    enable_if_t&lt;_Is_swappable&lt;_Ty1&gt;::value &amp;&amp; _Is_swappable&lt;_Ty2&gt;::value, int&gt; = 0&gt;
_CONSTEXPR20 void swap(pair&lt;_Ty1, _Ty2&gt;&amp; _Left, pair&lt;_Ty1, _Ty2&gt;&amp; _Right) noexcept(noexcept(_Left.swap(_Right))) {
    _Left.swap(_Right);
}

#if _HAS_CXX23
_EXPORT_STD template &lt;class _Ty1, class _Ty2,
    enable_if_t&lt;is_swappable_v&lt;const _Ty1&gt; &amp;&amp; is_swappable_v&lt;const _Ty2&gt;, int&gt; = 0&gt;
constexpr void swap(const pair&lt;_Ty1, _Ty2&gt;&amp; _Left, const pair&lt;_Ty1, _Ty2&gt;&amp; _Right) noexcept(
    noexcept(_Left.swap(_Right))) {
    _Left.swap(_Right);
}
#endif // _HAS_CXX23

_EXPORT_STD template &lt;class _Ty1, class _Ty2&gt;
_NODISCARD constexpr bool operator==(const pair&lt;_Ty1, _Ty2&gt;&amp; _Left, const pair&lt;_Ty1, _Ty2&gt;&amp; _Right) {
    return _Left.first == _Right.first &amp;&amp; _Left.second == _Right.second;
}

#ifdef __cpp_lib_concepts
_EXPORT_STD template &lt;class _Ty1, class _Ty2&gt;
_NODISCARD constexpr common_comparison_category_t&lt;_Synth_three_way_result&lt;_Ty1&gt;, _Synth_three_way_result&lt;_Ty2&gt;&gt;
    operator&lt;=&gt;(const pair&lt;_Ty1, _Ty2&gt;&amp; _Left, const pair&lt;_Ty1, _Ty2&gt;&amp; _Right) {
    if (auto _Result = _Synth_three_way{}(_Left.first, _Right.first); _Result != 0) {
        return _Result;
    }
    return _Synth_three_way{}(_Left.second, _Right.second);
}
#else // ^^^ defined(__cpp_lib_concepts) / !defined(__cpp_lib_concepts) vvv
#if !_HAS_CXX20
template &lt;class _Ty1, class _Ty2&gt;
_NODISCARD constexpr bool operator!=(const pair&lt;_Ty1, _Ty2&gt;&amp; _Left, const pair&lt;_Ty1, _Ty2&gt;&amp; _Right) {
    return !(_Left == _Right);
}
#endif // !_HAS_CXX20

template &lt;class _Ty1, class _Ty2&gt;
_NODISCARD constexpr bool operator&lt;(const pair&lt;_Ty1, _Ty2&gt;&amp; _Left, const pair&lt;_Ty1, _Ty2&gt;&amp; _Right) {
    return _Left.first &lt; _Right.first || (!(_Right.first &lt; _Left.first) &amp;&amp; _Left.second &lt; _Right.second);
}

template &lt;class _Ty1, class _Ty2&gt;
_NODISCARD constexpr bool operator&gt;(const pair&lt;_Ty1, _Ty2&gt;&amp; _Left, const pair&lt;_Ty1, _Ty2&gt;&amp; _Right) {
    return _Right &lt; _Left;
}

template &lt;class _Ty1, class _Ty2&gt;
_NODISCARD constexpr bool operator&lt;=(const pair&lt;_Ty1, _Ty2&gt;&amp; _Left, const pair&lt;_Ty1, _Ty2&gt;&amp; _Right) {
    return !(_Right &lt; _Left);
}

template &lt;class _Ty1, class _Ty2&gt;
_NODISCARD constexpr bool operator&gt;=(const pair&lt;_Ty1, _Ty2&gt;&amp; _Left, const pair&lt;_Ty1, _Ty2&gt;&amp; _Right) {
    return !(_Left &lt; _Right);
}
#endif // ^^^ !defined(__cpp_lib_concepts) ^^^

#ifdef __cpp_lib_concepts
template &lt;class _Ty1, class _Ty2, class _Uty1, class _Uty2, template &lt;class&gt; class _TQual,
    template &lt;class&gt; class _UQual&gt;
    requires requires {
                 typename pair&lt;common_reference_t&lt;_TQual&lt;_Ty1&gt;, _UQual&lt;_Uty1&gt;&gt;,
                     common_reference_t&lt;_TQual&lt;_Ty2&gt;, _UQual&lt;_Uty2&gt;&gt;&gt;;
             }
struct basic_common_reference&lt;pair&lt;_Ty1, _Ty2&gt;, pair&lt;_Uty1, _Uty2&gt;, _TQual, _UQual&gt; {
    using type = pair&lt;common_reference_t&lt;_TQual&lt;_Ty1&gt;, _UQual&lt;_Uty1&gt;&gt;, common_reference_t&lt;_TQual&lt;_Ty2&gt;, _UQual&lt;_Uty2&gt;&gt;&gt;;
};

template &lt;class _Ty1, class _Ty2, class _Uty1, class _Uty2&gt;
    requires requires { typename pair&lt;common_type_t&lt;_Ty1, _Uty1&gt;, common_type_t&lt;_Ty2, _Uty2&gt;&gt;; }
struct common_type&lt;pair&lt;_Ty1, _Ty2&gt;, pair&lt;_Uty1, _Uty2&gt;&gt; {
    using type = pair&lt;common_type_t&lt;_Ty1, _Uty1&gt;, common_type_t&lt;_Ty2, _Uty2&gt;&gt;;
};
#endif // __cpp_lib_concepts

template &lt;class _Ty&gt;
struct _Unrefwrap_helper { // leave unchanged if not a reference_wrapper
    using type = _Ty;
};

template &lt;class _Ty&gt;
struct _Unrefwrap_helper&lt;reference_wrapper&lt;_Ty&gt;&gt; { // make a reference from a reference_wrapper
    using type = _Ty&amp;;
};

// decay, then unwrap a reference_wrapper
template &lt;class _Ty&gt;
using _Unrefwrap_t = typename _Unrefwrap_helper&lt;decay_t&lt;_Ty&gt;&gt;::type;

_EXPORT_STD template &lt;class _Ty1, class _Ty2&gt;
_NODISCARD constexpr pair&lt;_Unrefwrap_t&lt;_Ty1&gt;, _Unrefwrap_t&lt;_Ty2&gt;&gt; make_pair(_Ty1&amp;&amp; _Val1, _Ty2&amp;&amp; _Val2) noexcept(
    is_nothrow_constructible_v&lt;_Unrefwrap_t&lt;_Ty1&gt;, _Ty1&gt;&amp;&amp;
        is_nothrow_constructible_v&lt;_Unrefwrap_t&lt;_Ty2&gt;, _Ty2&gt;) /* strengthened */ {
    // return pair composed from arguments
    using _Mypair = pair&lt;_Unrefwrap_t&lt;_Ty1&gt;, _Unrefwrap_t&lt;_Ty2&gt;&gt;;
    return _Mypair(_STD forward&lt;_Ty1&gt;(_Val1), _STD forward&lt;_Ty2&gt;(_Val2));
}

namespace _CXX20_DEPRECATE_REL_OPS rel_ops {
    _EXPORT_STD template &lt;class _Ty&gt;
    _CXX20_DEPRECATE_REL_OPS _NODISCARD bool operator!=(const _Ty&amp; _Left, const _Ty&amp; _Right) {
        return !(_Left == _Right);
    }

    _EXPORT_STD template &lt;class _Ty&gt;
    _CXX20_DEPRECATE_REL_OPS _NODISCARD bool operator&gt;(const _Ty&amp; _Left, const _Ty&amp; _Right) {
        return _Right &lt; _Left;
    }

    _EXPORT_STD template &lt;class _Ty&gt;
    _CXX20_DEPRECATE_REL_OPS _NODISCARD bool operator&lt;=(const _Ty&amp; _Left, const _Ty&amp; _Right) {
        return !(_Right &lt; _Left);
    }

    _EXPORT_STD template &lt;class _Ty&gt;
    _CXX20_DEPRECATE_REL_OPS _NODISCARD bool operator&gt;=(const _Ty&amp; _Left, const _Ty&amp; _Right) {
        return !(_Left &lt; _Right);
    }
} // namespace _CXX20_DEPRECATE_REL_OPS rel_ops

template &lt;class _Tuple, class = void&gt;
struct _Tuple_size_sfinae {}; // selected when tuple_size&lt;_Tuple&gt;::value isn't well-formed

template &lt;class _Tuple&gt;
struct _Tuple_size_sfinae&lt;_Tuple, void_t&lt;decltype(tuple_size&lt;_Tuple&gt;::value)&gt;&gt;
    : integral_constant&lt;size_t, tuple_size&lt;_Tuple&gt;::value&gt; {}; // selected when tuple_size&lt;_Tuple&gt;::value is well-formed

template &lt;class _Tuple&gt;
struct tuple_size&lt;const _Tuple&gt; : _Tuple_size_sfinae&lt;_Tuple&gt; {}; // ignore cv

template &lt;class _Tuple&gt;
struct _CXX20_DEPRECATE_VOLATILE tuple_size&lt;volatile _Tuple&gt; : _Tuple_size_sfinae&lt;_Tuple&gt; {}; // ignore cv

template &lt;class _Tuple&gt;
struct _CXX20_DEPRECATE_VOLATILE tuple_size&lt;const volatile _Tuple&gt; : _Tuple_size_sfinae&lt;_Tuple&gt; {}; // ignore cv

template &lt;size_t _Index, class _Tuple&gt;
struct _MSVC_KNOWN_SEMANTICS tuple_element&lt;_Index, const _Tuple&gt; : tuple_element&lt;_Index, _Tuple&gt; {
    using _Mybase = tuple_element&lt;_Index, _Tuple&gt;;
    using type    = add_const_t&lt;typename _Mybase::type&gt;;
};

template &lt;size_t _Index, class _Tuple&gt;
struct _CXX20_DEPRECATE_VOLATILE _MSVC_KNOWN_SEMANTICS tuple_element&lt;_Index, volatile _Tuple&gt;
    : tuple_element&lt;_Index, _Tuple&gt; {
    using _Mybase = tuple_element&lt;_Index, _Tuple&gt;;
    using type    = add_volatile_t&lt;typename _Mybase::type&gt;;
};

template &lt;size_t _Index, class _Tuple&gt;
struct _CXX20_DEPRECATE_VOLATILE _MSVC_KNOWN_SEMANTICS tuple_element&lt;_Index, const volatile _Tuple&gt;
    : tuple_element&lt;_Index, _Tuple&gt; {
    using _Mybase = tuple_element&lt;_Index, _Tuple&gt;;
    using type    = add_cv_t&lt;typename _Mybase::type&gt;;
};

template &lt;class _Ty, size_t _Size&gt;
struct tuple_size&lt;array&lt;_Ty, _Size&gt;&gt; : integral_constant&lt;size_t, _Size&gt; {}; // size of array

template &lt;size_t _Idx, class _Ty, size_t _Size&gt;
struct _MSVC_KNOWN_SEMANTICS tuple_element&lt;_Idx, array&lt;_Ty, _Size&gt;&gt; {
    static_assert(_Idx &lt; _Size, "array index out of bounds");

    using type = _Ty;
};

template &lt;class... _Types&gt;
struct tuple_size&lt;tuple&lt;_Types...&gt;&gt; : integral_constant&lt;size_t, sizeof...(_Types)&gt; {}; // size of tuple

template &lt;size_t _Index&gt;
struct _MSVC_KNOWN_SEMANTICS tuple_element&lt;_Index, tuple&lt;&gt;&gt; { // enforce bounds checking
    static_assert(_Always_false&lt;integral_constant&lt;size_t, _Index&gt;&gt;, "tuple index out of bounds");
};

template &lt;class _This, class... _Rest&gt;
struct _MSVC_KNOWN_SEMANTICS tuple_element&lt;0, tuple&lt;_This, _Rest...&gt;&gt; { // select first element
    using type = _This;
    // MSVC assumes the meaning of _Ttype; remove or rename, but do not change semantics
    using _Ttype = tuple&lt;_This, _Rest...&gt;;
};

template &lt;size_t _Index, class _This, class... _Rest&gt;
struct _MSVC_KNOWN_SEMANTICS tuple_element&lt;_Index, tuple&lt;_This, _Rest...&gt;&gt;
    : tuple_element&lt;_Index - 1, tuple&lt;_Rest...&gt;&gt; {}; // recursive tuple_element definition

template &lt;class _Ty1, class _Ty2&gt;
struct tuple_size&lt;pair&lt;_Ty1, _Ty2&gt;&gt; : integral_constant&lt;size_t, 2&gt; {}; // size of pair

template &lt;size_t _Idx, class _Ty1, class _Ty2&gt;
struct _MSVC_KNOWN_SEMANTICS tuple_element&lt;_Idx, pair&lt;_Ty1, _Ty2&gt;&gt; {
    static_assert(_Idx &lt; 2, "pair index out of bounds");

    using type = conditional_t&lt;_Idx == 0, _Ty1, _Ty2&gt;;
};

_EXPORT_STD template &lt;size_t _Idx, class _Ty1, class _Ty2&gt;
_NODISCARD constexpr tuple_element_t&lt;_Idx, pair&lt;_Ty1, _Ty2&gt;&gt;&amp; get(pair&lt;_Ty1, _Ty2&gt;&amp; _Pr) noexcept {
    // get reference to element at _Idx in pair _Pr
    if constexpr (_Idx == 0) {
        return _Pr.first;
    } else {
        return _Pr.second;
    }
}

_EXPORT_STD template &lt;class _Ty1, class _Ty2&gt;
_NODISCARD constexpr _Ty1&amp; get(pair&lt;_Ty1, _Ty2&gt;&amp; _Pr) noexcept {
    // get reference to element _Ty1 in pair _Pr
    return _Pr.first;
}

_EXPORT_STD template &lt;class _Ty2, class _Ty1&gt;
_NODISCARD constexpr _Ty2&amp; get(pair&lt;_Ty1, _Ty2&gt;&amp; _Pr) noexcept {
    // get reference to element _Ty2 in pair _Pr
    return _Pr.second;
}

_EXPORT_STD template &lt;size_t _Idx, class _Ty1, class _Ty2&gt;
_NODISCARD constexpr const tuple_element_t&lt;_Idx, pair&lt;_Ty1, _Ty2&gt;&gt;&amp; get(const pair&lt;_Ty1, _Ty2&gt;&amp; _Pr) noexcept {
    // get const reference to element at _Idx in pair _Pr
    if constexpr (_Idx == 0) {
        return _Pr.first;
    } else {
        return _Pr.second;
    }
}

_EXPORT_STD template &lt;class _Ty1, class _Ty2&gt;
_NODISCARD constexpr const _Ty1&amp; get(const pair&lt;_Ty1, _Ty2&gt;&amp; _Pr) noexcept {
    // get const reference to element _Ty1 in pair _Pr
    return _Pr.first;
}

_EXPORT_STD template &lt;class _Ty2, class _Ty1&gt;
_NODISCARD constexpr const _Ty2&amp; get(const pair&lt;_Ty1, _Ty2&gt;&amp; _Pr) noexcept {
    // get const reference to element _Ty2 in pair _Pr
    return _Pr.second;
}

_EXPORT_STD template &lt;size_t _Idx, class _Ty1, class _Ty2&gt;
_NODISCARD constexpr tuple_element_t&lt;_Idx, pair&lt;_Ty1, _Ty2&gt;&gt;&amp;&amp; get(pair&lt;_Ty1, _Ty2&gt;&amp;&amp; _Pr) noexcept {
    // get rvalue reference to element at _Idx in pair _Pr
    if constexpr (_Idx == 0) {
        return _STD forward&lt;_Ty1&gt;(_Pr.first);
    } else {
        return _STD forward&lt;_Ty2&gt;(_Pr.second);
    }
}

_EXPORT_STD template &lt;class _Ty1, class _Ty2&gt;
_NODISCARD constexpr _Ty1&amp;&amp; get(pair&lt;_Ty1, _Ty2&gt;&amp;&amp; _Pr) noexcept {
    // get rvalue reference to element _Ty1 in pair _Pr
    return _STD forward&lt;_Ty1&gt;(_Pr.first);
}

_EXPORT_STD template &lt;class _Ty2, class _Ty1&gt;
_NODISCARD constexpr _Ty2&amp;&amp; get(pair&lt;_Ty1, _Ty2&gt;&amp;&amp; _Pr) noexcept {
    // get rvalue reference to element _Ty2 in pair _Pr
    return _STD forward&lt;_Ty2&gt;(_Pr.second);
}

_EXPORT_STD template &lt;size_t _Idx, class _Ty1, class _Ty2&gt;
_NODISCARD constexpr const tuple_element_t&lt;_Idx, pair&lt;_Ty1, _Ty2&gt;&gt;&amp;&amp; get(const pair&lt;_Ty1, _Ty2&gt;&amp;&amp; _Pr) noexcept {
    // get const rvalue reference to element at _Idx in pair _Pr
    if constexpr (_Idx == 0) {
        return _STD forward&lt;const _Ty1&gt;(_Pr.first);
    } else {
        return _STD forward&lt;const _Ty2&gt;(_Pr.second);
    }
}

_EXPORT_STD template &lt;class _Ty1, class _Ty2&gt;
_NODISCARD constexpr const _Ty1&amp;&amp; get(const pair&lt;_Ty1, _Ty2&gt;&amp;&amp; _Pr) noexcept {
    // get const rvalue reference to element _Ty1 in pair _Pr
    return _STD forward&lt;const _Ty1&gt;(_Pr.first);
}

_EXPORT_STD template &lt;class _Ty2, class _Ty1&gt;
_NODISCARD constexpr const _Ty2&amp;&amp; get(const pair&lt;_Ty1, _Ty2&gt;&amp;&amp; _Pr) noexcept {
    // get const rvalue reference to element _Ty2 in pair _Pr
    return _STD forward&lt;const _Ty2&gt;(_Pr.second);
}

_EXPORT_STD template &lt;class _Ty, class _Other = _Ty&gt;
_CONSTEXPR20 _Ty exchange(_Ty&amp; _Val, _Other&amp;&amp; _New_val) noexcept(
<span style = "background-color:#dfd">    conjunction_v&lt;is_nothrow_move_constructible&lt;_Ty&gt;, is_nothrow_assignable&lt;_Ty&amp;, _Other&gt;&gt;) {</span>
    // assign _New_val to _Val, return previous _Val
<span style = "background-color:#dfd">    _Ty _Old_val = static_cast&lt;_Ty&amp;&amp;&gt;(_Val);
    _Val         = static_cast&lt;_Other&amp;&amp;&gt;(_New_val);
    return _Old_val;
}</span>

_EXPORT_STD template &lt;class _Ty&gt;
_NODISCARD constexpr add_const_t&lt;_Ty&gt;&amp; as_const(_Ty&amp; _Val) noexcept { // view _Val through const lenses
    return _Val;
}

_EXPORT_STD template &lt;class _Ty&gt;
void as_const(const _Ty&amp;&amp;) = delete;

#if _HAS_CXX17
_EXPORT_STD struct in_place_t { // tag used to select a constructor which initializes a contained object in place
    explicit in_place_t() = default;
};
_EXPORT_STD inline constexpr in_place_t in_place{};

_EXPORT_STD template &lt;class&gt;
struct in_place_type_t { // tag that selects a type to construct in place
    explicit in_place_type_t() = default;
};
_EXPORT_STD template &lt;class _Ty&gt;
inline constexpr in_place_type_t&lt;_Ty&gt; in_place_type{};

_EXPORT_STD template &lt;size_t&gt;
struct in_place_index_t { // tag that selects the index of a type to construct in place
    explicit in_place_index_t() = default;
};
_EXPORT_STD template &lt;size_t _Idx&gt;
inline constexpr in_place_index_t&lt;_Idx&gt; in_place_index{};
#endif // _HAS_CXX17

#if _HAS_CXX20
template &lt;class _Ty&gt;
inline constexpr bool _Is_standard_integer = is_integral_v&lt;_Ty&gt;
                                          &amp;&amp; !_Is_any_of_v&lt;remove_cv_t&lt;_Ty&gt;, bool, char,
#ifdef _NATIVE_WCHAR_T_DEFINED
                                              wchar_t,
#endif // _NATIVE_WCHAR_T_DEFINED
#ifdef __cpp_char8_t
                                              char8_t,
#endif // __cpp_char8_t
                                              char16_t, char32_t&gt;;

_EXPORT_STD template &lt;class _Ty1, class _Ty2&gt;
_NODISCARD constexpr bool cmp_equal(const _Ty1 _Left, const _Ty2 _Right) noexcept {
    static_assert(_Is_standard_integer&lt;_Ty1&gt; &amp;&amp; _Is_standard_integer&lt;_Ty2&gt;,
        "The integer comparison functions only accept standard and extended integer types.");
    if constexpr (is_signed_v&lt;_Ty1&gt; == is_signed_v&lt;_Ty2&gt;) {
        return _Left == _Right;
    } else if constexpr (is_signed_v&lt;_Ty2&gt;) {
        return _Left == static_cast&lt;make_unsigned_t&lt;_Ty2&gt;&gt;(_Right) &amp;&amp; _Right &gt;= 0;
    } else {
        return static_cast&lt;make_unsigned_t&lt;_Ty1&gt;&gt;(_Left) == _Right &amp;&amp; _Left &gt;= 0;
    }
}

_EXPORT_STD template &lt;class _Ty1, class _Ty2&gt;
_NODISCARD constexpr bool cmp_not_equal(const _Ty1 _Left, const _Ty2 _Right) noexcept {
    return !_STD cmp_equal(_Left, _Right);
}

_EXPORT_STD template &lt;class _Ty1, class _Ty2&gt;
_NODISCARD constexpr bool cmp_less(const _Ty1 _Left, const _Ty2 _Right) noexcept {
    static_assert(_Is_standard_integer&lt;_Ty1&gt; &amp;&amp; _Is_standard_integer&lt;_Ty2&gt;,
        "The integer comparison functions only accept standard and extended integer types.");
    if constexpr (is_signed_v&lt;_Ty1&gt; == is_signed_v&lt;_Ty2&gt;) {
        return _Left &lt; _Right;
    } else if constexpr (is_signed_v&lt;_Ty2&gt;) {
        return _Right &gt; 0 &amp;&amp; _Left &lt; static_cast&lt;make_unsigned_t&lt;_Ty2&gt;&gt;(_Right);
    } else {
        return _Left &lt; 0 || static_cast&lt;make_unsigned_t&lt;_Ty1&gt;&gt;(_Left) &lt; _Right;
    }
}

_EXPORT_STD template &lt;class _Ty1, class _Ty2&gt;
_NODISCARD constexpr bool cmp_greater(const _Ty1 _Left, const _Ty2 _Right) noexcept {
    return _STD cmp_less(_Right, _Left);
}

_EXPORT_STD template &lt;class _Ty1, class _Ty2&gt;
_NODISCARD constexpr bool cmp_less_equal(const _Ty1 _Left, const _Ty2 _Right) noexcept {
    return !_STD cmp_less(_Right, _Left);
}

_EXPORT_STD template &lt;class _Ty1, class _Ty2&gt;
_NODISCARD constexpr bool cmp_greater_equal(const _Ty1 _Left, const _Ty2 _Right) noexcept {
    return !_STD cmp_less(_Left, _Right);
}

template &lt;class _Ty&gt;
_NODISCARD _CONSTEVAL _Ty _Min_limit() noexcept { // same as (numeric_limits&lt;_Ty&gt;::min)(), less throughput cost
    static_assert(_Is_standard_integer&lt;_Ty&gt;); // doesn't attempt to handle all types
    if constexpr (is_signed_v&lt;_Ty&gt;) {
        constexpr auto _Unsigned_max = static_cast&lt;make_unsigned_t&lt;_Ty&gt;&gt;(-1);
        return static_cast&lt;_Ty&gt;((_Unsigned_max &gt;&gt; 1) + 1); // well-defined, N4861 [conv.integral]/3
    } else {
        return 0;
    }
}

template &lt;class _Ty&gt;
_NODISCARD _CONSTEVAL _Ty _Max_limit() noexcept { // same as (numeric_limits&lt;_Ty&gt;::max)(), less throughput cost
    static_assert(_Is_standard_integer&lt;_Ty&gt;); // doesn't attempt to handle all types
    if constexpr (is_signed_v&lt;_Ty&gt;) {
        constexpr auto _Unsigned_max = static_cast&lt;make_unsigned_t&lt;_Ty&gt;&gt;(-1);
        return static_cast&lt;_Ty&gt;(_Unsigned_max &gt;&gt; 1);
    } else {
        return static_cast&lt;_Ty&gt;(-1);
    }
}

_EXPORT_STD template &lt;class _Rx, class _Ty&gt;
_NODISCARD constexpr bool in_range(const _Ty _Value) noexcept {
    static_assert(_Is_standard_integer&lt;_Rx&gt; &amp;&amp; _Is_standard_integer&lt;_Ty&gt;,
        "The integer comparison functions only accept standard and extended integer types.");

    constexpr auto _Ty_min = _Min_limit&lt;_Ty&gt;();
    constexpr auto _Rx_min = _Min_limit&lt;_Rx&gt;();

    if constexpr (_STD cmp_less(_Ty_min, _Rx_min)) {
        if (_Value &lt; _Ty{_Rx_min}) {
            return false;
        }
    }

    constexpr auto _Ty_max = _Max_limit&lt;_Ty&gt;();
    constexpr auto _Rx_max = _Max_limit&lt;_Rx&gt;();

    if constexpr (_STD cmp_greater(_Ty_max, _Rx_max)) {
        if (_Value &gt; _Ty{_Rx_max}) {
            return false;
        }
    }

    return true;
}

#ifdef __cpp_lib_concepts
template &lt;class _Ty&gt;
using _With_reference = _Ty&amp;;

template &lt;class _Ty&gt;
concept _Can_reference = requires { typename _With_reference&lt;_Ty&gt;; };
#else // __cpp_lib_concepts
template &lt;class _Ty, class = void&gt;
inline constexpr bool _Can_reference = false;

template &lt;class _Ty&gt;
inline constexpr bool _Can_reference&lt;_Ty, void_t&lt;_Ty&amp;&gt;&gt; = true;
#endif // __cpp_lib_concepts
#endif // _HAS_CXX20

#if _HAS_CXX23
_EXPORT_STD template &lt;class _Ty&gt;
_NODISCARD constexpr underlying_type_t&lt;_Ty&gt; to_underlying(_Ty _Value) noexcept {
    return static_cast&lt;underlying_type_t&lt;_Ty&gt;&gt;(_Value);
}

_EXPORT_STD [[noreturn]] __forceinline void unreachable() noexcept /* strengthened */ {
    _STL_UNREACHABLE;
#ifdef _DEBUG
    _CSTD abort(); // likely to be called in debug mode, but can't be relied upon - already entered the UB territory
#endif // _DEBUG
}

_EXPORT_STD template &lt;class _Ty, class _Uty&gt;
_NODISCARD _MSVC_INTRINSIC constexpr auto&amp;&amp; forward_like(_Uty&amp;&amp; _Ux) noexcept {
    static_assert(_Can_reference&lt;_Ty&gt;, "std::forward_like's first template argument must be a referenceable type.");

    using _UnrefT = remove_reference_t&lt;_Ty&gt;;
    using _UnrefU = remove_reference_t&lt;_Uty&gt;;
    if constexpr (is_const_v&lt;_UnrefT&gt;) {
        if constexpr (is_lvalue_reference_v&lt;_Ty&gt;) {
            return static_cast&lt;const _UnrefU&amp;&gt;(_Ux);
        } else {
            return static_cast&lt;const _UnrefU&amp;&amp;&gt;(_Ux);
        }
    } else {
        if constexpr (is_lvalue_reference_v&lt;_Ty&gt;) {
            return static_cast&lt;_UnrefU&amp;&gt;(_Ux);
        } else {
            return static_cast&lt;_UnrefU&amp;&amp;&gt;(_Ux);
        }
    }
}

template &lt;class _Ty, class _Uty&gt;
using _Forward_like_t = decltype(_STD forward_like&lt;_Ty&gt;(_STD declval&lt;_Uty&amp;&gt;()));
#endif // _HAS_CXX23

#if _HAS_TR1_NAMESPACE
namespace _DEPRECATE_TR1_NAMESPACE tr1 {
    using _STD get;
    using _STD tuple_element;
    using _STD tuple_size;
} // namespace _DEPRECATE_TR1_NAMESPACE tr1
#endif // _HAS_TR1_NAMESPACE

_STD_END

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _UTILITY_</pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>